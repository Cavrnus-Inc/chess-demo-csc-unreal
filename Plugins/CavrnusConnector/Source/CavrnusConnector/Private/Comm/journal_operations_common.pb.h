// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: journal_operations_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_journal_5foperations_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_journal_5foperations_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "common.pb.h"
#include "journaldata.pb.h"
#include "properties.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_journal_5foperations_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_journal_5foperations_5fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_journal_5foperations_5fcommon_2eproto;
namespace Journal {
class OpBlindDataOp;
struct OpBlindDataOpDefaultTypeInternal;
extern OpBlindDataOpDefaultTypeInternal _OpBlindDataOp_default_instance_;
class OpDeclareProperty;
struct OpDeclarePropertyDefaultTypeInternal;
extern OpDeclarePropertyDefaultTypeInternal _OpDeclareProperty_default_instance_;
class OpDeclareProperty_V1;
struct OpDeclareProperty_V1DefaultTypeInternal;
extern OpDeclareProperty_V1DefaultTypeInternal _OpDeclareProperty_V1_default_instance_;
class OpImage2d;
struct OpImage2dDefaultTypeInternal;
extern OpImage2dDefaultTypeInternal _OpImage2d_default_instance_;
class OpImage2d_V1;
struct OpImage2d_V1DefaultTypeInternal;
extern OpImage2d_V1DefaultTypeInternal _OpImage2d_V1_default_instance_;
class OpImage3d;
struct OpImage3dDefaultTypeInternal;
extern OpImage3dDefaultTypeInternal _OpImage3d_default_instance_;
class OpImage3d_V1;
struct OpImage3d_V1DefaultTypeInternal;
extern OpImage3d_V1DefaultTypeInternal _OpImage3d_V1_default_instance_;
class OpLine2d;
struct OpLine2dDefaultTypeInternal;
extern OpLine2dDefaultTypeInternal _OpLine2d_default_instance_;
class OpLine2d_V1;
struct OpLine2d_V1DefaultTypeInternal;
extern OpLine2d_V1DefaultTypeInternal _OpLine2d_V1_default_instance_;
class OpLine3d;
struct OpLine3dDefaultTypeInternal;
extern OpLine3dDefaultTypeInternal _OpLine3d_default_instance_;
class OpLine3d_V1;
struct OpLine3d_V1DefaultTypeInternal;
extern OpLine3d_V1DefaultTypeInternal _OpLine3d_V1_default_instance_;
class OpRemoveOps;
struct OpRemoveOpsDefaultTypeInternal;
extern OpRemoveOpsDefaultTypeInternal _OpRemoveOps_default_instance_;
class OpRemoveOps_V1;
struct OpRemoveOps_V1DefaultTypeInternal;
extern OpRemoveOps_V1DefaultTypeInternal _OpRemoveOps_V1_default_instance_;
class OpRemoveOps_V2;
struct OpRemoveOps_V2DefaultTypeInternal;
extern OpRemoveOps_V2DefaultTypeInternal _OpRemoveOps_V2_default_instance_;
class OpSetPartHighlight;
struct OpSetPartHighlightDefaultTypeInternal;
extern OpSetPartHighlightDefaultTypeInternal _OpSetPartHighlight_default_instance_;
class OpSetPartHighlight_V1;
struct OpSetPartHighlight_V1DefaultTypeInternal;
extern OpSetPartHighlight_V1DefaultTypeInternal _OpSetPartHighlight_V1_default_instance_;
class OpText2d;
struct OpText2dDefaultTypeInternal;
extern OpText2dDefaultTypeInternal _OpText2d_default_instance_;
class OpText2dModify;
struct OpText2dModifyDefaultTypeInternal;
extern OpText2dModifyDefaultTypeInternal _OpText2dModify_default_instance_;
class OpText2dModify_V1;
struct OpText2dModify_V1DefaultTypeInternal;
extern OpText2dModify_V1DefaultTypeInternal _OpText2dModify_V1_default_instance_;
class OpText2d_V1;
struct OpText2d_V1DefaultTypeInternal;
extern OpText2d_V1DefaultTypeInternal _OpText2d_V1_default_instance_;
class OpText3d;
struct OpText3dDefaultTypeInternal;
extern OpText3dDefaultTypeInternal _OpText3d_default_instance_;
class OpText3dModify;
struct OpText3dModifyDefaultTypeInternal;
extern OpText3dModifyDefaultTypeInternal _OpText3dModify_default_instance_;
class OpText3dModify_V1;
struct OpText3dModify_V1DefaultTypeInternal;
extern OpText3dModify_V1DefaultTypeInternal _OpText3dModify_V1_default_instance_;
class OpText3d_V1;
struct OpText3d_V1DefaultTypeInternal;
extern OpText3d_V1DefaultTypeInternal _OpText3d_V1_default_instance_;
class OpUpdatePropertyValue;
struct OpUpdatePropertyValueDefaultTypeInternal;
extern OpUpdatePropertyValueDefaultTypeInternal _OpUpdatePropertyValue_default_instance_;
class OpUpdatePropertyValue_V1;
struct OpUpdatePropertyValue_V1DefaultTypeInternal;
extern OpUpdatePropertyValue_V1DefaultTypeInternal _OpUpdatePropertyValue_V1_default_instance_;
class OpUserAuthorityData;
struct OpUserAuthorityDataDefaultTypeInternal;
extern OpUserAuthorityDataDefaultTypeInternal _OpUserAuthorityData_default_instance_;
class OpUserAuthorityData_V1;
struct OpUserAuthorityData_V1DefaultTypeInternal;
extern OpUserAuthorityData_V1DefaultTypeInternal _OpUserAuthorityData_V1_default_instance_;
class OperationId;
struct OperationIdDefaultTypeInternal;
extern OperationIdDefaultTypeInternal _OperationId_default_instance_;
class OperationReferenceCollection;
struct OperationReferenceCollectionDefaultTypeInternal;
extern OperationReferenceCollectionDefaultTypeInternal _OperationReferenceCollection_default_instance_;
class OperationReferenceCollection_ReferenceSinglesByConnection;
struct OperationReferenceCollection_ReferenceSinglesByConnectionDefaultTypeInternal;
extern OperationReferenceCollection_ReferenceSinglesByConnectionDefaultTypeInternal _OperationReferenceCollection_ReferenceSinglesByConnection_default_instance_;
class OperationReferenceCollection_ReferenceTimeSpan;
struct OperationReferenceCollection_ReferenceTimeSpanDefaultTypeInternal;
extern OperationReferenceCollection_ReferenceTimeSpanDefaultTypeInternal _OperationReferenceCollection_ReferenceTimeSpan_default_instance_;
class UserAuthorityPayload;
struct UserAuthorityPayloadDefaultTypeInternal;
extern UserAuthorityPayloadDefaultTypeInternal _UserAuthorityPayload_default_instance_;
}  // namespace Journal
PROTOBUF_NAMESPACE_OPEN
template<> ::Journal::OpBlindDataOp* Arena::CreateMaybeMessage<::Journal::OpBlindDataOp>(Arena*);
template<> ::Journal::OpDeclareProperty* Arena::CreateMaybeMessage<::Journal::OpDeclareProperty>(Arena*);
template<> ::Journal::OpDeclareProperty_V1* Arena::CreateMaybeMessage<::Journal::OpDeclareProperty_V1>(Arena*);
template<> ::Journal::OpImage2d* Arena::CreateMaybeMessage<::Journal::OpImage2d>(Arena*);
template<> ::Journal::OpImage2d_V1* Arena::CreateMaybeMessage<::Journal::OpImage2d_V1>(Arena*);
template<> ::Journal::OpImage3d* Arena::CreateMaybeMessage<::Journal::OpImage3d>(Arena*);
template<> ::Journal::OpImage3d_V1* Arena::CreateMaybeMessage<::Journal::OpImage3d_V1>(Arena*);
template<> ::Journal::OpLine2d* Arena::CreateMaybeMessage<::Journal::OpLine2d>(Arena*);
template<> ::Journal::OpLine2d_V1* Arena::CreateMaybeMessage<::Journal::OpLine2d_V1>(Arena*);
template<> ::Journal::OpLine3d* Arena::CreateMaybeMessage<::Journal::OpLine3d>(Arena*);
template<> ::Journal::OpLine3d_V1* Arena::CreateMaybeMessage<::Journal::OpLine3d_V1>(Arena*);
template<> ::Journal::OpRemoveOps* Arena::CreateMaybeMessage<::Journal::OpRemoveOps>(Arena*);
template<> ::Journal::OpRemoveOps_V1* Arena::CreateMaybeMessage<::Journal::OpRemoveOps_V1>(Arena*);
template<> ::Journal::OpRemoveOps_V2* Arena::CreateMaybeMessage<::Journal::OpRemoveOps_V2>(Arena*);
template<> ::Journal::OpSetPartHighlight* Arena::CreateMaybeMessage<::Journal::OpSetPartHighlight>(Arena*);
template<> ::Journal::OpSetPartHighlight_V1* Arena::CreateMaybeMessage<::Journal::OpSetPartHighlight_V1>(Arena*);
template<> ::Journal::OpText2d* Arena::CreateMaybeMessage<::Journal::OpText2d>(Arena*);
template<> ::Journal::OpText2dModify* Arena::CreateMaybeMessage<::Journal::OpText2dModify>(Arena*);
template<> ::Journal::OpText2dModify_V1* Arena::CreateMaybeMessage<::Journal::OpText2dModify_V1>(Arena*);
template<> ::Journal::OpText2d_V1* Arena::CreateMaybeMessage<::Journal::OpText2d_V1>(Arena*);
template<> ::Journal::OpText3d* Arena::CreateMaybeMessage<::Journal::OpText3d>(Arena*);
template<> ::Journal::OpText3dModify* Arena::CreateMaybeMessage<::Journal::OpText3dModify>(Arena*);
template<> ::Journal::OpText3dModify_V1* Arena::CreateMaybeMessage<::Journal::OpText3dModify_V1>(Arena*);
template<> ::Journal::OpText3d_V1* Arena::CreateMaybeMessage<::Journal::OpText3d_V1>(Arena*);
template<> ::Journal::OpUpdatePropertyValue* Arena::CreateMaybeMessage<::Journal::OpUpdatePropertyValue>(Arena*);
template<> ::Journal::OpUpdatePropertyValue_V1* Arena::CreateMaybeMessage<::Journal::OpUpdatePropertyValue_V1>(Arena*);
template<> ::Journal::OpUserAuthorityData* Arena::CreateMaybeMessage<::Journal::OpUserAuthorityData>(Arena*);
template<> ::Journal::OpUserAuthorityData_V1* Arena::CreateMaybeMessage<::Journal::OpUserAuthorityData_V1>(Arena*);
template<> ::Journal::OperationId* Arena::CreateMaybeMessage<::Journal::OperationId>(Arena*);
template<> ::Journal::OperationReferenceCollection* Arena::CreateMaybeMessage<::Journal::OperationReferenceCollection>(Arena*);
template<> ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* Arena::CreateMaybeMessage<::Journal::OperationReferenceCollection_ReferenceSinglesByConnection>(Arena*);
template<> ::Journal::OperationReferenceCollection_ReferenceTimeSpan* Arena::CreateMaybeMessage<::Journal::OperationReferenceCollection_ReferenceTimeSpan>(Arena*);
template<> ::Journal::UserAuthorityPayload* Arena::CreateMaybeMessage<::Journal::UserAuthorityPayload>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Journal {

enum OpRemoveOps_V1_UndoRedoType : int {
  OpRemoveOps_V1_UndoRedoType_None = 0,
  OpRemoveOps_V1_UndoRedoType_Undo = 1,
  OpRemoveOps_V1_UndoRedoType_Redo = 2,
  OpRemoveOps_V1_UndoRedoType_OpRemoveOps_V1_UndoRedoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OpRemoveOps_V1_UndoRedoType_OpRemoveOps_V1_UndoRedoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OpRemoveOps_V1_UndoRedoType_IsValid(int value);
constexpr OpRemoveOps_V1_UndoRedoType OpRemoveOps_V1_UndoRedoType_UndoRedoType_MIN = OpRemoveOps_V1_UndoRedoType_None;
constexpr OpRemoveOps_V1_UndoRedoType OpRemoveOps_V1_UndoRedoType_UndoRedoType_MAX = OpRemoveOps_V1_UndoRedoType_Redo;
constexpr int OpRemoveOps_V1_UndoRedoType_UndoRedoType_ARRAYSIZE = OpRemoveOps_V1_UndoRedoType_UndoRedoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpRemoveOps_V1_UndoRedoType_descriptor();
template<typename T>
inline const std::string& OpRemoveOps_V1_UndoRedoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpRemoveOps_V1_UndoRedoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpRemoveOps_V1_UndoRedoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpRemoveOps_V1_UndoRedoType_descriptor(), enum_t_value);
}
inline bool OpRemoveOps_V1_UndoRedoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpRemoveOps_V1_UndoRedoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpRemoveOps_V1_UndoRedoType>(
    OpRemoveOps_V1_UndoRedoType_descriptor(), name, value);
}
enum OpRemoveOps_V2_UndoRedoType : int {
  OpRemoveOps_V2_UndoRedoType_None = 0,
  OpRemoveOps_V2_UndoRedoType_Undo = 1,
  OpRemoveOps_V2_UndoRedoType_Redo = 2,
  OpRemoveOps_V2_UndoRedoType_OpRemoveOps_V2_UndoRedoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OpRemoveOps_V2_UndoRedoType_OpRemoveOps_V2_UndoRedoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OpRemoveOps_V2_UndoRedoType_IsValid(int value);
constexpr OpRemoveOps_V2_UndoRedoType OpRemoveOps_V2_UndoRedoType_UndoRedoType_MIN = OpRemoveOps_V2_UndoRedoType_None;
constexpr OpRemoveOps_V2_UndoRedoType OpRemoveOps_V2_UndoRedoType_UndoRedoType_MAX = OpRemoveOps_V2_UndoRedoType_Redo;
constexpr int OpRemoveOps_V2_UndoRedoType_UndoRedoType_ARRAYSIZE = OpRemoveOps_V2_UndoRedoType_UndoRedoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpRemoveOps_V2_UndoRedoType_descriptor();
template<typename T>
inline const std::string& OpRemoveOps_V2_UndoRedoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpRemoveOps_V2_UndoRedoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpRemoveOps_V2_UndoRedoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpRemoveOps_V2_UndoRedoType_descriptor(), enum_t_value);
}
inline bool OpRemoveOps_V2_UndoRedoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpRemoveOps_V2_UndoRedoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpRemoveOps_V2_UndoRedoType>(
    OpRemoveOps_V2_UndoRedoType_descriptor(), name, value);
}
enum OpUserAuthorityData_V1_AuthorityCoordinationEventEnum : int {
  OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Finalizing = 0,
  OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Coordinating = 1,
  OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_IsValid(int value);
constexpr OpUserAuthorityData_V1_AuthorityCoordinationEventEnum OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_MIN = OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Finalizing;
constexpr OpUserAuthorityData_V1_AuthorityCoordinationEventEnum OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_MAX = OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Coordinating;
constexpr int OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_ARRAYSIZE = OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_descriptor();
template<typename T>
inline const std::string& OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpUserAuthorityData_V1_AuthorityCoordinationEventEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_descriptor(), enum_t_value);
}
inline bool OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpUserAuthorityData_V1_AuthorityCoordinationEventEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpUserAuthorityData_V1_AuthorityCoordinationEventEnum>(
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_descriptor(), name, value);
}
// ===================================================================

class OperationId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OperationId) */ {
 public:
  inline OperationId() : OperationId(nullptr) {}
  ~OperationId() override;
  explicit PROTOBUF_CONSTEXPR OperationId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationId(const OperationId& from);
  OperationId(OperationId&& from) noexcept
    : OperationId() {
    *this = ::std::move(from);
  }

  inline OperationId& operator=(const OperationId& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationId& operator=(OperationId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationId& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationId* internal_default_instance() {
    return reinterpret_cast<const OperationId*>(
               &_OperationId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OperationId& a, OperationId& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationId& from) {
    OperationId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OperationId";
  }
  protected:
  explicit OperationId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionIdFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // string connectionId = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:Journal.OperationId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OperationReferenceCollection_ReferenceTimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OperationReferenceCollection.ReferenceTimeSpan) */ {
 public:
  inline OperationReferenceCollection_ReferenceTimeSpan() : OperationReferenceCollection_ReferenceTimeSpan(nullptr) {}
  ~OperationReferenceCollection_ReferenceTimeSpan() override;
  explicit PROTOBUF_CONSTEXPR OperationReferenceCollection_ReferenceTimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationReferenceCollection_ReferenceTimeSpan(const OperationReferenceCollection_ReferenceTimeSpan& from);
  OperationReferenceCollection_ReferenceTimeSpan(OperationReferenceCollection_ReferenceTimeSpan&& from) noexcept
    : OperationReferenceCollection_ReferenceTimeSpan() {
    *this = ::std::move(from);
  }

  inline OperationReferenceCollection_ReferenceTimeSpan& operator=(const OperationReferenceCollection_ReferenceTimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationReferenceCollection_ReferenceTimeSpan& operator=(OperationReferenceCollection_ReferenceTimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationReferenceCollection_ReferenceTimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationReferenceCollection_ReferenceTimeSpan* internal_default_instance() {
    return reinterpret_cast<const OperationReferenceCollection_ReferenceTimeSpan*>(
               &_OperationReferenceCollection_ReferenceTimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperationReferenceCollection_ReferenceTimeSpan& a, OperationReferenceCollection_ReferenceTimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationReferenceCollection_ReferenceTimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationReferenceCollection_ReferenceTimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationReferenceCollection_ReferenceTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationReferenceCollection_ReferenceTimeSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationReferenceCollection_ReferenceTimeSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationReferenceCollection_ReferenceTimeSpan& from) {
    OperationReferenceCollection_ReferenceTimeSpan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationReferenceCollection_ReferenceTimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OperationReferenceCollection.ReferenceTimeSpan";
  }
  protected:
  explicit OperationReferenceCollection_ReferenceTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndInclusiveFieldNumber = 2,
  };
  // .google.protobuf.Timestamp begin = 1;
  bool has_begin() const;
  private:
  bool _internal_has_begin() const;
  public:
  void clear_begin();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& begin() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_begin();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_begin();
  void set_allocated_begin(::PROTOBUF_NAMESPACE_ID::Timestamp* begin);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_begin() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_begin();
  public:
  void unsafe_arena_set_allocated_begin(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* begin);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_begin();

  // .google.protobuf.Timestamp endInclusive = 2;
  bool has_endinclusive() const;
  private:
  bool _internal_has_endinclusive() const;
  public:
  void clear_endinclusive();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& endinclusive() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_endinclusive();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_endinclusive();
  void set_allocated_endinclusive(::PROTOBUF_NAMESPACE_ID::Timestamp* endinclusive);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_endinclusive() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_endinclusive();
  public:
  void unsafe_arena_set_allocated_endinclusive(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* endinclusive);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_endinclusive();

  // @@protoc_insertion_point(class_scope:Journal.OperationReferenceCollection.ReferenceTimeSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* begin_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* endinclusive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OperationReferenceCollection_ReferenceSinglesByConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OperationReferenceCollection.ReferenceSinglesByConnection) */ {
 public:
  inline OperationReferenceCollection_ReferenceSinglesByConnection() : OperationReferenceCollection_ReferenceSinglesByConnection(nullptr) {}
  ~OperationReferenceCollection_ReferenceSinglesByConnection() override;
  explicit PROTOBUF_CONSTEXPR OperationReferenceCollection_ReferenceSinglesByConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationReferenceCollection_ReferenceSinglesByConnection(const OperationReferenceCollection_ReferenceSinglesByConnection& from);
  OperationReferenceCollection_ReferenceSinglesByConnection(OperationReferenceCollection_ReferenceSinglesByConnection&& from) noexcept
    : OperationReferenceCollection_ReferenceSinglesByConnection() {
    *this = ::std::move(from);
  }

  inline OperationReferenceCollection_ReferenceSinglesByConnection& operator=(const OperationReferenceCollection_ReferenceSinglesByConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationReferenceCollection_ReferenceSinglesByConnection& operator=(OperationReferenceCollection_ReferenceSinglesByConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationReferenceCollection_ReferenceSinglesByConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationReferenceCollection_ReferenceSinglesByConnection* internal_default_instance() {
    return reinterpret_cast<const OperationReferenceCollection_ReferenceSinglesByConnection*>(
               &_OperationReferenceCollection_ReferenceSinglesByConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OperationReferenceCollection_ReferenceSinglesByConnection& a, OperationReferenceCollection_ReferenceSinglesByConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationReferenceCollection_ReferenceSinglesByConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationReferenceCollection_ReferenceSinglesByConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationReferenceCollection_ReferenceSinglesByConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationReferenceCollection_ReferenceSinglesByConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationReferenceCollection_ReferenceSinglesByConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationReferenceCollection_ReferenceSinglesByConnection& from) {
    OperationReferenceCollection_ReferenceSinglesByConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationReferenceCollection_ReferenceSinglesByConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OperationReferenceCollection.ReferenceSinglesByConnection";
  }
  protected:
  explicit OperationReferenceCollection_ReferenceSinglesByConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAtTimeSetFieldNumber = 2,
    kFromConnectionIdFieldNumber = 1,
  };
  // repeated .google.protobuf.Timestamp atTimeSet = 2;
  int attimeset_size() const;
  private:
  int _internal_attimeset_size() const;
  public:
  void clear_attimeset();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_attimeset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
      mutable_attimeset();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_attimeset(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_add_attimeset();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& attimeset(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* add_attimeset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
      attimeset() const;

  // string fromConnectionId = 1;
  void clear_fromconnectionid();
  const std::string& fromconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromconnectionid();
  PROTOBUF_NODISCARD std::string* release_fromconnectionid();
  void set_allocated_fromconnectionid(std::string* fromconnectionid);
  private:
  const std::string& _internal_fromconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromconnectionid(const std::string& value);
  std::string* _internal_mutable_fromconnectionid();
  public:

  // @@protoc_insertion_point(class_scope:Journal.OperationReferenceCollection.ReferenceSinglesByConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp > attimeset_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromconnectionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OperationReferenceCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OperationReferenceCollection) */ {
 public:
  inline OperationReferenceCollection() : OperationReferenceCollection(nullptr) {}
  ~OperationReferenceCollection() override;
  explicit PROTOBUF_CONSTEXPR OperationReferenceCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationReferenceCollection(const OperationReferenceCollection& from);
  OperationReferenceCollection(OperationReferenceCollection&& from) noexcept
    : OperationReferenceCollection() {
    *this = ::std::move(from);
  }

  inline OperationReferenceCollection& operator=(const OperationReferenceCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationReferenceCollection& operator=(OperationReferenceCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationReferenceCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationReferenceCollection* internal_default_instance() {
    return reinterpret_cast<const OperationReferenceCollection*>(
               &_OperationReferenceCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OperationReferenceCollection& a, OperationReferenceCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationReferenceCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationReferenceCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationReferenceCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationReferenceCollection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationReferenceCollection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationReferenceCollection& from) {
    OperationReferenceCollection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationReferenceCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OperationReferenceCollection";
  }
  protected:
  explicit OperationReferenceCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OperationReferenceCollection_ReferenceTimeSpan ReferenceTimeSpan;
  typedef OperationReferenceCollection_ReferenceSinglesByConnection ReferenceSinglesByConnection;

  // accessors -------------------------------------------------------

  enum : int {
    kSpansFieldNumber = 1,
    kSinglesFieldNumber = 2,
  };
  // repeated .Journal.OperationReferenceCollection.ReferenceTimeSpan spans = 1;
  int spans_size() const;
  private:
  int _internal_spans_size() const;
  public:
  void clear_spans();
  ::Journal::OperationReferenceCollection_ReferenceTimeSpan* mutable_spans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceTimeSpan >*
      mutable_spans();
  private:
  const ::Journal::OperationReferenceCollection_ReferenceTimeSpan& _internal_spans(int index) const;
  ::Journal::OperationReferenceCollection_ReferenceTimeSpan* _internal_add_spans();
  public:
  const ::Journal::OperationReferenceCollection_ReferenceTimeSpan& spans(int index) const;
  ::Journal::OperationReferenceCollection_ReferenceTimeSpan* add_spans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceTimeSpan >&
      spans() const;

  // repeated .Journal.OperationReferenceCollection.ReferenceSinglesByConnection singles = 2;
  int singles_size() const;
  private:
  int _internal_singles_size() const;
  public:
  void clear_singles();
  ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* mutable_singles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection >*
      mutable_singles();
  private:
  const ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection& _internal_singles(int index) const;
  ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* _internal_add_singles();
  public:
  const ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection& singles(int index) const;
  ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* add_singles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection >&
      singles() const;

  // @@protoc_insertion_point(class_scope:Journal.OperationReferenceCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceTimeSpan > spans_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection > singles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpRemoveOps_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpRemoveOps.V1) */ {
 public:
  inline OpRemoveOps_V1() : OpRemoveOps_V1(nullptr) {}
  ~OpRemoveOps_V1() override;
  explicit PROTOBUF_CONSTEXPR OpRemoveOps_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpRemoveOps_V1(const OpRemoveOps_V1& from);
  OpRemoveOps_V1(OpRemoveOps_V1&& from) noexcept
    : OpRemoveOps_V1() {
    *this = ::std::move(from);
  }

  inline OpRemoveOps_V1& operator=(const OpRemoveOps_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpRemoveOps_V1& operator=(OpRemoveOps_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpRemoveOps_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpRemoveOps_V1* internal_default_instance() {
    return reinterpret_cast<const OpRemoveOps_V1*>(
               &_OpRemoveOps_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OpRemoveOps_V1& a, OpRemoveOps_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpRemoveOps_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpRemoveOps_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpRemoveOps_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpRemoveOps_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpRemoveOps_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpRemoveOps_V1& from) {
    OpRemoveOps_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpRemoveOps_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpRemoveOps.V1";
  }
  protected:
  explicit OpRemoveOps_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpRemoveOps_V1_UndoRedoType UndoRedoType;
  static constexpr UndoRedoType None =
    OpRemoveOps_V1_UndoRedoType_None;
  static constexpr UndoRedoType Undo =
    OpRemoveOps_V1_UndoRedoType_Undo;
  static constexpr UndoRedoType Redo =
    OpRemoveOps_V1_UndoRedoType_Redo;
  static inline bool UndoRedoType_IsValid(int value) {
    return OpRemoveOps_V1_UndoRedoType_IsValid(value);
  }
  static constexpr UndoRedoType UndoRedoType_MIN =
    OpRemoveOps_V1_UndoRedoType_UndoRedoType_MIN;
  static constexpr UndoRedoType UndoRedoType_MAX =
    OpRemoveOps_V1_UndoRedoType_UndoRedoType_MAX;
  static constexpr int UndoRedoType_ARRAYSIZE =
    OpRemoveOps_V1_UndoRedoType_UndoRedoType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UndoRedoType_descriptor() {
    return OpRemoveOps_V1_UndoRedoType_descriptor();
  }
  template<typename T>
  static inline const std::string& UndoRedoType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UndoRedoType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UndoRedoType_Name.");
    return OpRemoveOps_V1_UndoRedoType_Name(enum_t_value);
  }
  static inline bool UndoRedoType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UndoRedoType* value) {
    return OpRemoveOps_V1_UndoRedoType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kRemovalTypeFieldNumber = 2,
  };
  // .Journal.OperationReferenceCollection ids = 1;
  bool has_ids() const;
  private:
  bool _internal_has_ids() const;
  public:
  void clear_ids();
  const ::Journal::OperationReferenceCollection& ids() const;
  PROTOBUF_NODISCARD ::Journal::OperationReferenceCollection* release_ids();
  ::Journal::OperationReferenceCollection* mutable_ids();
  void set_allocated_ids(::Journal::OperationReferenceCollection* ids);
  private:
  const ::Journal::OperationReferenceCollection& _internal_ids() const;
  ::Journal::OperationReferenceCollection* _internal_mutable_ids();
  public:
  void unsafe_arena_set_allocated_ids(
      ::Journal::OperationReferenceCollection* ids);
  ::Journal::OperationReferenceCollection* unsafe_arena_release_ids();

  // .Journal.OpRemoveOps.V1.UndoRedoType removalType = 2;
  void clear_removaltype();
  ::Journal::OpRemoveOps_V1_UndoRedoType removaltype() const;
  void set_removaltype(::Journal::OpRemoveOps_V1_UndoRedoType value);
  private:
  ::Journal::OpRemoveOps_V1_UndoRedoType _internal_removaltype() const;
  void _internal_set_removaltype(::Journal::OpRemoveOps_V1_UndoRedoType value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpRemoveOps.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Journal::OperationReferenceCollection* ids_;
    int removaltype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpRemoveOps_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpRemoveOps.V2) */ {
 public:
  inline OpRemoveOps_V2() : OpRemoveOps_V2(nullptr) {}
  ~OpRemoveOps_V2() override;
  explicit PROTOBUF_CONSTEXPR OpRemoveOps_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpRemoveOps_V2(const OpRemoveOps_V2& from);
  OpRemoveOps_V2(OpRemoveOps_V2&& from) noexcept
    : OpRemoveOps_V2() {
    *this = ::std::move(from);
  }

  inline OpRemoveOps_V2& operator=(const OpRemoveOps_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpRemoveOps_V2& operator=(OpRemoveOps_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpRemoveOps_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpRemoveOps_V2* internal_default_instance() {
    return reinterpret_cast<const OpRemoveOps_V2*>(
               &_OpRemoveOps_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpRemoveOps_V2& a, OpRemoveOps_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(OpRemoveOps_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpRemoveOps_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpRemoveOps_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpRemoveOps_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpRemoveOps_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpRemoveOps_V2& from) {
    OpRemoveOps_V2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpRemoveOps_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpRemoveOps.V2";
  }
  protected:
  explicit OpRemoveOps_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpRemoveOps_V2_UndoRedoType UndoRedoType;
  static constexpr UndoRedoType None =
    OpRemoveOps_V2_UndoRedoType_None;
  static constexpr UndoRedoType Undo =
    OpRemoveOps_V2_UndoRedoType_Undo;
  static constexpr UndoRedoType Redo =
    OpRemoveOps_V2_UndoRedoType_Redo;
  static inline bool UndoRedoType_IsValid(int value) {
    return OpRemoveOps_V2_UndoRedoType_IsValid(value);
  }
  static constexpr UndoRedoType UndoRedoType_MIN =
    OpRemoveOps_V2_UndoRedoType_UndoRedoType_MIN;
  static constexpr UndoRedoType UndoRedoType_MAX =
    OpRemoveOps_V2_UndoRedoType_UndoRedoType_MAX;
  static constexpr int UndoRedoType_ARRAYSIZE =
    OpRemoveOps_V2_UndoRedoType_UndoRedoType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UndoRedoType_descriptor() {
    return OpRemoveOps_V2_UndoRedoType_descriptor();
  }
  template<typename T>
  static inline const std::string& UndoRedoType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UndoRedoType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UndoRedoType_Name.");
    return OpRemoveOps_V2_UndoRedoType_Name(enum_t_value);
  }
  static inline bool UndoRedoType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UndoRedoType* value) {
    return OpRemoveOps_V2_UndoRedoType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOpIdsFieldNumber = 1,
    kRemovalTypeFieldNumber = 2,
  };
  // repeated string opIds = 1;
  int opids_size() const;
  private:
  int _internal_opids_size() const;
  public:
  void clear_opids();
  const std::string& opids(int index) const;
  std::string* mutable_opids(int index);
  void set_opids(int index, const std::string& value);
  void set_opids(int index, std::string&& value);
  void set_opids(int index, const char* value);
  void set_opids(int index, const char* value, size_t size);
  std::string* add_opids();
  void add_opids(const std::string& value);
  void add_opids(std::string&& value);
  void add_opids(const char* value);
  void add_opids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& opids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_opids();
  private:
  const std::string& _internal_opids(int index) const;
  std::string* _internal_add_opids();
  public:

  // .Journal.OpRemoveOps.V2.UndoRedoType removalType = 2;
  void clear_removaltype();
  ::Journal::OpRemoveOps_V2_UndoRedoType removaltype() const;
  void set_removaltype(::Journal::OpRemoveOps_V2_UndoRedoType value);
  private:
  ::Journal::OpRemoveOps_V2_UndoRedoType _internal_removaltype() const;
  void _internal_set_removaltype(::Journal::OpRemoveOps_V2_UndoRedoType value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpRemoveOps.V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> opids_;
    int removaltype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpRemoveOps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpRemoveOps) */ {
 public:
  inline OpRemoveOps() : OpRemoveOps(nullptr) {}
  ~OpRemoveOps() override;
  explicit PROTOBUF_CONSTEXPR OpRemoveOps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpRemoveOps(const OpRemoveOps& from);
  OpRemoveOps(OpRemoveOps&& from) noexcept
    : OpRemoveOps() {
    *this = ::std::move(from);
  }

  inline OpRemoveOps& operator=(const OpRemoveOps& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpRemoveOps& operator=(OpRemoveOps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpRemoveOps& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    kV2 = 2,
    V_NOT_SET = 0,
  };

  static inline const OpRemoveOps* internal_default_instance() {
    return reinterpret_cast<const OpRemoveOps*>(
               &_OpRemoveOps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OpRemoveOps& a, OpRemoveOps& b) {
    a.Swap(&b);
  }
  inline void Swap(OpRemoveOps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpRemoveOps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpRemoveOps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpRemoveOps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpRemoveOps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpRemoveOps& from) {
    OpRemoveOps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpRemoveOps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpRemoveOps";
  }
  protected:
  explicit OpRemoveOps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpRemoveOps_V1 V1;
  typedef OpRemoveOps_V2 V2;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
    kV2FieldNumber = 2,
  };
  // .Journal.OpRemoveOps.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpRemoveOps_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpRemoveOps_V1* release_v1();
  ::Journal::OpRemoveOps_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpRemoveOps_V1* v1);
  private:
  const ::Journal::OpRemoveOps_V1& _internal_v1() const;
  ::Journal::OpRemoveOps_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpRemoveOps_V1* v1);
  ::Journal::OpRemoveOps_V1* unsafe_arena_release_v1();

  // .Journal.OpRemoveOps.V2 v2 = 2;
  bool has_v2() const;
  private:
  bool _internal_has_v2() const;
  public:
  void clear_v2();
  const ::Journal::OpRemoveOps_V2& v2() const;
  PROTOBUF_NODISCARD ::Journal::OpRemoveOps_V2* release_v2();
  ::Journal::OpRemoveOps_V2* mutable_v2();
  void set_allocated_v2(::Journal::OpRemoveOps_V2* v2);
  private:
  const ::Journal::OpRemoveOps_V2& _internal_v2() const;
  ::Journal::OpRemoveOps_V2* _internal_mutable_v2();
  public:
  void unsafe_arena_set_allocated_v2(
      ::Journal::OpRemoveOps_V2* v2);
  ::Journal::OpRemoveOps_V2* unsafe_arena_release_v2();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpRemoveOps)
 private:
  class _Internal;
  void set_has_v1();
  void set_has_v2();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpRemoveOps_V1* v1_;
      ::Journal::OpRemoveOps_V2* v2_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpLine2d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpLine2d.V1) */ {
 public:
  inline OpLine2d_V1() : OpLine2d_V1(nullptr) {}
  ~OpLine2d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpLine2d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpLine2d_V1(const OpLine2d_V1& from);
  OpLine2d_V1(OpLine2d_V1&& from) noexcept
    : OpLine2d_V1() {
    *this = ::std::move(from);
  }

  inline OpLine2d_V1& operator=(const OpLine2d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpLine2d_V1& operator=(OpLine2d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpLine2d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpLine2d_V1* internal_default_instance() {
    return reinterpret_cast<const OpLine2d_V1*>(
               &_OpLine2d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpLine2d_V1& a, OpLine2d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpLine2d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpLine2d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpLine2d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpLine2d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpLine2d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpLine2d_V1& from) {
    OpLine2d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpLine2d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpLine2d.V1";
  }
  protected:
  explicit OpLine2d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewObjectIdFieldNumber = 10,
    kObjectIdFieldNumber = 1,
    kVisibleWithinStateFieldNumber = 2,
    kPointsFieldNumber = 3,
    kColorFieldNumber = 5,
    kWidthFieldNumber = 4,
  };
  // string newObjectId = 10;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .JournalData.BoardState visibleWithinState = 2;
  bool has_visiblewithinstate() const;
  private:
  bool _internal_has_visiblewithinstate() const;
  public:
  void clear_visiblewithinstate();
  const ::JournalData::BoardState& visiblewithinstate() const;
  PROTOBUF_NODISCARD ::JournalData::BoardState* release_visiblewithinstate();
  ::JournalData::BoardState* mutable_visiblewithinstate();
  void set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate);
  private:
  const ::JournalData::BoardState& _internal_visiblewithinstate() const;
  ::JournalData::BoardState* _internal_mutable_visiblewithinstate();
  public:
  void unsafe_arena_set_allocated_visiblewithinstate(
      ::JournalData::BoardState* visiblewithinstate);
  ::JournalData::BoardState* unsafe_arena_release_visiblewithinstate();

  // .Common.Float2Array points = 3;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::Common::Float2Array& points() const;
  PROTOBUF_NODISCARD ::Common::Float2Array* release_points();
  ::Common::Float2Array* mutable_points();
  void set_allocated_points(::Common::Float2Array* points);
  private:
  const ::Common::Float2Array& _internal_points() const;
  ::Common::Float2Array* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::Common::Float2Array* points);
  ::Common::Float2Array* unsafe_arena_release_points();

  // .Common.Color4 color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Common::Color4& color() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_color();
  ::Common::Color4* mutable_color();
  void set_allocated_color(::Common::Color4* color);
  private:
  const ::Common::Color4& _internal_color() const;
  ::Common::Color4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Common::Color4* color);
  ::Common::Color4* unsafe_arena_release_color();

  // float width = 4;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpLine2d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::JournalData::ObjectId* objectid_;
    ::JournalData::BoardState* visiblewithinstate_;
    ::Common::Float2Array* points_;
    ::Common::Color4* color_;
    float width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpLine2d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpLine2d) */ {
 public:
  inline OpLine2d() : OpLine2d(nullptr) {}
  ~OpLine2d() override;
  explicit PROTOBUF_CONSTEXPR OpLine2d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpLine2d(const OpLine2d& from);
  OpLine2d(OpLine2d&& from) noexcept
    : OpLine2d() {
    *this = ::std::move(from);
  }

  inline OpLine2d& operator=(const OpLine2d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpLine2d& operator=(OpLine2d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpLine2d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpLine2d* internal_default_instance() {
    return reinterpret_cast<const OpLine2d*>(
               &_OpLine2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OpLine2d& a, OpLine2d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpLine2d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpLine2d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpLine2d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpLine2d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpLine2d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpLine2d& from) {
    OpLine2d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpLine2d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpLine2d";
  }
  protected:
  explicit OpLine2d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpLine2d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpLine2d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpLine2d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpLine2d_V1* release_v1();
  ::Journal::OpLine2d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpLine2d_V1* v1);
  private:
  const ::Journal::OpLine2d_V1& _internal_v1() const;
  ::Journal::OpLine2d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpLine2d_V1* v1);
  ::Journal::OpLine2d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpLine2d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpLine2d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText2d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText2d.V1) */ {
 public:
  inline OpText2d_V1() : OpText2d_V1(nullptr) {}
  ~OpText2d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpText2d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText2d_V1(const OpText2d_V1& from);
  OpText2d_V1(OpText2d_V1&& from) noexcept
    : OpText2d_V1() {
    *this = ::std::move(from);
  }

  inline OpText2d_V1& operator=(const OpText2d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText2d_V1& operator=(OpText2d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText2d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpText2d_V1* internal_default_instance() {
    return reinterpret_cast<const OpText2d_V1*>(
               &_OpText2d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OpText2d_V1& a, OpText2d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText2d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText2d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText2d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText2d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText2d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText2d_V1& from) {
    OpText2d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText2d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText2d.V1";
  }
  protected:
  explicit OpText2d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 4,
    kLanguageFieldNumber = 5,
    kNewObjectIdFieldNumber = 10,
    kObjectIdFieldNumber = 1,
    kVisibleWithinStateFieldNumber = 2,
    kPointFieldNumber = 3,
    kColorFieldNumber = 6,
    kSizeFieldNumber = 7,
  };
  // string text = 4;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 5;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string newObjectId = 10;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .JournalData.BoardState visibleWithinState = 2;
  bool has_visiblewithinstate() const;
  private:
  bool _internal_has_visiblewithinstate() const;
  public:
  void clear_visiblewithinstate();
  const ::JournalData::BoardState& visiblewithinstate() const;
  PROTOBUF_NODISCARD ::JournalData::BoardState* release_visiblewithinstate();
  ::JournalData::BoardState* mutable_visiblewithinstate();
  void set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate);
  private:
  const ::JournalData::BoardState& _internal_visiblewithinstate() const;
  ::JournalData::BoardState* _internal_mutable_visiblewithinstate();
  public:
  void unsafe_arena_set_allocated_visiblewithinstate(
      ::JournalData::BoardState* visiblewithinstate);
  ::JournalData::BoardState* unsafe_arena_release_visiblewithinstate();

  // .Common.Float2 point = 3;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::Common::Float2& point() const;
  PROTOBUF_NODISCARD ::Common::Float2* release_point();
  ::Common::Float2* mutable_point();
  void set_allocated_point(::Common::Float2* point);
  private:
  const ::Common::Float2& _internal_point() const;
  ::Common::Float2* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::Common::Float2* point);
  ::Common::Float2* unsafe_arena_release_point();

  // .Common.Color4 color = 6;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Common::Color4& color() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_color();
  ::Common::Color4* mutable_color();
  void set_allocated_color(::Common::Color4* color);
  private:
  const ::Common::Color4& _internal_color() const;
  ::Common::Color4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Common::Color4* color);
  ::Common::Color4* unsafe_arena_release_color();

  // float size = 7;
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpText2d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::JournalData::ObjectId* objectid_;
    ::JournalData::BoardState* visiblewithinstate_;
    ::Common::Float2* point_;
    ::Common::Color4* color_;
    float size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText2d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText2d) */ {
 public:
  inline OpText2d() : OpText2d(nullptr) {}
  ~OpText2d() override;
  explicit PROTOBUF_CONSTEXPR OpText2d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText2d(const OpText2d& from);
  OpText2d(OpText2d&& from) noexcept
    : OpText2d() {
    *this = ::std::move(from);
  }

  inline OpText2d& operator=(const OpText2d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText2d& operator=(OpText2d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText2d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpText2d* internal_default_instance() {
    return reinterpret_cast<const OpText2d*>(
               &_OpText2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OpText2d& a, OpText2d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText2d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText2d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText2d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText2d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText2d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText2d& from) {
    OpText2d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText2d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText2d";
  }
  protected:
  explicit OpText2d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpText2d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpText2d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpText2d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpText2d_V1* release_v1();
  ::Journal::OpText2d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpText2d_V1* v1);
  private:
  const ::Journal::OpText2d_V1& _internal_v1() const;
  ::Journal::OpText2d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpText2d_V1* v1);
  ::Journal::OpText2d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpText2d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpText2d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText2dModify_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText2dModify.V1) */ {
 public:
  inline OpText2dModify_V1() : OpText2dModify_V1(nullptr) {}
  ~OpText2dModify_V1() override;
  explicit PROTOBUF_CONSTEXPR OpText2dModify_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText2dModify_V1(const OpText2dModify_V1& from);
  OpText2dModify_V1(OpText2dModify_V1&& from) noexcept
    : OpText2dModify_V1() {
    *this = ::std::move(from);
  }

  inline OpText2dModify_V1& operator=(const OpText2dModify_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText2dModify_V1& operator=(OpText2dModify_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText2dModify_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpText2dModify_V1* internal_default_instance() {
    return reinterpret_cast<const OpText2dModify_V1*>(
               &_OpText2dModify_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OpText2dModify_V1& a, OpText2dModify_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText2dModify_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText2dModify_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText2dModify_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText2dModify_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText2dModify_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText2dModify_V1& from) {
    OpText2dModify_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText2dModify_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText2dModify.V1";
  }
  protected:
  explicit OpText2dModify_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 4,
    kLanguageFieldNumber = 5,
    kTranslatedFromTextFieldNumber = 6,
    kTranslatedFromLanguageFieldNumber = 7,
    kObjectIdFieldNumber = 1,
  };
  // string text = 4;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 5;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string translatedFromText = 6;
  void clear_translatedfromtext();
  const std::string& translatedfromtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translatedfromtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translatedfromtext();
  PROTOBUF_NODISCARD std::string* release_translatedfromtext();
  void set_allocated_translatedfromtext(std::string* translatedfromtext);
  private:
  const std::string& _internal_translatedfromtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translatedfromtext(const std::string& value);
  std::string* _internal_mutable_translatedfromtext();
  public:

  // string translatedFromLanguage = 7;
  void clear_translatedfromlanguage();
  const std::string& translatedfromlanguage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translatedfromlanguage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translatedfromlanguage();
  PROTOBUF_NODISCARD std::string* release_translatedfromlanguage();
  void set_allocated_translatedfromlanguage(std::string* translatedfromlanguage);
  private:
  const std::string& _internal_translatedfromlanguage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translatedfromlanguage(const std::string& value);
  std::string* _internal_mutable_translatedfromlanguage();
  public:

  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // @@protoc_insertion_point(class_scope:Journal.OpText2dModify.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translatedfromtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translatedfromlanguage_;
    ::JournalData::ObjectId* objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText2dModify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText2dModify) */ {
 public:
  inline OpText2dModify() : OpText2dModify(nullptr) {}
  ~OpText2dModify() override;
  explicit PROTOBUF_CONSTEXPR OpText2dModify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText2dModify(const OpText2dModify& from);
  OpText2dModify(OpText2dModify&& from) noexcept
    : OpText2dModify() {
    *this = ::std::move(from);
  }

  inline OpText2dModify& operator=(const OpText2dModify& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText2dModify& operator=(OpText2dModify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText2dModify& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpText2dModify* internal_default_instance() {
    return reinterpret_cast<const OpText2dModify*>(
               &_OpText2dModify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OpText2dModify& a, OpText2dModify& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText2dModify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText2dModify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText2dModify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText2dModify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText2dModify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText2dModify& from) {
    OpText2dModify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText2dModify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText2dModify";
  }
  protected:
  explicit OpText2dModify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpText2dModify_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpText2dModify.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpText2dModify_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpText2dModify_V1* release_v1();
  ::Journal::OpText2dModify_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpText2dModify_V1* v1);
  private:
  const ::Journal::OpText2dModify_V1& _internal_v1() const;
  ::Journal::OpText2dModify_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpText2dModify_V1* v1);
  ::Journal::OpText2dModify_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpText2dModify)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpText2dModify_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpImage2d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpImage2d.V1) */ {
 public:
  inline OpImage2d_V1() : OpImage2d_V1(nullptr) {}
  ~OpImage2d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpImage2d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpImage2d_V1(const OpImage2d_V1& from);
  OpImage2d_V1(OpImage2d_V1&& from) noexcept
    : OpImage2d_V1() {
    *this = ::std::move(from);
  }

  inline OpImage2d_V1& operator=(const OpImage2d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpImage2d_V1& operator=(OpImage2d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpImage2d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpImage2d_V1* internal_default_instance() {
    return reinterpret_cast<const OpImage2d_V1*>(
               &_OpImage2d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(OpImage2d_V1& a, OpImage2d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpImage2d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpImage2d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpImage2d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpImage2d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpImage2d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpImage2d_V1& from) {
    OpImage2d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpImage2d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpImage2d.V1";
  }
  protected:
  explicit OpImage2d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewObjectIdFieldNumber = 10,
    kPlacementDataFieldNumber = 1,
    kContentIdFieldNumber = 2,
  };
  // string newObjectId = 10;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // .JournalData.Image2dPlacementData placementData = 1;
  bool has_placementdata() const;
  private:
  bool _internal_has_placementdata() const;
  public:
  void clear_placementdata();
  const ::JournalData::Image2dPlacementData& placementdata() const;
  PROTOBUF_NODISCARD ::JournalData::Image2dPlacementData* release_placementdata();
  ::JournalData::Image2dPlacementData* mutable_placementdata();
  void set_allocated_placementdata(::JournalData::Image2dPlacementData* placementdata);
  private:
  const ::JournalData::Image2dPlacementData& _internal_placementdata() const;
  ::JournalData::Image2dPlacementData* _internal_mutable_placementdata();
  public:
  void unsafe_arena_set_allocated_placementdata(
      ::JournalData::Image2dPlacementData* placementdata);
  ::JournalData::Image2dPlacementData* unsafe_arena_release_placementdata();

  // .JournalData.ImageContentType contentId = 2;
  bool has_contentid() const;
  private:
  bool _internal_has_contentid() const;
  public:
  void clear_contentid();
  const ::JournalData::ImageContentType& contentid() const;
  PROTOBUF_NODISCARD ::JournalData::ImageContentType* release_contentid();
  ::JournalData::ImageContentType* mutable_contentid();
  void set_allocated_contentid(::JournalData::ImageContentType* contentid);
  private:
  const ::JournalData::ImageContentType& _internal_contentid() const;
  ::JournalData::ImageContentType* _internal_mutable_contentid();
  public:
  void unsafe_arena_set_allocated_contentid(
      ::JournalData::ImageContentType* contentid);
  ::JournalData::ImageContentType* unsafe_arena_release_contentid();

  // @@protoc_insertion_point(class_scope:Journal.OpImage2d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::JournalData::Image2dPlacementData* placementdata_;
    ::JournalData::ImageContentType* contentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpImage2d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpImage2d) */ {
 public:
  inline OpImage2d() : OpImage2d(nullptr) {}
  ~OpImage2d() override;
  explicit PROTOBUF_CONSTEXPR OpImage2d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpImage2d(const OpImage2d& from);
  OpImage2d(OpImage2d&& from) noexcept
    : OpImage2d() {
    *this = ::std::move(from);
  }

  inline OpImage2d& operator=(const OpImage2d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpImage2d& operator=(OpImage2d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpImage2d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpImage2d* internal_default_instance() {
    return reinterpret_cast<const OpImage2d*>(
               &_OpImage2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(OpImage2d& a, OpImage2d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpImage2d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpImage2d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpImage2d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpImage2d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpImage2d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpImage2d& from) {
    OpImage2d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpImage2d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpImage2d";
  }
  protected:
  explicit OpImage2d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpImage2d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpImage2d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpImage2d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpImage2d_V1* release_v1();
  ::Journal::OpImage2d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpImage2d_V1* v1);
  private:
  const ::Journal::OpImage2d_V1& _internal_v1() const;
  ::Journal::OpImage2d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpImage2d_V1* v1);
  ::Journal::OpImage2d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpImage2d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpImage2d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpLine3d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpLine3d.V1) */ {
 public:
  inline OpLine3d_V1() : OpLine3d_V1(nullptr) {}
  ~OpLine3d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpLine3d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpLine3d_V1(const OpLine3d_V1& from);
  OpLine3d_V1(OpLine3d_V1&& from) noexcept
    : OpLine3d_V1() {
    *this = ::std::move(from);
  }

  inline OpLine3d_V1& operator=(const OpLine3d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpLine3d_V1& operator=(OpLine3d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpLine3d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpLine3d_V1* internal_default_instance() {
    return reinterpret_cast<const OpLine3d_V1*>(
               &_OpLine3d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(OpLine3d_V1& a, OpLine3d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpLine3d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpLine3d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpLine3d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpLine3d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpLine3d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpLine3d_V1& from) {
    OpLine3d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpLine3d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpLine3d.V1";
  }
  protected:
  explicit OpLine3d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewObjectIdFieldNumber = 10,
    kObjectIdFieldNumber = 1,
    kPointsFieldNumber = 2,
    kNormalsFieldNumber = 3,
    kColorFieldNumber = 5,
    kWidthFieldNumber = 4,
  };
  // string newObjectId = 10;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .Common.Float3Array points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::Common::Float3Array& points() const;
  PROTOBUF_NODISCARD ::Common::Float3Array* release_points();
  ::Common::Float3Array* mutable_points();
  void set_allocated_points(::Common::Float3Array* points);
  private:
  const ::Common::Float3Array& _internal_points() const;
  ::Common::Float3Array* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::Common::Float3Array* points);
  ::Common::Float3Array* unsafe_arena_release_points();

  // .Common.Float3Array normals = 3;
  bool has_normals() const;
  private:
  bool _internal_has_normals() const;
  public:
  void clear_normals();
  const ::Common::Float3Array& normals() const;
  PROTOBUF_NODISCARD ::Common::Float3Array* release_normals();
  ::Common::Float3Array* mutable_normals();
  void set_allocated_normals(::Common::Float3Array* normals);
  private:
  const ::Common::Float3Array& _internal_normals() const;
  ::Common::Float3Array* _internal_mutable_normals();
  public:
  void unsafe_arena_set_allocated_normals(
      ::Common::Float3Array* normals);
  ::Common::Float3Array* unsafe_arena_release_normals();

  // .Common.Color4 color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Common::Color4& color() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_color();
  ::Common::Color4* mutable_color();
  void set_allocated_color(::Common::Color4* color);
  private:
  const ::Common::Color4& _internal_color() const;
  ::Common::Color4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Common::Color4* color);
  ::Common::Color4* unsafe_arena_release_color();

  // float width = 4;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpLine3d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::JournalData::ObjectId* objectid_;
    ::Common::Float3Array* points_;
    ::Common::Float3Array* normals_;
    ::Common::Color4* color_;
    float width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpLine3d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpLine3d) */ {
 public:
  inline OpLine3d() : OpLine3d(nullptr) {}
  ~OpLine3d() override;
  explicit PROTOBUF_CONSTEXPR OpLine3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpLine3d(const OpLine3d& from);
  OpLine3d(OpLine3d&& from) noexcept
    : OpLine3d() {
    *this = ::std::move(from);
  }

  inline OpLine3d& operator=(const OpLine3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpLine3d& operator=(OpLine3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpLine3d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpLine3d* internal_default_instance() {
    return reinterpret_cast<const OpLine3d*>(
               &_OpLine3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(OpLine3d& a, OpLine3d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpLine3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpLine3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpLine3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpLine3d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpLine3d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpLine3d& from) {
    OpLine3d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpLine3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpLine3d";
  }
  protected:
  explicit OpLine3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpLine3d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpLine3d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpLine3d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpLine3d_V1* release_v1();
  ::Journal::OpLine3d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpLine3d_V1* v1);
  private:
  const ::Journal::OpLine3d_V1& _internal_v1() const;
  ::Journal::OpLine3d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpLine3d_V1* v1);
  ::Journal::OpLine3d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpLine3d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpLine3d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText3d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText3d.V1) */ {
 public:
  inline OpText3d_V1() : OpText3d_V1(nullptr) {}
  ~OpText3d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpText3d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText3d_V1(const OpText3d_V1& from);
  OpText3d_V1(OpText3d_V1&& from) noexcept
    : OpText3d_V1() {
    *this = ::std::move(from);
  }

  inline OpText3d_V1& operator=(const OpText3d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText3d_V1& operator=(OpText3d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText3d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpText3d_V1* internal_default_instance() {
    return reinterpret_cast<const OpText3d_V1*>(
               &_OpText3d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OpText3d_V1& a, OpText3d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText3d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText3d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText3d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText3d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText3d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText3d_V1& from) {
    OpText3d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText3d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText3d.V1";
  }
  protected:
  explicit OpText3d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewObjectIdFieldNumber = 1,
    kTextFieldNumber = 3,
    kLanguageFieldNumber = 4,
    kPlacementDataFieldNumber = 2,
    kColorFieldNumber = 5,
  };
  // string newObjectId = 1;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 4;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // .JournalData.TagPlacementData placementData = 2;
  bool has_placementdata() const;
  private:
  bool _internal_has_placementdata() const;
  public:
  void clear_placementdata();
  const ::JournalData::TagPlacementData& placementdata() const;
  PROTOBUF_NODISCARD ::JournalData::TagPlacementData* release_placementdata();
  ::JournalData::TagPlacementData* mutable_placementdata();
  void set_allocated_placementdata(::JournalData::TagPlacementData* placementdata);
  private:
  const ::JournalData::TagPlacementData& _internal_placementdata() const;
  ::JournalData::TagPlacementData* _internal_mutable_placementdata();
  public:
  void unsafe_arena_set_allocated_placementdata(
      ::JournalData::TagPlacementData* placementdata);
  ::JournalData::TagPlacementData* unsafe_arena_release_placementdata();

  // .Common.Color4 color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Common::Color4& color() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_color();
  ::Common::Color4* mutable_color();
  void set_allocated_color(::Common::Color4* color);
  private:
  const ::Common::Color4& _internal_color() const;
  ::Common::Color4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Common::Color4* color);
  ::Common::Color4* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:Journal.OpText3d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::JournalData::TagPlacementData* placementdata_;
    ::Common::Color4* color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText3d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText3d) */ {
 public:
  inline OpText3d() : OpText3d(nullptr) {}
  ~OpText3d() override;
  explicit PROTOBUF_CONSTEXPR OpText3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText3d(const OpText3d& from);
  OpText3d(OpText3d&& from) noexcept
    : OpText3d() {
    *this = ::std::move(from);
  }

  inline OpText3d& operator=(const OpText3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText3d& operator=(OpText3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText3d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpText3d* internal_default_instance() {
    return reinterpret_cast<const OpText3d*>(
               &_OpText3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OpText3d& a, OpText3d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText3d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText3d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText3d& from) {
    OpText3d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText3d";
  }
  protected:
  explicit OpText3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpText3d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpText3d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpText3d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpText3d_V1* release_v1();
  ::Journal::OpText3d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpText3d_V1* v1);
  private:
  const ::Journal::OpText3d_V1& _internal_v1() const;
  ::Journal::OpText3d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpText3d_V1* v1);
  ::Journal::OpText3d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpText3d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpText3d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText3dModify_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText3dModify.V1) */ {
 public:
  inline OpText3dModify_V1() : OpText3dModify_V1(nullptr) {}
  ~OpText3dModify_V1() override;
  explicit PROTOBUF_CONSTEXPR OpText3dModify_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText3dModify_V1(const OpText3dModify_V1& from);
  OpText3dModify_V1(OpText3dModify_V1&& from) noexcept
    : OpText3dModify_V1() {
    *this = ::std::move(from);
  }

  inline OpText3dModify_V1& operator=(const OpText3dModify_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText3dModify_V1& operator=(OpText3dModify_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText3dModify_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpText3dModify_V1* internal_default_instance() {
    return reinterpret_cast<const OpText3dModify_V1*>(
               &_OpText3dModify_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OpText3dModify_V1& a, OpText3dModify_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText3dModify_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText3dModify_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText3dModify_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText3dModify_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText3dModify_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText3dModify_V1& from) {
    OpText3dModify_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText3dModify_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText3dModify.V1";
  }
  protected:
  explicit OpText3dModify_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kLanguageFieldNumber = 4,
    kTranslatedFromTextFieldNumber = 6,
    kTranslatedFromLanguageFieldNumber = 7,
    kObjectIdFieldNumber = 1,
    kColorFieldNumber = 5,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 4;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string translatedFromText = 6;
  void clear_translatedfromtext();
  const std::string& translatedfromtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translatedfromtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translatedfromtext();
  PROTOBUF_NODISCARD std::string* release_translatedfromtext();
  void set_allocated_translatedfromtext(std::string* translatedfromtext);
  private:
  const std::string& _internal_translatedfromtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translatedfromtext(const std::string& value);
  std::string* _internal_mutable_translatedfromtext();
  public:

  // string translatedFromLanguage = 7;
  void clear_translatedfromlanguage();
  const std::string& translatedfromlanguage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translatedfromlanguage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translatedfromlanguage();
  PROTOBUF_NODISCARD std::string* release_translatedfromlanguage();
  void set_allocated_translatedfromlanguage(std::string* translatedfromlanguage);
  private:
  const std::string& _internal_translatedfromlanguage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translatedfromlanguage(const std::string& value);
  std::string* _internal_mutable_translatedfromlanguage();
  public:

  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .Common.Color4 color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Common::Color4& color() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_color();
  ::Common::Color4* mutable_color();
  void set_allocated_color(::Common::Color4* color);
  private:
  const ::Common::Color4& _internal_color() const;
  ::Common::Color4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Common::Color4* color);
  ::Common::Color4* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:Journal.OpText3dModify.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translatedfromtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translatedfromlanguage_;
    ::JournalData::ObjectId* objectid_;
    ::Common::Color4* color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpText3dModify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpText3dModify) */ {
 public:
  inline OpText3dModify() : OpText3dModify(nullptr) {}
  ~OpText3dModify() override;
  explicit PROTOBUF_CONSTEXPR OpText3dModify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpText3dModify(const OpText3dModify& from);
  OpText3dModify(OpText3dModify&& from) noexcept
    : OpText3dModify() {
    *this = ::std::move(from);
  }

  inline OpText3dModify& operator=(const OpText3dModify& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpText3dModify& operator=(OpText3dModify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpText3dModify& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpText3dModify* internal_default_instance() {
    return reinterpret_cast<const OpText3dModify*>(
               &_OpText3dModify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OpText3dModify& a, OpText3dModify& b) {
    a.Swap(&b);
  }
  inline void Swap(OpText3dModify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpText3dModify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpText3dModify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpText3dModify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpText3dModify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpText3dModify& from) {
    OpText3dModify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpText3dModify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpText3dModify";
  }
  protected:
  explicit OpText3dModify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpText3dModify_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpText3dModify.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpText3dModify_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpText3dModify_V1* release_v1();
  ::Journal::OpText3dModify_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpText3dModify_V1* v1);
  private:
  const ::Journal::OpText3dModify_V1& _internal_v1() const;
  ::Journal::OpText3dModify_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpText3dModify_V1* v1);
  ::Journal::OpText3dModify_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpText3dModify)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpText3dModify_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpImage3d_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpImage3d.V1) */ {
 public:
  inline OpImage3d_V1() : OpImage3d_V1(nullptr) {}
  ~OpImage3d_V1() override;
  explicit PROTOBUF_CONSTEXPR OpImage3d_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpImage3d_V1(const OpImage3d_V1& from);
  OpImage3d_V1(OpImage3d_V1&& from) noexcept
    : OpImage3d_V1() {
    *this = ::std::move(from);
  }

  inline OpImage3d_V1& operator=(const OpImage3d_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpImage3d_V1& operator=(OpImage3d_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpImage3d_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpImage3d_V1* internal_default_instance() {
    return reinterpret_cast<const OpImage3d_V1*>(
               &_OpImage3d_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(OpImage3d_V1& a, OpImage3d_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpImage3d_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpImage3d_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpImage3d_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpImage3d_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpImage3d_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpImage3d_V1& from) {
    OpImage3d_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpImage3d_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpImage3d.V1";
  }
  protected:
  explicit OpImage3d_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewObjectIdFieldNumber = 1,
    kPlacementDataFieldNumber = 2,
    kContentIdFieldNumber = 3,
  };
  // string newObjectId = 1;
  void clear_newobjectid();
  const std::string& newobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newobjectid();
  PROTOBUF_NODISCARD std::string* release_newobjectid();
  void set_allocated_newobjectid(std::string* newobjectid);
  private:
  const std::string& _internal_newobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newobjectid(const std::string& value);
  std::string* _internal_mutable_newobjectid();
  public:

  // .JournalData.TagPlacementData placementData = 2;
  bool has_placementdata() const;
  private:
  bool _internal_has_placementdata() const;
  public:
  void clear_placementdata();
  const ::JournalData::TagPlacementData& placementdata() const;
  PROTOBUF_NODISCARD ::JournalData::TagPlacementData* release_placementdata();
  ::JournalData::TagPlacementData* mutable_placementdata();
  void set_allocated_placementdata(::JournalData::TagPlacementData* placementdata);
  private:
  const ::JournalData::TagPlacementData& _internal_placementdata() const;
  ::JournalData::TagPlacementData* _internal_mutable_placementdata();
  public:
  void unsafe_arena_set_allocated_placementdata(
      ::JournalData::TagPlacementData* placementdata);
  ::JournalData::TagPlacementData* unsafe_arena_release_placementdata();

  // .JournalData.ImageContentType contentId = 3;
  bool has_contentid() const;
  private:
  bool _internal_has_contentid() const;
  public:
  void clear_contentid();
  const ::JournalData::ImageContentType& contentid() const;
  PROTOBUF_NODISCARD ::JournalData::ImageContentType* release_contentid();
  ::JournalData::ImageContentType* mutable_contentid();
  void set_allocated_contentid(::JournalData::ImageContentType* contentid);
  private:
  const ::JournalData::ImageContentType& _internal_contentid() const;
  ::JournalData::ImageContentType* _internal_mutable_contentid();
  public:
  void unsafe_arena_set_allocated_contentid(
      ::JournalData::ImageContentType* contentid);
  ::JournalData::ImageContentType* unsafe_arena_release_contentid();

  // @@protoc_insertion_point(class_scope:Journal.OpImage3d.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newobjectid_;
    ::JournalData::TagPlacementData* placementdata_;
    ::JournalData::ImageContentType* contentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpImage3d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpImage3d) */ {
 public:
  inline OpImage3d() : OpImage3d(nullptr) {}
  ~OpImage3d() override;
  explicit PROTOBUF_CONSTEXPR OpImage3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpImage3d(const OpImage3d& from);
  OpImage3d(OpImage3d&& from) noexcept
    : OpImage3d() {
    *this = ::std::move(from);
  }

  inline OpImage3d& operator=(const OpImage3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpImage3d& operator=(OpImage3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpImage3d& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpImage3d* internal_default_instance() {
    return reinterpret_cast<const OpImage3d*>(
               &_OpImage3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(OpImage3d& a, OpImage3d& b) {
    a.Swap(&b);
  }
  inline void Swap(OpImage3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpImage3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpImage3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpImage3d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpImage3d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpImage3d& from) {
    OpImage3d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpImage3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpImage3d";
  }
  protected:
  explicit OpImage3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpImage3d_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpImage3d.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpImage3d_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpImage3d_V1* release_v1();
  ::Journal::OpImage3d_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpImage3d_V1* v1);
  private:
  const ::Journal::OpImage3d_V1& _internal_v1() const;
  ::Journal::OpImage3d_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpImage3d_V1* v1);
  ::Journal::OpImage3d_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpImage3d)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpImage3d_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpUpdatePropertyValue_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpUpdatePropertyValue.V1) */ {
 public:
  inline OpUpdatePropertyValue_V1() : OpUpdatePropertyValue_V1(nullptr) {}
  ~OpUpdatePropertyValue_V1() override;
  explicit PROTOBUF_CONSTEXPR OpUpdatePropertyValue_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpUpdatePropertyValue_V1(const OpUpdatePropertyValue_V1& from);
  OpUpdatePropertyValue_V1(OpUpdatePropertyValue_V1&& from) noexcept
    : OpUpdatePropertyValue_V1() {
    *this = ::std::move(from);
  }

  inline OpUpdatePropertyValue_V1& operator=(const OpUpdatePropertyValue_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpUpdatePropertyValue_V1& operator=(OpUpdatePropertyValue_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpUpdatePropertyValue_V1& default_instance() {
    return *internal_default_instance();
  }
  enum ValueTypeCase {
    kScalar = 2,
    kString = 3,
    kVector = 4,
    kColor = 5,
    kTransform = 6,
    kBoolean = 7,
    kJson = 9,
    kLink = 10,
    VALUETYPE_NOT_SET = 0,
  };

  static inline const OpUpdatePropertyValue_V1* internal_default_instance() {
    return reinterpret_cast<const OpUpdatePropertyValue_V1*>(
               &_OpUpdatePropertyValue_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(OpUpdatePropertyValue_V1& a, OpUpdatePropertyValue_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpUpdatePropertyValue_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpUpdatePropertyValue_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpUpdatePropertyValue_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpUpdatePropertyValue_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpUpdatePropertyValue_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpUpdatePropertyValue_V1& from) {
    OpUpdatePropertyValue_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpUpdatePropertyValue_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpUpdatePropertyValue.V1";
  }
  protected:
  explicit OpUpdatePropertyValue_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
    kScalarFieldNumber = 2,
    kStringFieldNumber = 3,
    kVectorFieldNumber = 4,
    kColorFieldNumber = 5,
    kTransformFieldNumber = 6,
    kBooleanFieldNumber = 7,
    kJsonFieldNumber = 9,
    kLinkFieldNumber = 10,
  };
  // .Property.PropertyIdentifier propId = 1;
  bool has_propid() const;
  private:
  bool _internal_has_propid() const;
  public:
  void clear_propid();
  const ::Property::PropertyIdentifier& propid() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propid();
  ::Property::PropertyIdentifier* mutable_propid();
  void set_allocated_propid(::Property::PropertyIdentifier* propid);
  private:
  const ::Property::PropertyIdentifier& _internal_propid() const;
  ::Property::PropertyIdentifier* _internal_mutable_propid();
  public:
  void unsafe_arena_set_allocated_propid(
      ::Property::PropertyIdentifier* propid);
  ::Property::PropertyIdentifier* unsafe_arena_release_propid();

  // .Property.ScalarPropertyAssignment scalar = 2;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  const ::Property::ScalarPropertyAssignment& scalar() const;
  PROTOBUF_NODISCARD ::Property::ScalarPropertyAssignment* release_scalar();
  ::Property::ScalarPropertyAssignment* mutable_scalar();
  void set_allocated_scalar(::Property::ScalarPropertyAssignment* scalar);
  private:
  const ::Property::ScalarPropertyAssignment& _internal_scalar() const;
  ::Property::ScalarPropertyAssignment* _internal_mutable_scalar();
  public:
  void unsafe_arena_set_allocated_scalar(
      ::Property::ScalarPropertyAssignment* scalar);
  ::Property::ScalarPropertyAssignment* unsafe_arena_release_scalar();

  // .Property.StringPropertyAssignment string = 3;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const ::Property::StringPropertyAssignment& string() const;
  PROTOBUF_NODISCARD ::Property::StringPropertyAssignment* release_string();
  ::Property::StringPropertyAssignment* mutable_string();
  void set_allocated_string(::Property::StringPropertyAssignment* string);
  private:
  const ::Property::StringPropertyAssignment& _internal_string() const;
  ::Property::StringPropertyAssignment* _internal_mutable_string();
  public:
  void unsafe_arena_set_allocated_string(
      ::Property::StringPropertyAssignment* string);
  ::Property::StringPropertyAssignment* unsafe_arena_release_string();

  // .Property.VectorPropertyAssignment vector = 4;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;
  public:
  void clear_vector();
  const ::Property::VectorPropertyAssignment& vector() const;
  PROTOBUF_NODISCARD ::Property::VectorPropertyAssignment* release_vector();
  ::Property::VectorPropertyAssignment* mutable_vector();
  void set_allocated_vector(::Property::VectorPropertyAssignment* vector);
  private:
  const ::Property::VectorPropertyAssignment& _internal_vector() const;
  ::Property::VectorPropertyAssignment* _internal_mutable_vector();
  public:
  void unsafe_arena_set_allocated_vector(
      ::Property::VectorPropertyAssignment* vector);
  ::Property::VectorPropertyAssignment* unsafe_arena_release_vector();

  // .Property.ColorPropertyAssignment color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Property::ColorPropertyAssignment& color() const;
  PROTOBUF_NODISCARD ::Property::ColorPropertyAssignment* release_color();
  ::Property::ColorPropertyAssignment* mutable_color();
  void set_allocated_color(::Property::ColorPropertyAssignment* color);
  private:
  const ::Property::ColorPropertyAssignment& _internal_color() const;
  ::Property::ColorPropertyAssignment* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Property::ColorPropertyAssignment* color);
  ::Property::ColorPropertyAssignment* unsafe_arena_release_color();

  // .Property.TransformPropertyAssignment transform = 6;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::Property::TransformPropertyAssignment& transform() const;
  PROTOBUF_NODISCARD ::Property::TransformPropertyAssignment* release_transform();
  ::Property::TransformPropertyAssignment* mutable_transform();
  void set_allocated_transform(::Property::TransformPropertyAssignment* transform);
  private:
  const ::Property::TransformPropertyAssignment& _internal_transform() const;
  ::Property::TransformPropertyAssignment* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::Property::TransformPropertyAssignment* transform);
  ::Property::TransformPropertyAssignment* unsafe_arena_release_transform();

  // .Property.BooleanPropertyAssignment boolean = 7;
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  const ::Property::BooleanPropertyAssignment& boolean() const;
  PROTOBUF_NODISCARD ::Property::BooleanPropertyAssignment* release_boolean();
  ::Property::BooleanPropertyAssignment* mutable_boolean();
  void set_allocated_boolean(::Property::BooleanPropertyAssignment* boolean);
  private:
  const ::Property::BooleanPropertyAssignment& _internal_boolean() const;
  ::Property::BooleanPropertyAssignment* _internal_mutable_boolean();
  public:
  void unsafe_arena_set_allocated_boolean(
      ::Property::BooleanPropertyAssignment* boolean);
  ::Property::BooleanPropertyAssignment* unsafe_arena_release_boolean();

  // .Property.JsonPropertyAssignment json = 9;
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const ::Property::JsonPropertyAssignment& json() const;
  PROTOBUF_NODISCARD ::Property::JsonPropertyAssignment* release_json();
  ::Property::JsonPropertyAssignment* mutable_json();
  void set_allocated_json(::Property::JsonPropertyAssignment* json);
  private:
  const ::Property::JsonPropertyAssignment& _internal_json() const;
  ::Property::JsonPropertyAssignment* _internal_mutable_json();
  public:
  void unsafe_arena_set_allocated_json(
      ::Property::JsonPropertyAssignment* json);
  ::Property::JsonPropertyAssignment* unsafe_arena_release_json();

  // .Property.LinkPropertyAssignment link = 10;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::Property::LinkPropertyAssignment& link() const;
  PROTOBUF_NODISCARD ::Property::LinkPropertyAssignment* release_link();
  ::Property::LinkPropertyAssignment* mutable_link();
  void set_allocated_link(::Property::LinkPropertyAssignment* link);
  private:
  const ::Property::LinkPropertyAssignment& _internal_link() const;
  ::Property::LinkPropertyAssignment* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::Property::LinkPropertyAssignment* link);
  ::Property::LinkPropertyAssignment* unsafe_arena_release_link();

  void clear_ValueType();
  ValueTypeCase ValueType_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpUpdatePropertyValue.V1)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_string();
  void set_has_vector();
  void set_has_color();
  void set_has_transform();
  void set_has_boolean();
  void set_has_json();
  void set_has_link();

  inline bool has_ValueType() const;
  inline void clear_has_ValueType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Property::PropertyIdentifier* propid_;
    union ValueTypeUnion {
      constexpr ValueTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Property::ScalarPropertyAssignment* scalar_;
      ::Property::StringPropertyAssignment* string_;
      ::Property::VectorPropertyAssignment* vector_;
      ::Property::ColorPropertyAssignment* color_;
      ::Property::TransformPropertyAssignment* transform_;
      ::Property::BooleanPropertyAssignment* boolean_;
      ::Property::JsonPropertyAssignment* json_;
      ::Property::LinkPropertyAssignment* link_;
    } ValueType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpUpdatePropertyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpUpdatePropertyValue) */ {
 public:
  inline OpUpdatePropertyValue() : OpUpdatePropertyValue(nullptr) {}
  ~OpUpdatePropertyValue() override;
  explicit PROTOBUF_CONSTEXPR OpUpdatePropertyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpUpdatePropertyValue(const OpUpdatePropertyValue& from);
  OpUpdatePropertyValue(OpUpdatePropertyValue&& from) noexcept
    : OpUpdatePropertyValue() {
    *this = ::std::move(from);
  }

  inline OpUpdatePropertyValue& operator=(const OpUpdatePropertyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpUpdatePropertyValue& operator=(OpUpdatePropertyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpUpdatePropertyValue& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpUpdatePropertyValue* internal_default_instance() {
    return reinterpret_cast<const OpUpdatePropertyValue*>(
               &_OpUpdatePropertyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(OpUpdatePropertyValue& a, OpUpdatePropertyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(OpUpdatePropertyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpUpdatePropertyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpUpdatePropertyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpUpdatePropertyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpUpdatePropertyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpUpdatePropertyValue& from) {
    OpUpdatePropertyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpUpdatePropertyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpUpdatePropertyValue";
  }
  protected:
  explicit OpUpdatePropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpUpdatePropertyValue_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpUpdatePropertyValue.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpUpdatePropertyValue_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpUpdatePropertyValue_V1* release_v1();
  ::Journal::OpUpdatePropertyValue_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpUpdatePropertyValue_V1* v1);
  private:
  const ::Journal::OpUpdatePropertyValue_V1& _internal_v1() const;
  ::Journal::OpUpdatePropertyValue_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpUpdatePropertyValue_V1* v1);
  ::Journal::OpUpdatePropertyValue_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpUpdatePropertyValue)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpUpdatePropertyValue_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpDeclareProperty_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpDeclareProperty.V1) */ {
 public:
  inline OpDeclareProperty_V1() : OpDeclareProperty_V1(nullptr) {}
  ~OpDeclareProperty_V1() override;
  explicit PROTOBUF_CONSTEXPR OpDeclareProperty_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpDeclareProperty_V1(const OpDeclareProperty_V1& from);
  OpDeclareProperty_V1(OpDeclareProperty_V1&& from) noexcept
    : OpDeclareProperty_V1() {
    *this = ::std::move(from);
  }

  inline OpDeclareProperty_V1& operator=(const OpDeclareProperty_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpDeclareProperty_V1& operator=(OpDeclareProperty_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpDeclareProperty_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpDeclareProperty_V1* internal_default_instance() {
    return reinterpret_cast<const OpDeclareProperty_V1*>(
               &_OpDeclareProperty_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(OpDeclareProperty_V1& a, OpDeclareProperty_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpDeclareProperty_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpDeclareProperty_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpDeclareProperty_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpDeclareProperty_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpDeclareProperty_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpDeclareProperty_V1& from) {
    OpDeclareProperty_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpDeclareProperty_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpDeclareProperty.V1";
  }
  protected:
  explicit OpDeclareProperty_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
    kDeclFieldNumber = 2,
  };
  // .Property.PropertyIdentifier propId = 1;
  bool has_propid() const;
  private:
  bool _internal_has_propid() const;
  public:
  void clear_propid();
  const ::Property::PropertyIdentifier& propid() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propid();
  ::Property::PropertyIdentifier* mutable_propid();
  void set_allocated_propid(::Property::PropertyIdentifier* propid);
  private:
  const ::Property::PropertyIdentifier& _internal_propid() const;
  ::Property::PropertyIdentifier* _internal_mutable_propid();
  public:
  void unsafe_arena_set_allocated_propid(
      ::Property::PropertyIdentifier* propid);
  ::Property::PropertyIdentifier* unsafe_arena_release_propid();

  // .Property.AnyPropertyDeclaration decl = 2;
  bool has_decl() const;
  private:
  bool _internal_has_decl() const;
  public:
  void clear_decl();
  const ::Property::AnyPropertyDeclaration& decl() const;
  PROTOBUF_NODISCARD ::Property::AnyPropertyDeclaration* release_decl();
  ::Property::AnyPropertyDeclaration* mutable_decl();
  void set_allocated_decl(::Property::AnyPropertyDeclaration* decl);
  private:
  const ::Property::AnyPropertyDeclaration& _internal_decl() const;
  ::Property::AnyPropertyDeclaration* _internal_mutable_decl();
  public:
  void unsafe_arena_set_allocated_decl(
      ::Property::AnyPropertyDeclaration* decl);
  ::Property::AnyPropertyDeclaration* unsafe_arena_release_decl();

  // @@protoc_insertion_point(class_scope:Journal.OpDeclareProperty.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Property::PropertyIdentifier* propid_;
    ::Property::AnyPropertyDeclaration* decl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpDeclareProperty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpDeclareProperty) */ {
 public:
  inline OpDeclareProperty() : OpDeclareProperty(nullptr) {}
  ~OpDeclareProperty() override;
  explicit PROTOBUF_CONSTEXPR OpDeclareProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpDeclareProperty(const OpDeclareProperty& from);
  OpDeclareProperty(OpDeclareProperty&& from) noexcept
    : OpDeclareProperty() {
    *this = ::std::move(from);
  }

  inline OpDeclareProperty& operator=(const OpDeclareProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpDeclareProperty& operator=(OpDeclareProperty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpDeclareProperty& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpDeclareProperty* internal_default_instance() {
    return reinterpret_cast<const OpDeclareProperty*>(
               &_OpDeclareProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(OpDeclareProperty& a, OpDeclareProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(OpDeclareProperty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpDeclareProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpDeclareProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpDeclareProperty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpDeclareProperty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpDeclareProperty& from) {
    OpDeclareProperty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpDeclareProperty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpDeclareProperty";
  }
  protected:
  explicit OpDeclareProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpDeclareProperty_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpDeclareProperty.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpDeclareProperty_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpDeclareProperty_V1* release_v1();
  ::Journal::OpDeclareProperty_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpDeclareProperty_V1* v1);
  private:
  const ::Journal::OpDeclareProperty_V1& _internal_v1() const;
  ::Journal::OpDeclareProperty_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpDeclareProperty_V1* v1);
  ::Journal::OpDeclareProperty_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpDeclareProperty)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpDeclareProperty_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpBlindDataOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpBlindDataOp) */ {
 public:
  inline OpBlindDataOp() : OpBlindDataOp(nullptr) {}
  ~OpBlindDataOp() override;
  explicit PROTOBUF_CONSTEXPR OpBlindDataOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpBlindDataOp(const OpBlindDataOp& from);
  OpBlindDataOp(OpBlindDataOp&& from) noexcept
    : OpBlindDataOp() {
    *this = ::std::move(from);
  }

  inline OpBlindDataOp& operator=(const OpBlindDataOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpBlindDataOp& operator=(OpBlindDataOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpBlindDataOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpBlindDataOp* internal_default_instance() {
    return reinterpret_cast<const OpBlindDataOp*>(
               &_OpBlindDataOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(OpBlindDataOp& a, OpBlindDataOp& b) {
    a.Swap(&b);
  }
  inline void Swap(OpBlindDataOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpBlindDataOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpBlindDataOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpBlindDataOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpBlindDataOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpBlindDataOp& from) {
    OpBlindDataOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpBlindDataOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpBlindDataOp";
  }
  protected:
  explicit OpBlindDataOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlindDataIdentifierFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string blindDataIdentifier = 1;
  void clear_blinddataidentifier();
  const std::string& blinddataidentifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blinddataidentifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blinddataidentifier();
  PROTOBUF_NODISCARD std::string* release_blinddataidentifier();
  void set_allocated_blinddataidentifier(std::string* blinddataidentifier);
  private:
  const std::string& _internal_blinddataidentifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blinddataidentifier(const std::string& value);
  std::string* _internal_mutable_blinddataidentifier();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpBlindDataOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blinddataidentifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class UserAuthorityPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.UserAuthorityPayload) */ {
 public:
  inline UserAuthorityPayload() : UserAuthorityPayload(nullptr) {}
  ~UserAuthorityPayload() override;
  explicit PROTOBUF_CONSTEXPR UserAuthorityPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAuthorityPayload(const UserAuthorityPayload& from);
  UserAuthorityPayload(UserAuthorityPayload&& from) noexcept
    : UserAuthorityPayload() {
    *this = ::std::move(from);
  }

  inline UserAuthorityPayload& operator=(const UserAuthorityPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAuthorityPayload& operator=(UserAuthorityPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAuthorityPayload& default_instance() {
    return *internal_default_instance();
  }
  enum FinalizationPayloadCase {
    kMessage = 10,
    kJson = 11,
    FINALIZATIONPAYLOAD_NOT_SET = 0,
  };

  static inline const UserAuthorityPayload* internal_default_instance() {
    return reinterpret_cast<const UserAuthorityPayload*>(
               &_UserAuthorityPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UserAuthorityPayload& a, UserAuthorityPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAuthorityPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAuthorityPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAuthorityPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAuthorityPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAuthorityPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAuthorityPayload& from) {
    UserAuthorityPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAuthorityPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.UserAuthorityPayload";
  }
  protected:
  explicit UserAuthorityPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 10,
    kJsonFieldNumber = 11,
  };
  // string message = 10;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string json = 11;
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  void clear_FinalizationPayload();
  FinalizationPayloadCase FinalizationPayload_case() const;
  // @@protoc_insertion_point(class_scope:Journal.UserAuthorityPayload)
 private:
  class _Internal;
  void set_has_message();
  void set_has_json();

  inline bool has_FinalizationPayload() const;
  inline void clear_has_FinalizationPayload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union FinalizationPayloadUnion {
      constexpr FinalizationPayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
    } FinalizationPayload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpUserAuthorityData_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpUserAuthorityData.V1) */ {
 public:
  inline OpUserAuthorityData_V1() : OpUserAuthorityData_V1(nullptr) {}
  ~OpUserAuthorityData_V1() override;
  explicit PROTOBUF_CONSTEXPR OpUserAuthorityData_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpUserAuthorityData_V1(const OpUserAuthorityData_V1& from);
  OpUserAuthorityData_V1(OpUserAuthorityData_V1&& from) noexcept
    : OpUserAuthorityData_V1() {
    *this = ::std::move(from);
  }

  inline OpUserAuthorityData_V1& operator=(const OpUserAuthorityData_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpUserAuthorityData_V1& operator=(OpUserAuthorityData_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpUserAuthorityData_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpUserAuthorityData_V1* internal_default_instance() {
    return reinterpret_cast<const OpUserAuthorityData_V1*>(
               &_OpUserAuthorityData_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(OpUserAuthorityData_V1& a, OpUserAuthorityData_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpUserAuthorityData_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpUserAuthorityData_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpUserAuthorityData_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpUserAuthorityData_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpUserAuthorityData_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpUserAuthorityData_V1& from) {
    OpUserAuthorityData_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpUserAuthorityData_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpUserAuthorityData.V1";
  }
  protected:
  explicit OpUserAuthorityData_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpUserAuthorityData_V1_AuthorityCoordinationEventEnum AuthorityCoordinationEventEnum;
  static constexpr AuthorityCoordinationEventEnum Finalizing =
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Finalizing;
  static constexpr AuthorityCoordinationEventEnum Coordinating =
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Coordinating;
  static inline bool AuthorityCoordinationEventEnum_IsValid(int value) {
    return OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_IsValid(value);
  }
  static constexpr AuthorityCoordinationEventEnum AuthorityCoordinationEventEnum_MIN =
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_MIN;
  static constexpr AuthorityCoordinationEventEnum AuthorityCoordinationEventEnum_MAX =
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_MAX;
  static constexpr int AuthorityCoordinationEventEnum_ARRAYSIZE =
    OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_AuthorityCoordinationEventEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AuthorityCoordinationEventEnum_descriptor() {
    return OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& AuthorityCoordinationEventEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AuthorityCoordinationEventEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AuthorityCoordinationEventEnum_Name.");
    return OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Name(enum_t_value);
  }
  static inline bool AuthorityCoordinationEventEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AuthorityCoordinationEventEnum* value) {
    return OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorityRequestedKeyFieldNumber = 1,
    kRequestorConnectionIdFieldNumber = 3,
    kPayloadFieldNumber = 4,
    kCoordinationEventTypeFieldNumber = 2,
    kOrdinalFieldNumber = 5,
  };
  // string authorityRequestedKey = 1;
  void clear_authorityrequestedkey();
  const std::string& authorityrequestedkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorityrequestedkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorityrequestedkey();
  PROTOBUF_NODISCARD std::string* release_authorityrequestedkey();
  void set_allocated_authorityrequestedkey(std::string* authorityrequestedkey);
  private:
  const std::string& _internal_authorityrequestedkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorityrequestedkey(const std::string& value);
  std::string* _internal_mutable_authorityrequestedkey();
  public:

  // string requestorConnectionId = 3;
  void clear_requestorconnectionid();
  const std::string& requestorconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requestorconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requestorconnectionid();
  PROTOBUF_NODISCARD std::string* release_requestorconnectionid();
  void set_allocated_requestorconnectionid(std::string* requestorconnectionid);
  private:
  const std::string& _internal_requestorconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestorconnectionid(const std::string& value);
  std::string* _internal_mutable_requestorconnectionid();
  public:

  // .Journal.UserAuthorityPayload payload = 4;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::Journal::UserAuthorityPayload& payload() const;
  PROTOBUF_NODISCARD ::Journal::UserAuthorityPayload* release_payload();
  ::Journal::UserAuthorityPayload* mutable_payload();
  void set_allocated_payload(::Journal::UserAuthorityPayload* payload);
  private:
  const ::Journal::UserAuthorityPayload& _internal_payload() const;
  ::Journal::UserAuthorityPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::Journal::UserAuthorityPayload* payload);
  ::Journal::UserAuthorityPayload* unsafe_arena_release_payload();

  // .Journal.OpUserAuthorityData.V1.AuthorityCoordinationEventEnum coordinationEventType = 2;
  void clear_coordinationeventtype();
  ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum coordinationeventtype() const;
  void set_coordinationeventtype(::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum value);
  private:
  ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum _internal_coordinationeventtype() const;
  void _internal_set_coordinationeventtype(::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum value);
  public:

  // int32 ordinal = 5;
  void clear_ordinal();
  int32_t ordinal() const;
  void set_ordinal(int32_t value);
  private:
  int32_t _internal_ordinal() const;
  void _internal_set_ordinal(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpUserAuthorityData.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorityrequestedkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestorconnectionid_;
    ::Journal::UserAuthorityPayload* payload_;
    int coordinationeventtype_;
    int32_t ordinal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpUserAuthorityData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpUserAuthorityData) */ {
 public:
  inline OpUserAuthorityData() : OpUserAuthorityData(nullptr) {}
  ~OpUserAuthorityData() override;
  explicit PROTOBUF_CONSTEXPR OpUserAuthorityData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpUserAuthorityData(const OpUserAuthorityData& from);
  OpUserAuthorityData(OpUserAuthorityData&& from) noexcept
    : OpUserAuthorityData() {
    *this = ::std::move(from);
  }

  inline OpUserAuthorityData& operator=(const OpUserAuthorityData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpUserAuthorityData& operator=(OpUserAuthorityData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpUserAuthorityData& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpUserAuthorityData* internal_default_instance() {
    return reinterpret_cast<const OpUserAuthorityData*>(
               &_OpUserAuthorityData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(OpUserAuthorityData& a, OpUserAuthorityData& b) {
    a.Swap(&b);
  }
  inline void Swap(OpUserAuthorityData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpUserAuthorityData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpUserAuthorityData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpUserAuthorityData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpUserAuthorityData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpUserAuthorityData& from) {
    OpUserAuthorityData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpUserAuthorityData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpUserAuthorityData";
  }
  protected:
  explicit OpUserAuthorityData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpUserAuthorityData_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpUserAuthorityData.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpUserAuthorityData_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpUserAuthorityData_V1* release_v1();
  ::Journal::OpUserAuthorityData_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpUserAuthorityData_V1* v1);
  private:
  const ::Journal::OpUserAuthorityData_V1& _internal_v1() const;
  ::Journal::OpUserAuthorityData_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpUserAuthorityData_V1* v1);
  ::Journal::OpUserAuthorityData_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpUserAuthorityData)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpUserAuthorityData_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpSetPartHighlight_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpSetPartHighlight.V1) */ {
 public:
  inline OpSetPartHighlight_V1() : OpSetPartHighlight_V1(nullptr) {}
  ~OpSetPartHighlight_V1() override;
  explicit PROTOBUF_CONSTEXPR OpSetPartHighlight_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpSetPartHighlight_V1(const OpSetPartHighlight_V1& from);
  OpSetPartHighlight_V1(OpSetPartHighlight_V1&& from) noexcept
    : OpSetPartHighlight_V1() {
    *this = ::std::move(from);
  }

  inline OpSetPartHighlight_V1& operator=(const OpSetPartHighlight_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpSetPartHighlight_V1& operator=(OpSetPartHighlight_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpSetPartHighlight_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpSetPartHighlight_V1* internal_default_instance() {
    return reinterpret_cast<const OpSetPartHighlight_V1*>(
               &_OpSetPartHighlight_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(OpSetPartHighlight_V1& a, OpSetPartHighlight_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(OpSetPartHighlight_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpSetPartHighlight_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpSetPartHighlight_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpSetPartHighlight_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpSetPartHighlight_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpSetPartHighlight_V1& from) {
    OpSetPartHighlight_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpSetPartHighlight_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpSetPartHighlight.V1";
  }
  protected:
  explicit OpSetPartHighlight_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHighlightDataFieldNumber = 10,
    kSetFieldNumber = 2,
  };
  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .JournalData.PartHighlightData highlightData = 10;
  bool has_highlightdata() const;
  private:
  bool _internal_has_highlightdata() const;
  public:
  void clear_highlightdata();
  const ::JournalData::PartHighlightData& highlightdata() const;
  PROTOBUF_NODISCARD ::JournalData::PartHighlightData* release_highlightdata();
  ::JournalData::PartHighlightData* mutable_highlightdata();
  void set_allocated_highlightdata(::JournalData::PartHighlightData* highlightdata);
  private:
  const ::JournalData::PartHighlightData& _internal_highlightdata() const;
  ::JournalData::PartHighlightData* _internal_mutable_highlightdata();
  public:
  void unsafe_arena_set_allocated_highlightdata(
      ::JournalData::PartHighlightData* highlightdata);
  ::JournalData::PartHighlightData* unsafe_arena_release_highlightdata();

  // bool set = 2;
  void clear_set();
  bool set() const;
  void set_set(bool value);
  private:
  bool _internal_set() const;
  void _internal_set_set(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Journal.OpSetPartHighlight.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::JournalData::ObjectId* objectid_;
    ::JournalData::PartHighlightData* highlightdata_;
    bool set_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OpSetPartHighlight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Journal.OpSetPartHighlight) */ {
 public:
  inline OpSetPartHighlight() : OpSetPartHighlight(nullptr) {}
  ~OpSetPartHighlight() override;
  explicit PROTOBUF_CONSTEXPR OpSetPartHighlight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpSetPartHighlight(const OpSetPartHighlight& from);
  OpSetPartHighlight(OpSetPartHighlight&& from) noexcept
    : OpSetPartHighlight() {
    *this = ::std::move(from);
  }

  inline OpSetPartHighlight& operator=(const OpSetPartHighlight& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpSetPartHighlight& operator=(OpSetPartHighlight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpSetPartHighlight& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const OpSetPartHighlight* internal_default_instance() {
    return reinterpret_cast<const OpSetPartHighlight*>(
               &_OpSetPartHighlight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(OpSetPartHighlight& a, OpSetPartHighlight& b) {
    a.Swap(&b);
  }
  inline void Swap(OpSetPartHighlight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpSetPartHighlight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpSetPartHighlight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpSetPartHighlight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpSetPartHighlight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpSetPartHighlight& from) {
    OpSetPartHighlight::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpSetPartHighlight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Journal.OpSetPartHighlight";
  }
  protected:
  explicit OpSetPartHighlight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpSetPartHighlight_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Journal.OpSetPartHighlight.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Journal::OpSetPartHighlight_V1& v1() const;
  PROTOBUF_NODISCARD ::Journal::OpSetPartHighlight_V1* release_v1();
  ::Journal::OpSetPartHighlight_V1* mutable_v1();
  void set_allocated_v1(::Journal::OpSetPartHighlight_V1* v1);
  private:
  const ::Journal::OpSetPartHighlight_V1& _internal_v1() const;
  ::Journal::OpSetPartHighlight_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Journal::OpSetPartHighlight_V1* v1);
  ::Journal::OpSetPartHighlight_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Journal.OpSetPartHighlight)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpSetPartHighlight_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journal_5foperations_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OperationId

// .google.protobuf.Timestamp time = 1;
inline bool OperationId::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool OperationId::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationId::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationId::time() const {
  // @@protoc_insertion_point(field_get:Journal.OperationId.time)
  return _internal_time();
}
inline void OperationId::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OperationId.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationId::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationId::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:Journal.OperationId.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationId::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationId::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:Journal.OperationId.time)
  return _msg;
}
inline void OperationId::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:Journal.OperationId.time)
}

// string connectionId = 2;
inline void OperationId::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& OperationId::connectionid() const {
  // @@protoc_insertion_point(field_get:Journal.OperationId.connectionId)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationId::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OperationId.connectionId)
}
inline std::string* OperationId::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:Journal.OperationId.connectionId)
  return _s;
}
inline const std::string& OperationId::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void OperationId::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationId::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationId::release_connectionid() {
  // @@protoc_insertion_point(field_release:Journal.OperationId.connectionId)
  return _impl_.connectionid_.Release();
}
inline void OperationId::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OperationId.connectionId)
}

// -------------------------------------------------------------------

// OperationReferenceCollection_ReferenceTimeSpan

// .google.protobuf.Timestamp begin = 1;
inline bool OperationReferenceCollection_ReferenceTimeSpan::_internal_has_begin() const {
  return this != internal_default_instance() && _impl_.begin_ != nullptr;
}
inline bool OperationReferenceCollection_ReferenceTimeSpan::has_begin() const {
  return _internal_has_begin();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceTimeSpan::_internal_begin() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.begin_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceTimeSpan::begin() const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.ReferenceTimeSpan.begin)
  return _internal_begin();
}
inline void OperationReferenceCollection_ReferenceTimeSpan::unsafe_arena_set_allocated_begin(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* begin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.begin_);
  }
  _impl_.begin_ = begin;
  if (begin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OperationReferenceCollection.ReferenceTimeSpan.begin)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::release_begin() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.begin_;
  _impl_.begin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::unsafe_arena_release_begin() {
  // @@protoc_insertion_point(field_release:Journal.OperationReferenceCollection.ReferenceTimeSpan.begin)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.begin_;
  _impl_.begin_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::_internal_mutable_begin() {
  
  if (_impl_.begin_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.begin_ = p;
  }
  return _impl_.begin_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::mutable_begin() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.ReferenceTimeSpan.begin)
  return _msg;
}
inline void OperationReferenceCollection_ReferenceTimeSpan::set_allocated_begin(::PROTOBUF_NAMESPACE_ID::Timestamp* begin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.begin_);
  }
  if (begin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(begin));
    if (message_arena != submessage_arena) {
      begin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, begin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.begin_ = begin;
  // @@protoc_insertion_point(field_set_allocated:Journal.OperationReferenceCollection.ReferenceTimeSpan.begin)
}

// .google.protobuf.Timestamp endInclusive = 2;
inline bool OperationReferenceCollection_ReferenceTimeSpan::_internal_has_endinclusive() const {
  return this != internal_default_instance() && _impl_.endinclusive_ != nullptr;
}
inline bool OperationReferenceCollection_ReferenceTimeSpan::has_endinclusive() const {
  return _internal_has_endinclusive();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceTimeSpan::_internal_endinclusive() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.endinclusive_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceTimeSpan::endinclusive() const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.ReferenceTimeSpan.endInclusive)
  return _internal_endinclusive();
}
inline void OperationReferenceCollection_ReferenceTimeSpan::unsafe_arena_set_allocated_endinclusive(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* endinclusive) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endinclusive_);
  }
  _impl_.endinclusive_ = endinclusive;
  if (endinclusive) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OperationReferenceCollection.ReferenceTimeSpan.endInclusive)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::release_endinclusive() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.endinclusive_;
  _impl_.endinclusive_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::unsafe_arena_release_endinclusive() {
  // @@protoc_insertion_point(field_release:Journal.OperationReferenceCollection.ReferenceTimeSpan.endInclusive)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.endinclusive_;
  _impl_.endinclusive_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::_internal_mutable_endinclusive() {
  
  if (_impl_.endinclusive_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.endinclusive_ = p;
  }
  return _impl_.endinclusive_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceTimeSpan::mutable_endinclusive() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_endinclusive();
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.ReferenceTimeSpan.endInclusive)
  return _msg;
}
inline void OperationReferenceCollection_ReferenceTimeSpan::set_allocated_endinclusive(::PROTOBUF_NAMESPACE_ID::Timestamp* endinclusive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endinclusive_);
  }
  if (endinclusive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endinclusive));
    if (message_arena != submessage_arena) {
      endinclusive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endinclusive, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endinclusive_ = endinclusive;
  // @@protoc_insertion_point(field_set_allocated:Journal.OperationReferenceCollection.ReferenceTimeSpan.endInclusive)
}

// -------------------------------------------------------------------

// OperationReferenceCollection_ReferenceSinglesByConnection

// string fromConnectionId = 1;
inline void OperationReferenceCollection_ReferenceSinglesByConnection::clear_fromconnectionid() {
  _impl_.fromconnectionid_.ClearToEmpty();
}
inline const std::string& OperationReferenceCollection_ReferenceSinglesByConnection::fromconnectionid() const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.fromConnectionId)
  return _internal_fromconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationReferenceCollection_ReferenceSinglesByConnection::set_fromconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.fromConnectionId)
}
inline std::string* OperationReferenceCollection_ReferenceSinglesByConnection::mutable_fromconnectionid() {
  std::string* _s = _internal_mutable_fromconnectionid();
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.fromConnectionId)
  return _s;
}
inline const std::string& OperationReferenceCollection_ReferenceSinglesByConnection::_internal_fromconnectionid() const {
  return _impl_.fromconnectionid_.Get();
}
inline void OperationReferenceCollection_ReferenceSinglesByConnection::_internal_set_fromconnectionid(const std::string& value) {
  
  _impl_.fromconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationReferenceCollection_ReferenceSinglesByConnection::_internal_mutable_fromconnectionid() {
  
  return _impl_.fromconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationReferenceCollection_ReferenceSinglesByConnection::release_fromconnectionid() {
  // @@protoc_insertion_point(field_release:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.fromConnectionId)
  return _impl_.fromconnectionid_.Release();
}
inline void OperationReferenceCollection_ReferenceSinglesByConnection::set_allocated_fromconnectionid(std::string* fromconnectionid) {
  if (fromconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.fromconnectionid_.SetAllocated(fromconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromconnectionid_.IsDefault()) {
    _impl_.fromconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.fromConnectionId)
}

// repeated .google.protobuf.Timestamp atTimeSet = 2;
inline int OperationReferenceCollection_ReferenceSinglesByConnection::_internal_attimeset_size() const {
  return _impl_.attimeset_.size();
}
inline int OperationReferenceCollection_ReferenceSinglesByConnection::attimeset_size() const {
  return _internal_attimeset_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceSinglesByConnection::mutable_attimeset(int index) {
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.atTimeSet)
  return _impl_.attimeset_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
OperationReferenceCollection_ReferenceSinglesByConnection::mutable_attimeset() {
  // @@protoc_insertion_point(field_mutable_list:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.atTimeSet)
  return &_impl_.attimeset_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceSinglesByConnection::_internal_attimeset(int index) const {
  return _impl_.attimeset_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationReferenceCollection_ReferenceSinglesByConnection::attimeset(int index) const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.atTimeSet)
  return _internal_attimeset(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceSinglesByConnection::_internal_add_attimeset() {
  return _impl_.attimeset_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationReferenceCollection_ReferenceSinglesByConnection::add_attimeset() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _add = _internal_add_attimeset();
  // @@protoc_insertion_point(field_add:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.atTimeSet)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
OperationReferenceCollection_ReferenceSinglesByConnection::attimeset() const {
  // @@protoc_insertion_point(field_list:Journal.OperationReferenceCollection.ReferenceSinglesByConnection.atTimeSet)
  return _impl_.attimeset_;
}

// -------------------------------------------------------------------

// OperationReferenceCollection

// repeated .Journal.OperationReferenceCollection.ReferenceTimeSpan spans = 1;
inline int OperationReferenceCollection::_internal_spans_size() const {
  return _impl_.spans_.size();
}
inline int OperationReferenceCollection::spans_size() const {
  return _internal_spans_size();
}
inline void OperationReferenceCollection::clear_spans() {
  _impl_.spans_.Clear();
}
inline ::Journal::OperationReferenceCollection_ReferenceTimeSpan* OperationReferenceCollection::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.spans)
  return _impl_.spans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceTimeSpan >*
OperationReferenceCollection::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:Journal.OperationReferenceCollection.spans)
  return &_impl_.spans_;
}
inline const ::Journal::OperationReferenceCollection_ReferenceTimeSpan& OperationReferenceCollection::_internal_spans(int index) const {
  return _impl_.spans_.Get(index);
}
inline const ::Journal::OperationReferenceCollection_ReferenceTimeSpan& OperationReferenceCollection::spans(int index) const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.spans)
  return _internal_spans(index);
}
inline ::Journal::OperationReferenceCollection_ReferenceTimeSpan* OperationReferenceCollection::_internal_add_spans() {
  return _impl_.spans_.Add();
}
inline ::Journal::OperationReferenceCollection_ReferenceTimeSpan* OperationReferenceCollection::add_spans() {
  ::Journal::OperationReferenceCollection_ReferenceTimeSpan* _add = _internal_add_spans();
  // @@protoc_insertion_point(field_add:Journal.OperationReferenceCollection.spans)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceTimeSpan >&
OperationReferenceCollection::spans() const {
  // @@protoc_insertion_point(field_list:Journal.OperationReferenceCollection.spans)
  return _impl_.spans_;
}

// repeated .Journal.OperationReferenceCollection.ReferenceSinglesByConnection singles = 2;
inline int OperationReferenceCollection::_internal_singles_size() const {
  return _impl_.singles_.size();
}
inline int OperationReferenceCollection::singles_size() const {
  return _internal_singles_size();
}
inline void OperationReferenceCollection::clear_singles() {
  _impl_.singles_.Clear();
}
inline ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* OperationReferenceCollection::mutable_singles(int index) {
  // @@protoc_insertion_point(field_mutable:Journal.OperationReferenceCollection.singles)
  return _impl_.singles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection >*
OperationReferenceCollection::mutable_singles() {
  // @@protoc_insertion_point(field_mutable_list:Journal.OperationReferenceCollection.singles)
  return &_impl_.singles_;
}
inline const ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection& OperationReferenceCollection::_internal_singles(int index) const {
  return _impl_.singles_.Get(index);
}
inline const ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection& OperationReferenceCollection::singles(int index) const {
  // @@protoc_insertion_point(field_get:Journal.OperationReferenceCollection.singles)
  return _internal_singles(index);
}
inline ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* OperationReferenceCollection::_internal_add_singles() {
  return _impl_.singles_.Add();
}
inline ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* OperationReferenceCollection::add_singles() {
  ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection* _add = _internal_add_singles();
  // @@protoc_insertion_point(field_add:Journal.OperationReferenceCollection.singles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Journal::OperationReferenceCollection_ReferenceSinglesByConnection >&
OperationReferenceCollection::singles() const {
  // @@protoc_insertion_point(field_list:Journal.OperationReferenceCollection.singles)
  return _impl_.singles_;
}

// -------------------------------------------------------------------

// OpRemoveOps_V1

// .Journal.OperationReferenceCollection ids = 1;
inline bool OpRemoveOps_V1::_internal_has_ids() const {
  return this != internal_default_instance() && _impl_.ids_ != nullptr;
}
inline bool OpRemoveOps_V1::has_ids() const {
  return _internal_has_ids();
}
inline void OpRemoveOps_V1::clear_ids() {
  if (GetArenaForAllocation() == nullptr && _impl_.ids_ != nullptr) {
    delete _impl_.ids_;
  }
  _impl_.ids_ = nullptr;
}
inline const ::Journal::OperationReferenceCollection& OpRemoveOps_V1::_internal_ids() const {
  const ::Journal::OperationReferenceCollection* p = _impl_.ids_;
  return p != nullptr ? *p : reinterpret_cast<const ::Journal::OperationReferenceCollection&>(
      ::Journal::_OperationReferenceCollection_default_instance_);
}
inline const ::Journal::OperationReferenceCollection& OpRemoveOps_V1::ids() const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.V1.ids)
  return _internal_ids();
}
inline void OpRemoveOps_V1::unsafe_arena_set_allocated_ids(
    ::Journal::OperationReferenceCollection* ids) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ids_);
  }
  _impl_.ids_ = ids;
  if (ids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpRemoveOps.V1.ids)
}
inline ::Journal::OperationReferenceCollection* OpRemoveOps_V1::release_ids() {
  
  ::Journal::OperationReferenceCollection* temp = _impl_.ids_;
  _impl_.ids_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Journal::OperationReferenceCollection* OpRemoveOps_V1::unsafe_arena_release_ids() {
  // @@protoc_insertion_point(field_release:Journal.OpRemoveOps.V1.ids)
  
  ::Journal::OperationReferenceCollection* temp = _impl_.ids_;
  _impl_.ids_ = nullptr;
  return temp;
}
inline ::Journal::OperationReferenceCollection* OpRemoveOps_V1::_internal_mutable_ids() {
  
  if (_impl_.ids_ == nullptr) {
    auto* p = CreateMaybeMessage<::Journal::OperationReferenceCollection>(GetArenaForAllocation());
    _impl_.ids_ = p;
  }
  return _impl_.ids_;
}
inline ::Journal::OperationReferenceCollection* OpRemoveOps_V1::mutable_ids() {
  ::Journal::OperationReferenceCollection* _msg = _internal_mutable_ids();
  // @@protoc_insertion_point(field_mutable:Journal.OpRemoveOps.V1.ids)
  return _msg;
}
inline void OpRemoveOps_V1::set_allocated_ids(::Journal::OperationReferenceCollection* ids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ids_;
  }
  if (ids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ids);
    if (message_arena != submessage_arena) {
      ids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ids, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ids_ = ids;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpRemoveOps.V1.ids)
}

// .Journal.OpRemoveOps.V1.UndoRedoType removalType = 2;
inline void OpRemoveOps_V1::clear_removaltype() {
  _impl_.removaltype_ = 0;
}
inline ::Journal::OpRemoveOps_V1_UndoRedoType OpRemoveOps_V1::_internal_removaltype() const {
  return static_cast< ::Journal::OpRemoveOps_V1_UndoRedoType >(_impl_.removaltype_);
}
inline ::Journal::OpRemoveOps_V1_UndoRedoType OpRemoveOps_V1::removaltype() const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.V1.removalType)
  return _internal_removaltype();
}
inline void OpRemoveOps_V1::_internal_set_removaltype(::Journal::OpRemoveOps_V1_UndoRedoType value) {
  
  _impl_.removaltype_ = value;
}
inline void OpRemoveOps_V1::set_removaltype(::Journal::OpRemoveOps_V1_UndoRedoType value) {
  _internal_set_removaltype(value);
  // @@protoc_insertion_point(field_set:Journal.OpRemoveOps.V1.removalType)
}

// -------------------------------------------------------------------

// OpRemoveOps_V2

// repeated string opIds = 1;
inline int OpRemoveOps_V2::_internal_opids_size() const {
  return _impl_.opids_.size();
}
inline int OpRemoveOps_V2::opids_size() const {
  return _internal_opids_size();
}
inline void OpRemoveOps_V2::clear_opids() {
  _impl_.opids_.Clear();
}
inline std::string* OpRemoveOps_V2::add_opids() {
  std::string* _s = _internal_add_opids();
  // @@protoc_insertion_point(field_add_mutable:Journal.OpRemoveOps.V2.opIds)
  return _s;
}
inline const std::string& OpRemoveOps_V2::_internal_opids(int index) const {
  return _impl_.opids_.Get(index);
}
inline const std::string& OpRemoveOps_V2::opids(int index) const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.V2.opIds)
  return _internal_opids(index);
}
inline std::string* OpRemoveOps_V2::mutable_opids(int index) {
  // @@protoc_insertion_point(field_mutable:Journal.OpRemoveOps.V2.opIds)
  return _impl_.opids_.Mutable(index);
}
inline void OpRemoveOps_V2::set_opids(int index, const std::string& value) {
  _impl_.opids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::set_opids(int index, std::string&& value) {
  _impl_.opids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::set_opids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.opids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::set_opids(int index, const char* value, size_t size) {
  _impl_.opids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Journal.OpRemoveOps.V2.opIds)
}
inline std::string* OpRemoveOps_V2::_internal_add_opids() {
  return _impl_.opids_.Add();
}
inline void OpRemoveOps_V2::add_opids(const std::string& value) {
  _impl_.opids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::add_opids(std::string&& value) {
  _impl_.opids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::add_opids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.opids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Journal.OpRemoveOps.V2.opIds)
}
inline void OpRemoveOps_V2::add_opids(const char* value, size_t size) {
  _impl_.opids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Journal.OpRemoveOps.V2.opIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpRemoveOps_V2::opids() const {
  // @@protoc_insertion_point(field_list:Journal.OpRemoveOps.V2.opIds)
  return _impl_.opids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpRemoveOps_V2::mutable_opids() {
  // @@protoc_insertion_point(field_mutable_list:Journal.OpRemoveOps.V2.opIds)
  return &_impl_.opids_;
}

// .Journal.OpRemoveOps.V2.UndoRedoType removalType = 2;
inline void OpRemoveOps_V2::clear_removaltype() {
  _impl_.removaltype_ = 0;
}
inline ::Journal::OpRemoveOps_V2_UndoRedoType OpRemoveOps_V2::_internal_removaltype() const {
  return static_cast< ::Journal::OpRemoveOps_V2_UndoRedoType >(_impl_.removaltype_);
}
inline ::Journal::OpRemoveOps_V2_UndoRedoType OpRemoveOps_V2::removaltype() const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.V2.removalType)
  return _internal_removaltype();
}
inline void OpRemoveOps_V2::_internal_set_removaltype(::Journal::OpRemoveOps_V2_UndoRedoType value) {
  
  _impl_.removaltype_ = value;
}
inline void OpRemoveOps_V2::set_removaltype(::Journal::OpRemoveOps_V2_UndoRedoType value) {
  _internal_set_removaltype(value);
  // @@protoc_insertion_point(field_set:Journal.OpRemoveOps.V2.removalType)
}

// -------------------------------------------------------------------

// OpRemoveOps

// .Journal.OpRemoveOps.V1 v1 = 1;
inline bool OpRemoveOps::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpRemoveOps::has_v1() const {
  return _internal_has_v1();
}
inline void OpRemoveOps::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpRemoveOps::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpRemoveOps_V1* OpRemoveOps::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpRemoveOps.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpRemoveOps_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpRemoveOps_V1& OpRemoveOps::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpRemoveOps_V1&>(::Journal::_OpRemoveOps_V1_default_instance_);
}
inline const ::Journal::OpRemoveOps_V1& OpRemoveOps::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.v1)
  return _internal_v1();
}
inline ::Journal::OpRemoveOps_V1* OpRemoveOps::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpRemoveOps.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpRemoveOps_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpRemoveOps::unsafe_arena_set_allocated_v1(::Journal::OpRemoveOps_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpRemoveOps.v1)
}
inline ::Journal::OpRemoveOps_V1* OpRemoveOps::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpRemoveOps_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpRemoveOps_V1* OpRemoveOps::mutable_v1() {
  ::Journal::OpRemoveOps_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpRemoveOps.v1)
  return _msg;
}

// .Journal.OpRemoveOps.V2 v2 = 2;
inline bool OpRemoveOps::_internal_has_v2() const {
  return V_case() == kV2;
}
inline bool OpRemoveOps::has_v2() const {
  return _internal_has_v2();
}
inline void OpRemoveOps::set_has_v2() {
  _impl_._oneof_case_[0] = kV2;
}
inline void OpRemoveOps::clear_v2() {
  if (_internal_has_v2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v2_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpRemoveOps_V2* OpRemoveOps::release_v2() {
  // @@protoc_insertion_point(field_release:Journal.OpRemoveOps.v2)
  if (_internal_has_v2()) {
    clear_has_V();
    ::Journal::OpRemoveOps_V2* temp = _impl_.V_.v2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpRemoveOps_V2& OpRemoveOps::_internal_v2() const {
  return _internal_has_v2()
      ? *_impl_.V_.v2_
      : reinterpret_cast< ::Journal::OpRemoveOps_V2&>(::Journal::_OpRemoveOps_V2_default_instance_);
}
inline const ::Journal::OpRemoveOps_V2& OpRemoveOps::v2() const {
  // @@protoc_insertion_point(field_get:Journal.OpRemoveOps.v2)
  return _internal_v2();
}
inline ::Journal::OpRemoveOps_V2* OpRemoveOps::unsafe_arena_release_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpRemoveOps.v2)
  if (_internal_has_v2()) {
    clear_has_V();
    ::Journal::OpRemoveOps_V2* temp = _impl_.V_.v2_;
    _impl_.V_.v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpRemoveOps::unsafe_arena_set_allocated_v2(::Journal::OpRemoveOps_V2* v2) {
  clear_V();
  if (v2) {
    set_has_v2();
    _impl_.V_.v2_ = v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpRemoveOps.v2)
}
inline ::Journal::OpRemoveOps_V2* OpRemoveOps::_internal_mutable_v2() {
  if (!_internal_has_v2()) {
    clear_V();
    set_has_v2();
    _impl_.V_.v2_ = CreateMaybeMessage< ::Journal::OpRemoveOps_V2 >(GetArenaForAllocation());
  }
  return _impl_.V_.v2_;
}
inline ::Journal::OpRemoveOps_V2* OpRemoveOps::mutable_v2() {
  ::Journal::OpRemoveOps_V2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:Journal.OpRemoveOps.v2)
  return _msg;
}

inline bool OpRemoveOps::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpRemoveOps::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpRemoveOps::VCase OpRemoveOps::V_case() const {
  return OpRemoveOps::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpLine2d_V1

// string newObjectId = 10;
inline void OpLine2d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpLine2d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpLine2d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpLine2d.V1.newObjectId)
}
inline std::string* OpLine2d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.V1.newObjectId)
  return _s;
}
inline const std::string& OpLine2d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpLine2d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpLine2d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpLine2d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpLine2d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine2d.V1.newObjectId)
}

// .JournalData.ObjectId objectId = 1;
inline bool OpLine2d_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpLine2d_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpLine2d_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpLine2d_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.objectId)
  return _internal_objectid();
}
inline void OpLine2d_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine2d.V1.objectId)
}
inline ::JournalData::ObjectId* OpLine2d_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpLine2d_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpLine2d_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpLine2d_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.V1.objectId)
  return _msg;
}
inline void OpLine2d_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine2d.V1.objectId)
}

// .JournalData.BoardState visibleWithinState = 2;
inline bool OpLine2d_V1::_internal_has_visiblewithinstate() const {
  return this != internal_default_instance() && _impl_.visiblewithinstate_ != nullptr;
}
inline bool OpLine2d_V1::has_visiblewithinstate() const {
  return _internal_has_visiblewithinstate();
}
inline const ::JournalData::BoardState& OpLine2d_V1::_internal_visiblewithinstate() const {
  const ::JournalData::BoardState* p = _impl_.visiblewithinstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::BoardState&>(
      ::JournalData::_BoardState_default_instance_);
}
inline const ::JournalData::BoardState& OpLine2d_V1::visiblewithinstate() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.visibleWithinState)
  return _internal_visiblewithinstate();
}
inline void OpLine2d_V1::unsafe_arena_set_allocated_visiblewithinstate(
    ::JournalData::BoardState* visiblewithinstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visiblewithinstate_);
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  if (visiblewithinstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine2d.V1.visibleWithinState)
}
inline ::JournalData::BoardState* OpLine2d_V1::release_visiblewithinstate() {
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::BoardState* OpLine2d_V1::unsafe_arena_release_visiblewithinstate() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.V1.visibleWithinState)
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
  return temp;
}
inline ::JournalData::BoardState* OpLine2d_V1::_internal_mutable_visiblewithinstate() {
  
  if (_impl_.visiblewithinstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::BoardState>(GetArenaForAllocation());
    _impl_.visiblewithinstate_ = p;
  }
  return _impl_.visiblewithinstate_;
}
inline ::JournalData::BoardState* OpLine2d_V1::mutable_visiblewithinstate() {
  ::JournalData::BoardState* _msg = _internal_mutable_visiblewithinstate();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.V1.visibleWithinState)
  return _msg;
}
inline void OpLine2d_V1::set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visiblewithinstate_);
  }
  if (visiblewithinstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visiblewithinstate));
    if (message_arena != submessage_arena) {
      visiblewithinstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visiblewithinstate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine2d.V1.visibleWithinState)
}

// .Common.Float2Array points = 3;
inline bool OpLine2d_V1::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool OpLine2d_V1::has_points() const {
  return _internal_has_points();
}
inline const ::Common::Float2Array& OpLine2d_V1::_internal_points() const {
  const ::Common::Float2Array* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float2Array&>(
      ::Common::_Float2Array_default_instance_);
}
inline const ::Common::Float2Array& OpLine2d_V1::points() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.points)
  return _internal_points();
}
inline void OpLine2d_V1::unsafe_arena_set_allocated_points(
    ::Common::Float2Array* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine2d.V1.points)
}
inline ::Common::Float2Array* OpLine2d_V1::release_points() {
  
  ::Common::Float2Array* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float2Array* OpLine2d_V1::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.V1.points)
  
  ::Common::Float2Array* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::Common::Float2Array* OpLine2d_V1::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float2Array>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::Common::Float2Array* OpLine2d_V1::mutable_points() {
  ::Common::Float2Array* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.V1.points)
  return _msg;
}
inline void OpLine2d_V1::set_allocated_points(::Common::Float2Array* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points));
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine2d.V1.points)
}

// float width = 4;
inline void OpLine2d_V1::clear_width() {
  _impl_.width_ = 0;
}
inline float OpLine2d_V1::_internal_width() const {
  return _impl_.width_;
}
inline float OpLine2d_V1::width() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.width)
  return _internal_width();
}
inline void OpLine2d_V1::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void OpLine2d_V1::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Journal.OpLine2d.V1.width)
}

// .Common.Color4 color = 5;
inline bool OpLine2d_V1::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool OpLine2d_V1::has_color() const {
  return _internal_has_color();
}
inline const ::Common::Color4& OpLine2d_V1::_internal_color() const {
  const ::Common::Color4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& OpLine2d_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.V1.color)
  return _internal_color();
}
inline void OpLine2d_V1::unsafe_arena_set_allocated_color(
    ::Common::Color4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine2d.V1.color)
}
inline ::Common::Color4* OpLine2d_V1::release_color() {
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* OpLine2d_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.V1.color)
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Common::Color4* OpLine2d_V1::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Common::Color4* OpLine2d_V1::mutable_color() {
  ::Common::Color4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.V1.color)
  return _msg;
}
inline void OpLine2d_V1::set_allocated_color(::Common::Color4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine2d.V1.color)
}

// -------------------------------------------------------------------

// OpLine2d

// .Journal.OpLine2d.V1 v1 = 1;
inline bool OpLine2d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpLine2d::has_v1() const {
  return _internal_has_v1();
}
inline void OpLine2d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpLine2d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpLine2d_V1* OpLine2d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpLine2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpLine2d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpLine2d_V1& OpLine2d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpLine2d_V1&>(::Journal::_OpLine2d_V1_default_instance_);
}
inline const ::Journal::OpLine2d_V1& OpLine2d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine2d.v1)
  return _internal_v1();
}
inline ::Journal::OpLine2d_V1* OpLine2d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpLine2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpLine2d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpLine2d::unsafe_arena_set_allocated_v1(::Journal::OpLine2d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine2d.v1)
}
inline ::Journal::OpLine2d_V1* OpLine2d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpLine2d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpLine2d_V1* OpLine2d::mutable_v1() {
  ::Journal::OpLine2d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine2d.v1)
  return _msg;
}

inline bool OpLine2d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpLine2d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpLine2d::VCase OpLine2d::V_case() const {
  return OpLine2d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpText2d_V1

// string newObjectId = 10;
inline void OpText2d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpText2d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2d.V1.newObjectId)
}
inline std::string* OpText2d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.newObjectId)
  return _s;
}
inline const std::string& OpText2d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpText2d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpText2d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.newObjectId)
}

// .JournalData.ObjectId objectId = 1;
inline bool OpText2d_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpText2d_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpText2d_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpText2d_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.objectId)
  return _internal_objectid();
}
inline void OpText2d_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2d.V1.objectId)
}
inline ::JournalData::ObjectId* OpText2d_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpText2d_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpText2d_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpText2d_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.objectId)
  return _msg;
}
inline void OpText2d_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.objectId)
}

// .JournalData.BoardState visibleWithinState = 2;
inline bool OpText2d_V1::_internal_has_visiblewithinstate() const {
  return this != internal_default_instance() && _impl_.visiblewithinstate_ != nullptr;
}
inline bool OpText2d_V1::has_visiblewithinstate() const {
  return _internal_has_visiblewithinstate();
}
inline const ::JournalData::BoardState& OpText2d_V1::_internal_visiblewithinstate() const {
  const ::JournalData::BoardState* p = _impl_.visiblewithinstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::BoardState&>(
      ::JournalData::_BoardState_default_instance_);
}
inline const ::JournalData::BoardState& OpText2d_V1::visiblewithinstate() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.visibleWithinState)
  return _internal_visiblewithinstate();
}
inline void OpText2d_V1::unsafe_arena_set_allocated_visiblewithinstate(
    ::JournalData::BoardState* visiblewithinstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visiblewithinstate_);
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  if (visiblewithinstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2d.V1.visibleWithinState)
}
inline ::JournalData::BoardState* OpText2d_V1::release_visiblewithinstate() {
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::BoardState* OpText2d_V1::unsafe_arena_release_visiblewithinstate() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.visibleWithinState)
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
  return temp;
}
inline ::JournalData::BoardState* OpText2d_V1::_internal_mutable_visiblewithinstate() {
  
  if (_impl_.visiblewithinstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::BoardState>(GetArenaForAllocation());
    _impl_.visiblewithinstate_ = p;
  }
  return _impl_.visiblewithinstate_;
}
inline ::JournalData::BoardState* OpText2d_V1::mutable_visiblewithinstate() {
  ::JournalData::BoardState* _msg = _internal_mutable_visiblewithinstate();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.visibleWithinState)
  return _msg;
}
inline void OpText2d_V1::set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visiblewithinstate_);
  }
  if (visiblewithinstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visiblewithinstate));
    if (message_arena != submessage_arena) {
      visiblewithinstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visiblewithinstate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.visibleWithinState)
}

// .Common.Float2 point = 3;
inline bool OpText2d_V1::_internal_has_point() const {
  return this != internal_default_instance() && _impl_.point_ != nullptr;
}
inline bool OpText2d_V1::has_point() const {
  return _internal_has_point();
}
inline const ::Common::Float2& OpText2d_V1::_internal_point() const {
  const ::Common::Float2* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float2&>(
      ::Common::_Float2_default_instance_);
}
inline const ::Common::Float2& OpText2d_V1::point() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.point)
  return _internal_point();
}
inline void OpText2d_V1::unsafe_arena_set_allocated_point(
    ::Common::Float2* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2d.V1.point)
}
inline ::Common::Float2* OpText2d_V1::release_point() {
  
  ::Common::Float2* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float2* OpText2d_V1::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.point)
  
  ::Common::Float2* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::Common::Float2* OpText2d_V1::_internal_mutable_point() {
  
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float2>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::Common::Float2* OpText2d_V1::mutable_point() {
  ::Common::Float2* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.point)
  return _msg;
}
inline void OpText2d_V1::set_allocated_point(::Common::Float2* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point));
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.point)
}

// string text = 4;
inline void OpText2d_V1::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& OpText2d_V1::text() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2d_V1::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2d.V1.text)
}
inline std::string* OpText2d_V1::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.text)
  return _s;
}
inline const std::string& OpText2d_V1::_internal_text() const {
  return _impl_.text_.Get();
}
inline void OpText2d_V1::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2d_V1::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2d_V1::release_text() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.text)
  return _impl_.text_.Release();
}
inline void OpText2d_V1::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.text)
}

// string language = 5;
inline void OpText2d_V1::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& OpText2d_V1::language() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2d_V1::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2d.V1.language)
}
inline std::string* OpText2d_V1::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.language)
  return _s;
}
inline const std::string& OpText2d_V1::_internal_language() const {
  return _impl_.language_.Get();
}
inline void OpText2d_V1::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2d_V1::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2d_V1::release_language() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.language)
  return _impl_.language_.Release();
}
inline void OpText2d_V1::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.language)
}

// .Common.Color4 color = 6;
inline bool OpText2d_V1::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool OpText2d_V1::has_color() const {
  return _internal_has_color();
}
inline const ::Common::Color4& OpText2d_V1::_internal_color() const {
  const ::Common::Color4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& OpText2d_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.color)
  return _internal_color();
}
inline void OpText2d_V1::unsafe_arena_set_allocated_color(
    ::Common::Color4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2d.V1.color)
}
inline ::Common::Color4* OpText2d_V1::release_color() {
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* OpText2d_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.V1.color)
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Common::Color4* OpText2d_V1::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Common::Color4* OpText2d_V1::mutable_color() {
  ::Common::Color4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.V1.color)
  return _msg;
}
inline void OpText2d_V1::set_allocated_color(::Common::Color4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2d.V1.color)
}

// float size = 7;
inline void OpText2d_V1::clear_size() {
  _impl_.size_ = 0;
}
inline float OpText2d_V1::_internal_size() const {
  return _impl_.size_;
}
inline float OpText2d_V1::size() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.V1.size)
  return _internal_size();
}
inline void OpText2d_V1::_internal_set_size(float value) {
  
  _impl_.size_ = value;
}
inline void OpText2d_V1::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Journal.OpText2d.V1.size)
}

// -------------------------------------------------------------------

// OpText2d

// .Journal.OpText2d.V1 v1 = 1;
inline bool OpText2d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpText2d::has_v1() const {
  return _internal_has_v1();
}
inline void OpText2d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpText2d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpText2d_V1* OpText2d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpText2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText2d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText2d_V1& OpText2d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpText2d_V1&>(::Journal::_OpText2d_V1_default_instance_);
}
inline const ::Journal::OpText2d_V1& OpText2d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2d.v1)
  return _internal_v1();
}
inline ::Journal::OpText2d_V1* OpText2d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpText2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText2d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpText2d::unsafe_arena_set_allocated_v1(::Journal::OpText2d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2d.v1)
}
inline ::Journal::OpText2d_V1* OpText2d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpText2d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpText2d_V1* OpText2d::mutable_v1() {
  ::Journal::OpText2d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2d.v1)
  return _msg;
}

inline bool OpText2d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpText2d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpText2d::VCase OpText2d::V_case() const {
  return OpText2d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpText2dModify_V1

// .JournalData.ObjectId objectId = 1;
inline bool OpText2dModify_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpText2dModify_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpText2dModify_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpText2dModify_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.V1.objectId)
  return _internal_objectid();
}
inline void OpText2dModify_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2dModify.V1.objectId)
}
inline ::JournalData::ObjectId* OpText2dModify_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpText2dModify_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpText2dModify_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpText2dModify_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.V1.objectId)
  return _msg;
}
inline void OpText2dModify_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2dModify.V1.objectId)
}

// string text = 4;
inline void OpText2dModify_V1::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& OpText2dModify_V1::text() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.V1.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2dModify_V1::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2dModify.V1.text)
}
inline std::string* OpText2dModify_V1::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.V1.text)
  return _s;
}
inline const std::string& OpText2dModify_V1::_internal_text() const {
  return _impl_.text_.Get();
}
inline void OpText2dModify_V1::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::release_text() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.V1.text)
  return _impl_.text_.Release();
}
inline void OpText2dModify_V1::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2dModify.V1.text)
}

// string language = 5;
inline void OpText2dModify_V1::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& OpText2dModify_V1::language() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.V1.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2dModify_V1::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2dModify.V1.language)
}
inline std::string* OpText2dModify_V1::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.V1.language)
  return _s;
}
inline const std::string& OpText2dModify_V1::_internal_language() const {
  return _impl_.language_.Get();
}
inline void OpText2dModify_V1::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::release_language() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.V1.language)
  return _impl_.language_.Release();
}
inline void OpText2dModify_V1::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2dModify.V1.language)
}

// string translatedFromText = 6;
inline void OpText2dModify_V1::clear_translatedfromtext() {
  _impl_.translatedfromtext_.ClearToEmpty();
}
inline const std::string& OpText2dModify_V1::translatedfromtext() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.V1.translatedFromText)
  return _internal_translatedfromtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2dModify_V1::set_translatedfromtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.translatedfromtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2dModify.V1.translatedFromText)
}
inline std::string* OpText2dModify_V1::mutable_translatedfromtext() {
  std::string* _s = _internal_mutable_translatedfromtext();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.V1.translatedFromText)
  return _s;
}
inline const std::string& OpText2dModify_V1::_internal_translatedfromtext() const {
  return _impl_.translatedfromtext_.Get();
}
inline void OpText2dModify_V1::_internal_set_translatedfromtext(const std::string& value) {
  
  _impl_.translatedfromtext_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::_internal_mutable_translatedfromtext() {
  
  return _impl_.translatedfromtext_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::release_translatedfromtext() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.V1.translatedFromText)
  return _impl_.translatedfromtext_.Release();
}
inline void OpText2dModify_V1::set_allocated_translatedfromtext(std::string* translatedfromtext) {
  if (translatedfromtext != nullptr) {
    
  } else {
    
  }
  _impl_.translatedfromtext_.SetAllocated(translatedfromtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translatedfromtext_.IsDefault()) {
    _impl_.translatedfromtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2dModify.V1.translatedFromText)
}

// string translatedFromLanguage = 7;
inline void OpText2dModify_V1::clear_translatedfromlanguage() {
  _impl_.translatedfromlanguage_.ClearToEmpty();
}
inline const std::string& OpText2dModify_V1::translatedfromlanguage() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.V1.translatedFromLanguage)
  return _internal_translatedfromlanguage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText2dModify_V1::set_translatedfromlanguage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.translatedfromlanguage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText2dModify.V1.translatedFromLanguage)
}
inline std::string* OpText2dModify_V1::mutable_translatedfromlanguage() {
  std::string* _s = _internal_mutable_translatedfromlanguage();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.V1.translatedFromLanguage)
  return _s;
}
inline const std::string& OpText2dModify_V1::_internal_translatedfromlanguage() const {
  return _impl_.translatedfromlanguage_.Get();
}
inline void OpText2dModify_V1::_internal_set_translatedfromlanguage(const std::string& value) {
  
  _impl_.translatedfromlanguage_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::_internal_mutable_translatedfromlanguage() {
  
  return _impl_.translatedfromlanguage_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText2dModify_V1::release_translatedfromlanguage() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.V1.translatedFromLanguage)
  return _impl_.translatedfromlanguage_.Release();
}
inline void OpText2dModify_V1::set_allocated_translatedfromlanguage(std::string* translatedfromlanguage) {
  if (translatedfromlanguage != nullptr) {
    
  } else {
    
  }
  _impl_.translatedfromlanguage_.SetAllocated(translatedfromlanguage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translatedfromlanguage_.IsDefault()) {
    _impl_.translatedfromlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText2dModify.V1.translatedFromLanguage)
}

// -------------------------------------------------------------------

// OpText2dModify

// .Journal.OpText2dModify.V1 v1 = 1;
inline bool OpText2dModify::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpText2dModify::has_v1() const {
  return _internal_has_v1();
}
inline void OpText2dModify::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpText2dModify::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpText2dModify_V1* OpText2dModify::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpText2dModify.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText2dModify_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText2dModify_V1& OpText2dModify::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpText2dModify_V1&>(::Journal::_OpText2dModify_V1_default_instance_);
}
inline const ::Journal::OpText2dModify_V1& OpText2dModify::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpText2dModify.v1)
  return _internal_v1();
}
inline ::Journal::OpText2dModify_V1* OpText2dModify::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpText2dModify.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText2dModify_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpText2dModify::unsafe_arena_set_allocated_v1(::Journal::OpText2dModify_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText2dModify.v1)
}
inline ::Journal::OpText2dModify_V1* OpText2dModify::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpText2dModify_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpText2dModify_V1* OpText2dModify::mutable_v1() {
  ::Journal::OpText2dModify_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpText2dModify.v1)
  return _msg;
}

inline bool OpText2dModify::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpText2dModify::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpText2dModify::VCase OpText2dModify::V_case() const {
  return OpText2dModify::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpImage2d_V1

// string newObjectId = 10;
inline void OpImage2d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpImage2d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage2d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpImage2d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpImage2d.V1.newObjectId)
}
inline std::string* OpImage2d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage2d.V1.newObjectId)
  return _s;
}
inline const std::string& OpImage2d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpImage2d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpImage2d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpImage2d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpImage2d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpImage2d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage2d.V1.newObjectId)
}

// .JournalData.Image2dPlacementData placementData = 1;
inline bool OpImage2d_V1::_internal_has_placementdata() const {
  return this != internal_default_instance() && _impl_.placementdata_ != nullptr;
}
inline bool OpImage2d_V1::has_placementdata() const {
  return _internal_has_placementdata();
}
inline const ::JournalData::Image2dPlacementData& OpImage2d_V1::_internal_placementdata() const {
  const ::JournalData::Image2dPlacementData* p = _impl_.placementdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::Image2dPlacementData&>(
      ::JournalData::_Image2dPlacementData_default_instance_);
}
inline const ::JournalData::Image2dPlacementData& OpImage2d_V1::placementdata() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage2d.V1.placementData)
  return _internal_placementdata();
}
inline void OpImage2d_V1::unsafe_arena_set_allocated_placementdata(
    ::JournalData::Image2dPlacementData* placementdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  _impl_.placementdata_ = placementdata;
  if (placementdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage2d.V1.placementData)
}
inline ::JournalData::Image2dPlacementData* OpImage2d_V1::release_placementdata() {
  
  ::JournalData::Image2dPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::Image2dPlacementData* OpImage2d_V1::unsafe_arena_release_placementdata() {
  // @@protoc_insertion_point(field_release:Journal.OpImage2d.V1.placementData)
  
  ::JournalData::Image2dPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
  return temp;
}
inline ::JournalData::Image2dPlacementData* OpImage2d_V1::_internal_mutable_placementdata() {
  
  if (_impl_.placementdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::Image2dPlacementData>(GetArenaForAllocation());
    _impl_.placementdata_ = p;
  }
  return _impl_.placementdata_;
}
inline ::JournalData::Image2dPlacementData* OpImage2d_V1::mutable_placementdata() {
  ::JournalData::Image2dPlacementData* _msg = _internal_mutable_placementdata();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage2d.V1.placementData)
  return _msg;
}
inline void OpImage2d_V1::set_allocated_placementdata(::JournalData::Image2dPlacementData* placementdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  if (placementdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placementdata));
    if (message_arena != submessage_arena) {
      placementdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placementdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.placementdata_ = placementdata;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage2d.V1.placementData)
}

// .JournalData.ImageContentType contentId = 2;
inline bool OpImage2d_V1::_internal_has_contentid() const {
  return this != internal_default_instance() && _impl_.contentid_ != nullptr;
}
inline bool OpImage2d_V1::has_contentid() const {
  return _internal_has_contentid();
}
inline const ::JournalData::ImageContentType& OpImage2d_V1::_internal_contentid() const {
  const ::JournalData::ImageContentType* p = _impl_.contentid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ImageContentType&>(
      ::JournalData::_ImageContentType_default_instance_);
}
inline const ::JournalData::ImageContentType& OpImage2d_V1::contentid() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage2d.V1.contentId)
  return _internal_contentid();
}
inline void OpImage2d_V1::unsafe_arena_set_allocated_contentid(
    ::JournalData::ImageContentType* contentid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contentid_);
  }
  _impl_.contentid_ = contentid;
  if (contentid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage2d.V1.contentId)
}
inline ::JournalData::ImageContentType* OpImage2d_V1::release_contentid() {
  
  ::JournalData::ImageContentType* temp = _impl_.contentid_;
  _impl_.contentid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ImageContentType* OpImage2d_V1::unsafe_arena_release_contentid() {
  // @@protoc_insertion_point(field_release:Journal.OpImage2d.V1.contentId)
  
  ::JournalData::ImageContentType* temp = _impl_.contentid_;
  _impl_.contentid_ = nullptr;
  return temp;
}
inline ::JournalData::ImageContentType* OpImage2d_V1::_internal_mutable_contentid() {
  
  if (_impl_.contentid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ImageContentType>(GetArenaForAllocation());
    _impl_.contentid_ = p;
  }
  return _impl_.contentid_;
}
inline ::JournalData::ImageContentType* OpImage2d_V1::mutable_contentid() {
  ::JournalData::ImageContentType* _msg = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage2d.V1.contentId)
  return _msg;
}
inline void OpImage2d_V1::set_allocated_contentid(::JournalData::ImageContentType* contentid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contentid_);
  }
  if (contentid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contentid));
    if (message_arena != submessage_arena) {
      contentid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contentid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contentid_ = contentid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage2d.V1.contentId)
}

// -------------------------------------------------------------------

// OpImage2d

// .Journal.OpImage2d.V1 v1 = 1;
inline bool OpImage2d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpImage2d::has_v1() const {
  return _internal_has_v1();
}
inline void OpImage2d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpImage2d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpImage2d_V1* OpImage2d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpImage2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpImage2d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpImage2d_V1& OpImage2d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpImage2d_V1&>(::Journal::_OpImage2d_V1_default_instance_);
}
inline const ::Journal::OpImage2d_V1& OpImage2d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage2d.v1)
  return _internal_v1();
}
inline ::Journal::OpImage2d_V1* OpImage2d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpImage2d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpImage2d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpImage2d::unsafe_arena_set_allocated_v1(::Journal::OpImage2d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage2d.v1)
}
inline ::Journal::OpImage2d_V1* OpImage2d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpImage2d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpImage2d_V1* OpImage2d::mutable_v1() {
  ::Journal::OpImage2d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage2d.v1)
  return _msg;
}

inline bool OpImage2d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpImage2d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpImage2d::VCase OpImage2d::V_case() const {
  return OpImage2d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpLine3d_V1

// string newObjectId = 10;
inline void OpLine3d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpLine3d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpLine3d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpLine3d.V1.newObjectId)
}
inline std::string* OpLine3d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.V1.newObjectId)
  return _s;
}
inline const std::string& OpLine3d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpLine3d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpLine3d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpLine3d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpLine3d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine3d.V1.newObjectId)
}

// .JournalData.ObjectId objectId = 1;
inline bool OpLine3d_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpLine3d_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpLine3d_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpLine3d_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.objectId)
  return _internal_objectid();
}
inline void OpLine3d_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine3d.V1.objectId)
}
inline ::JournalData::ObjectId* OpLine3d_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpLine3d_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpLine3d_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpLine3d_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.V1.objectId)
  return _msg;
}
inline void OpLine3d_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine3d.V1.objectId)
}

// .Common.Float3Array points = 2;
inline bool OpLine3d_V1::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool OpLine3d_V1::has_points() const {
  return _internal_has_points();
}
inline const ::Common::Float3Array& OpLine3d_V1::_internal_points() const {
  const ::Common::Float3Array* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3Array&>(
      ::Common::_Float3Array_default_instance_);
}
inline const ::Common::Float3Array& OpLine3d_V1::points() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.points)
  return _internal_points();
}
inline void OpLine3d_V1::unsafe_arena_set_allocated_points(
    ::Common::Float3Array* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine3d.V1.points)
}
inline ::Common::Float3Array* OpLine3d_V1::release_points() {
  
  ::Common::Float3Array* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3Array* OpLine3d_V1::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.V1.points)
  
  ::Common::Float3Array* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::Common::Float3Array* OpLine3d_V1::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3Array>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::Common::Float3Array* OpLine3d_V1::mutable_points() {
  ::Common::Float3Array* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.V1.points)
  return _msg;
}
inline void OpLine3d_V1::set_allocated_points(::Common::Float3Array* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points));
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine3d.V1.points)
}

// .Common.Float3Array normals = 3;
inline bool OpLine3d_V1::_internal_has_normals() const {
  return this != internal_default_instance() && _impl_.normals_ != nullptr;
}
inline bool OpLine3d_V1::has_normals() const {
  return _internal_has_normals();
}
inline const ::Common::Float3Array& OpLine3d_V1::_internal_normals() const {
  const ::Common::Float3Array* p = _impl_.normals_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3Array&>(
      ::Common::_Float3Array_default_instance_);
}
inline const ::Common::Float3Array& OpLine3d_V1::normals() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.normals)
  return _internal_normals();
}
inline void OpLine3d_V1::unsafe_arena_set_allocated_normals(
    ::Common::Float3Array* normals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.normals_);
  }
  _impl_.normals_ = normals;
  if (normals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine3d.V1.normals)
}
inline ::Common::Float3Array* OpLine3d_V1::release_normals() {
  
  ::Common::Float3Array* temp = _impl_.normals_;
  _impl_.normals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3Array* OpLine3d_V1::unsafe_arena_release_normals() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.V1.normals)
  
  ::Common::Float3Array* temp = _impl_.normals_;
  _impl_.normals_ = nullptr;
  return temp;
}
inline ::Common::Float3Array* OpLine3d_V1::_internal_mutable_normals() {
  
  if (_impl_.normals_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3Array>(GetArenaForAllocation());
    _impl_.normals_ = p;
  }
  return _impl_.normals_;
}
inline ::Common::Float3Array* OpLine3d_V1::mutable_normals() {
  ::Common::Float3Array* _msg = _internal_mutable_normals();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.V1.normals)
  return _msg;
}
inline void OpLine3d_V1::set_allocated_normals(::Common::Float3Array* normals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.normals_);
  }
  if (normals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(normals));
    if (message_arena != submessage_arena) {
      normals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.normals_ = normals;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine3d.V1.normals)
}

// float width = 4;
inline void OpLine3d_V1::clear_width() {
  _impl_.width_ = 0;
}
inline float OpLine3d_V1::_internal_width() const {
  return _impl_.width_;
}
inline float OpLine3d_V1::width() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.width)
  return _internal_width();
}
inline void OpLine3d_V1::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void OpLine3d_V1::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Journal.OpLine3d.V1.width)
}

// .Common.Color4 color = 5;
inline bool OpLine3d_V1::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool OpLine3d_V1::has_color() const {
  return _internal_has_color();
}
inline const ::Common::Color4& OpLine3d_V1::_internal_color() const {
  const ::Common::Color4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& OpLine3d_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.V1.color)
  return _internal_color();
}
inline void OpLine3d_V1::unsafe_arena_set_allocated_color(
    ::Common::Color4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine3d.V1.color)
}
inline ::Common::Color4* OpLine3d_V1::release_color() {
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* OpLine3d_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.V1.color)
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Common::Color4* OpLine3d_V1::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Common::Color4* OpLine3d_V1::mutable_color() {
  ::Common::Color4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.V1.color)
  return _msg;
}
inline void OpLine3d_V1::set_allocated_color(::Common::Color4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpLine3d.V1.color)
}

// -------------------------------------------------------------------

// OpLine3d

// .Journal.OpLine3d.V1 v1 = 1;
inline bool OpLine3d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpLine3d::has_v1() const {
  return _internal_has_v1();
}
inline void OpLine3d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpLine3d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpLine3d_V1* OpLine3d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpLine3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpLine3d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpLine3d_V1& OpLine3d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpLine3d_V1&>(::Journal::_OpLine3d_V1_default_instance_);
}
inline const ::Journal::OpLine3d_V1& OpLine3d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpLine3d.v1)
  return _internal_v1();
}
inline ::Journal::OpLine3d_V1* OpLine3d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpLine3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpLine3d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpLine3d::unsafe_arena_set_allocated_v1(::Journal::OpLine3d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpLine3d.v1)
}
inline ::Journal::OpLine3d_V1* OpLine3d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpLine3d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpLine3d_V1* OpLine3d::mutable_v1() {
  ::Journal::OpLine3d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpLine3d.v1)
  return _msg;
}

inline bool OpLine3d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpLine3d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpLine3d::VCase OpLine3d::V_case() const {
  return OpLine3d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpText3d_V1

// string newObjectId = 1;
inline void OpText3d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpText3d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3d.V1.newObjectId)
}
inline std::string* OpText3d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.V1.newObjectId)
  return _s;
}
inline const std::string& OpText3d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpText3d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpText3d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3d.V1.newObjectId)
}

// .JournalData.TagPlacementData placementData = 2;
inline bool OpText3d_V1::_internal_has_placementdata() const {
  return this != internal_default_instance() && _impl_.placementdata_ != nullptr;
}
inline bool OpText3d_V1::has_placementdata() const {
  return _internal_has_placementdata();
}
inline const ::JournalData::TagPlacementData& OpText3d_V1::_internal_placementdata() const {
  const ::JournalData::TagPlacementData* p = _impl_.placementdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::TagPlacementData&>(
      ::JournalData::_TagPlacementData_default_instance_);
}
inline const ::JournalData::TagPlacementData& OpText3d_V1::placementdata() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.V1.placementData)
  return _internal_placementdata();
}
inline void OpText3d_V1::unsafe_arena_set_allocated_placementdata(
    ::JournalData::TagPlacementData* placementdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  _impl_.placementdata_ = placementdata;
  if (placementdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3d.V1.placementData)
}
inline ::JournalData::TagPlacementData* OpText3d_V1::release_placementdata() {
  
  ::JournalData::TagPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::TagPlacementData* OpText3d_V1::unsafe_arena_release_placementdata() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.V1.placementData)
  
  ::JournalData::TagPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
  return temp;
}
inline ::JournalData::TagPlacementData* OpText3d_V1::_internal_mutable_placementdata() {
  
  if (_impl_.placementdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::TagPlacementData>(GetArenaForAllocation());
    _impl_.placementdata_ = p;
  }
  return _impl_.placementdata_;
}
inline ::JournalData::TagPlacementData* OpText3d_V1::mutable_placementdata() {
  ::JournalData::TagPlacementData* _msg = _internal_mutable_placementdata();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.V1.placementData)
  return _msg;
}
inline void OpText3d_V1::set_allocated_placementdata(::JournalData::TagPlacementData* placementdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  if (placementdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placementdata));
    if (message_arena != submessage_arena) {
      placementdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placementdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.placementdata_ = placementdata;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3d.V1.placementData)
}

// string text = 3;
inline void OpText3d_V1::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& OpText3d_V1::text() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.V1.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3d_V1::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3d.V1.text)
}
inline std::string* OpText3d_V1::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.V1.text)
  return _s;
}
inline const std::string& OpText3d_V1::_internal_text() const {
  return _impl_.text_.Get();
}
inline void OpText3d_V1::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3d_V1::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3d_V1::release_text() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.V1.text)
  return _impl_.text_.Release();
}
inline void OpText3d_V1::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3d.V1.text)
}

// string language = 4;
inline void OpText3d_V1::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& OpText3d_V1::language() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.V1.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3d_V1::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3d.V1.language)
}
inline std::string* OpText3d_V1::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.V1.language)
  return _s;
}
inline const std::string& OpText3d_V1::_internal_language() const {
  return _impl_.language_.Get();
}
inline void OpText3d_V1::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3d_V1::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3d_V1::release_language() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.V1.language)
  return _impl_.language_.Release();
}
inline void OpText3d_V1::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3d.V1.language)
}

// .Common.Color4 color = 5;
inline bool OpText3d_V1::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool OpText3d_V1::has_color() const {
  return _internal_has_color();
}
inline const ::Common::Color4& OpText3d_V1::_internal_color() const {
  const ::Common::Color4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& OpText3d_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.V1.color)
  return _internal_color();
}
inline void OpText3d_V1::unsafe_arena_set_allocated_color(
    ::Common::Color4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3d.V1.color)
}
inline ::Common::Color4* OpText3d_V1::release_color() {
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* OpText3d_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.V1.color)
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Common::Color4* OpText3d_V1::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Common::Color4* OpText3d_V1::mutable_color() {
  ::Common::Color4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.V1.color)
  return _msg;
}
inline void OpText3d_V1::set_allocated_color(::Common::Color4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3d.V1.color)
}

// -------------------------------------------------------------------

// OpText3d

// .Journal.OpText3d.V1 v1 = 1;
inline bool OpText3d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpText3d::has_v1() const {
  return _internal_has_v1();
}
inline void OpText3d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpText3d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpText3d_V1* OpText3d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpText3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText3d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText3d_V1& OpText3d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpText3d_V1&>(::Journal::_OpText3d_V1_default_instance_);
}
inline const ::Journal::OpText3d_V1& OpText3d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3d.v1)
  return _internal_v1();
}
inline ::Journal::OpText3d_V1* OpText3d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpText3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText3d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpText3d::unsafe_arena_set_allocated_v1(::Journal::OpText3d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3d.v1)
}
inline ::Journal::OpText3d_V1* OpText3d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpText3d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpText3d_V1* OpText3d::mutable_v1() {
  ::Journal::OpText3d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3d.v1)
  return _msg;
}

inline bool OpText3d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpText3d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpText3d::VCase OpText3d::V_case() const {
  return OpText3d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpText3dModify_V1

// .JournalData.ObjectId objectId = 1;
inline bool OpText3dModify_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpText3dModify_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpText3dModify_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpText3dModify_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.objectId)
  return _internal_objectid();
}
inline void OpText3dModify_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3dModify.V1.objectId)
}
inline ::JournalData::ObjectId* OpText3dModify_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpText3dModify_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpText3dModify_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpText3dModify_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.objectId)
  return _msg;
}
inline void OpText3dModify_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.objectId)
}

// string text = 3;
inline void OpText3dModify_V1::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& OpText3dModify_V1::text() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3dModify_V1::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3dModify.V1.text)
}
inline std::string* OpText3dModify_V1::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.text)
  return _s;
}
inline const std::string& OpText3dModify_V1::_internal_text() const {
  return _impl_.text_.Get();
}
inline void OpText3dModify_V1::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::release_text() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.text)
  return _impl_.text_.Release();
}
inline void OpText3dModify_V1::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.text)
}

// string language = 4;
inline void OpText3dModify_V1::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& OpText3dModify_V1::language() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3dModify_V1::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3dModify.V1.language)
}
inline std::string* OpText3dModify_V1::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.language)
  return _s;
}
inline const std::string& OpText3dModify_V1::_internal_language() const {
  return _impl_.language_.Get();
}
inline void OpText3dModify_V1::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::release_language() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.language)
  return _impl_.language_.Release();
}
inline void OpText3dModify_V1::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.language)
}

// .Common.Color4 color = 5;
inline bool OpText3dModify_V1::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool OpText3dModify_V1::has_color() const {
  return _internal_has_color();
}
inline const ::Common::Color4& OpText3dModify_V1::_internal_color() const {
  const ::Common::Color4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& OpText3dModify_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.color)
  return _internal_color();
}
inline void OpText3dModify_V1::unsafe_arena_set_allocated_color(
    ::Common::Color4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3dModify.V1.color)
}
inline ::Common::Color4* OpText3dModify_V1::release_color() {
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* OpText3dModify_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.color)
  
  ::Common::Color4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Common::Color4* OpText3dModify_V1::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Common::Color4* OpText3dModify_V1::mutable_color() {
  ::Common::Color4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.color)
  return _msg;
}
inline void OpText3dModify_V1::set_allocated_color(::Common::Color4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.color)
}

// string translatedFromText = 6;
inline void OpText3dModify_V1::clear_translatedfromtext() {
  _impl_.translatedfromtext_.ClearToEmpty();
}
inline const std::string& OpText3dModify_V1::translatedfromtext() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.translatedFromText)
  return _internal_translatedfromtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3dModify_V1::set_translatedfromtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.translatedfromtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3dModify.V1.translatedFromText)
}
inline std::string* OpText3dModify_V1::mutable_translatedfromtext() {
  std::string* _s = _internal_mutable_translatedfromtext();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.translatedFromText)
  return _s;
}
inline const std::string& OpText3dModify_V1::_internal_translatedfromtext() const {
  return _impl_.translatedfromtext_.Get();
}
inline void OpText3dModify_V1::_internal_set_translatedfromtext(const std::string& value) {
  
  _impl_.translatedfromtext_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::_internal_mutable_translatedfromtext() {
  
  return _impl_.translatedfromtext_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::release_translatedfromtext() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.translatedFromText)
  return _impl_.translatedfromtext_.Release();
}
inline void OpText3dModify_V1::set_allocated_translatedfromtext(std::string* translatedfromtext) {
  if (translatedfromtext != nullptr) {
    
  } else {
    
  }
  _impl_.translatedfromtext_.SetAllocated(translatedfromtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translatedfromtext_.IsDefault()) {
    _impl_.translatedfromtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.translatedFromText)
}

// string translatedFromLanguage = 7;
inline void OpText3dModify_V1::clear_translatedfromlanguage() {
  _impl_.translatedfromlanguage_.ClearToEmpty();
}
inline const std::string& OpText3dModify_V1::translatedfromlanguage() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.V1.translatedFromLanguage)
  return _internal_translatedfromlanguage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpText3dModify_V1::set_translatedfromlanguage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.translatedfromlanguage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpText3dModify.V1.translatedFromLanguage)
}
inline std::string* OpText3dModify_V1::mutable_translatedfromlanguage() {
  std::string* _s = _internal_mutable_translatedfromlanguage();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.V1.translatedFromLanguage)
  return _s;
}
inline const std::string& OpText3dModify_V1::_internal_translatedfromlanguage() const {
  return _impl_.translatedfromlanguage_.Get();
}
inline void OpText3dModify_V1::_internal_set_translatedfromlanguage(const std::string& value) {
  
  _impl_.translatedfromlanguage_.Set(value, GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::_internal_mutable_translatedfromlanguage() {
  
  return _impl_.translatedfromlanguage_.Mutable(GetArenaForAllocation());
}
inline std::string* OpText3dModify_V1::release_translatedfromlanguage() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.V1.translatedFromLanguage)
  return _impl_.translatedfromlanguage_.Release();
}
inline void OpText3dModify_V1::set_allocated_translatedfromlanguage(std::string* translatedfromlanguage) {
  if (translatedfromlanguage != nullptr) {
    
  } else {
    
  }
  _impl_.translatedfromlanguage_.SetAllocated(translatedfromlanguage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translatedfromlanguage_.IsDefault()) {
    _impl_.translatedfromlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpText3dModify.V1.translatedFromLanguage)
}

// -------------------------------------------------------------------

// OpText3dModify

// .Journal.OpText3dModify.V1 v1 = 1;
inline bool OpText3dModify::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpText3dModify::has_v1() const {
  return _internal_has_v1();
}
inline void OpText3dModify::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpText3dModify::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpText3dModify_V1* OpText3dModify::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpText3dModify.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText3dModify_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText3dModify_V1& OpText3dModify::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpText3dModify_V1&>(::Journal::_OpText3dModify_V1_default_instance_);
}
inline const ::Journal::OpText3dModify_V1& OpText3dModify::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpText3dModify.v1)
  return _internal_v1();
}
inline ::Journal::OpText3dModify_V1* OpText3dModify::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpText3dModify.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpText3dModify_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpText3dModify::unsafe_arena_set_allocated_v1(::Journal::OpText3dModify_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpText3dModify.v1)
}
inline ::Journal::OpText3dModify_V1* OpText3dModify::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpText3dModify_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpText3dModify_V1* OpText3dModify::mutable_v1() {
  ::Journal::OpText3dModify_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpText3dModify.v1)
  return _msg;
}

inline bool OpText3dModify::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpText3dModify::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpText3dModify::VCase OpText3dModify::V_case() const {
  return OpText3dModify::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpImage3d_V1

// string newObjectId = 1;
inline void OpImage3d_V1::clear_newobjectid() {
  _impl_.newobjectid_.ClearToEmpty();
}
inline const std::string& OpImage3d_V1::newobjectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage3d.V1.newObjectId)
  return _internal_newobjectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpImage3d_V1::set_newobjectid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newobjectid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpImage3d.V1.newObjectId)
}
inline std::string* OpImage3d_V1::mutable_newobjectid() {
  std::string* _s = _internal_mutable_newobjectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage3d.V1.newObjectId)
  return _s;
}
inline const std::string& OpImage3d_V1::_internal_newobjectid() const {
  return _impl_.newobjectid_.Get();
}
inline void OpImage3d_V1::_internal_set_newobjectid(const std::string& value) {
  
  _impl_.newobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpImage3d_V1::_internal_mutable_newobjectid() {
  
  return _impl_.newobjectid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpImage3d_V1::release_newobjectid() {
  // @@protoc_insertion_point(field_release:Journal.OpImage3d.V1.newObjectId)
  return _impl_.newobjectid_.Release();
}
inline void OpImage3d_V1::set_allocated_newobjectid(std::string* newobjectid) {
  if (newobjectid != nullptr) {
    
  } else {
    
  }
  _impl_.newobjectid_.SetAllocated(newobjectid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newobjectid_.IsDefault()) {
    _impl_.newobjectid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage3d.V1.newObjectId)
}

// .JournalData.TagPlacementData placementData = 2;
inline bool OpImage3d_V1::_internal_has_placementdata() const {
  return this != internal_default_instance() && _impl_.placementdata_ != nullptr;
}
inline bool OpImage3d_V1::has_placementdata() const {
  return _internal_has_placementdata();
}
inline const ::JournalData::TagPlacementData& OpImage3d_V1::_internal_placementdata() const {
  const ::JournalData::TagPlacementData* p = _impl_.placementdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::TagPlacementData&>(
      ::JournalData::_TagPlacementData_default_instance_);
}
inline const ::JournalData::TagPlacementData& OpImage3d_V1::placementdata() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage3d.V1.placementData)
  return _internal_placementdata();
}
inline void OpImage3d_V1::unsafe_arena_set_allocated_placementdata(
    ::JournalData::TagPlacementData* placementdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  _impl_.placementdata_ = placementdata;
  if (placementdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage3d.V1.placementData)
}
inline ::JournalData::TagPlacementData* OpImage3d_V1::release_placementdata() {
  
  ::JournalData::TagPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::TagPlacementData* OpImage3d_V1::unsafe_arena_release_placementdata() {
  // @@protoc_insertion_point(field_release:Journal.OpImage3d.V1.placementData)
  
  ::JournalData::TagPlacementData* temp = _impl_.placementdata_;
  _impl_.placementdata_ = nullptr;
  return temp;
}
inline ::JournalData::TagPlacementData* OpImage3d_V1::_internal_mutable_placementdata() {
  
  if (_impl_.placementdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::TagPlacementData>(GetArenaForAllocation());
    _impl_.placementdata_ = p;
  }
  return _impl_.placementdata_;
}
inline ::JournalData::TagPlacementData* OpImage3d_V1::mutable_placementdata() {
  ::JournalData::TagPlacementData* _msg = _internal_mutable_placementdata();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage3d.V1.placementData)
  return _msg;
}
inline void OpImage3d_V1::set_allocated_placementdata(::JournalData::TagPlacementData* placementdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placementdata_);
  }
  if (placementdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placementdata));
    if (message_arena != submessage_arena) {
      placementdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placementdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.placementdata_ = placementdata;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage3d.V1.placementData)
}

// .JournalData.ImageContentType contentId = 3;
inline bool OpImage3d_V1::_internal_has_contentid() const {
  return this != internal_default_instance() && _impl_.contentid_ != nullptr;
}
inline bool OpImage3d_V1::has_contentid() const {
  return _internal_has_contentid();
}
inline const ::JournalData::ImageContentType& OpImage3d_V1::_internal_contentid() const {
  const ::JournalData::ImageContentType* p = _impl_.contentid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ImageContentType&>(
      ::JournalData::_ImageContentType_default_instance_);
}
inline const ::JournalData::ImageContentType& OpImage3d_V1::contentid() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage3d.V1.contentId)
  return _internal_contentid();
}
inline void OpImage3d_V1::unsafe_arena_set_allocated_contentid(
    ::JournalData::ImageContentType* contentid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contentid_);
  }
  _impl_.contentid_ = contentid;
  if (contentid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage3d.V1.contentId)
}
inline ::JournalData::ImageContentType* OpImage3d_V1::release_contentid() {
  
  ::JournalData::ImageContentType* temp = _impl_.contentid_;
  _impl_.contentid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ImageContentType* OpImage3d_V1::unsafe_arena_release_contentid() {
  // @@protoc_insertion_point(field_release:Journal.OpImage3d.V1.contentId)
  
  ::JournalData::ImageContentType* temp = _impl_.contentid_;
  _impl_.contentid_ = nullptr;
  return temp;
}
inline ::JournalData::ImageContentType* OpImage3d_V1::_internal_mutable_contentid() {
  
  if (_impl_.contentid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ImageContentType>(GetArenaForAllocation());
    _impl_.contentid_ = p;
  }
  return _impl_.contentid_;
}
inline ::JournalData::ImageContentType* OpImage3d_V1::mutable_contentid() {
  ::JournalData::ImageContentType* _msg = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage3d.V1.contentId)
  return _msg;
}
inline void OpImage3d_V1::set_allocated_contentid(::JournalData::ImageContentType* contentid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contentid_);
  }
  if (contentid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contentid));
    if (message_arena != submessage_arena) {
      contentid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contentid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contentid_ = contentid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpImage3d.V1.contentId)
}

// -------------------------------------------------------------------

// OpImage3d

// .Journal.OpImage3d.V1 v1 = 1;
inline bool OpImage3d::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpImage3d::has_v1() const {
  return _internal_has_v1();
}
inline void OpImage3d::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpImage3d::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpImage3d_V1* OpImage3d::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpImage3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpImage3d_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpImage3d_V1& OpImage3d::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpImage3d_V1&>(::Journal::_OpImage3d_V1_default_instance_);
}
inline const ::Journal::OpImage3d_V1& OpImage3d::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpImage3d.v1)
  return _internal_v1();
}
inline ::Journal::OpImage3d_V1* OpImage3d::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpImage3d.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpImage3d_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpImage3d::unsafe_arena_set_allocated_v1(::Journal::OpImage3d_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpImage3d.v1)
}
inline ::Journal::OpImage3d_V1* OpImage3d::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpImage3d_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpImage3d_V1* OpImage3d::mutable_v1() {
  ::Journal::OpImage3d_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpImage3d.v1)
  return _msg;
}

inline bool OpImage3d::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpImage3d::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpImage3d::VCase OpImage3d::V_case() const {
  return OpImage3d::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpUpdatePropertyValue_V1

// .Property.PropertyIdentifier propId = 1;
inline bool OpUpdatePropertyValue_V1::_internal_has_propid() const {
  return this != internal_default_instance() && _impl_.propid_ != nullptr;
}
inline bool OpUpdatePropertyValue_V1::has_propid() const {
  return _internal_has_propid();
}
inline const ::Property::PropertyIdentifier& OpUpdatePropertyValue_V1::_internal_propid() const {
  const ::Property::PropertyIdentifier* p = _impl_.propid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& OpUpdatePropertyValue_V1::propid() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.propId)
  return _internal_propid();
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_propid(
    ::Property::PropertyIdentifier* propid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propid_);
  }
  _impl_.propid_ = propid;
  if (propid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.propId)
}
inline ::Property::PropertyIdentifier* OpUpdatePropertyValue_V1::release_propid() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propid_;
  _impl_.propid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* OpUpdatePropertyValue_V1::unsafe_arena_release_propid() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.propId)
  
  ::Property::PropertyIdentifier* temp = _impl_.propid_;
  _impl_.propid_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* OpUpdatePropertyValue_V1::_internal_mutable_propid() {
  
  if (_impl_.propid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propid_ = p;
  }
  return _impl_.propid_;
}
inline ::Property::PropertyIdentifier* OpUpdatePropertyValue_V1::mutable_propid() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propid();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.propId)
  return _msg;
}
inline void OpUpdatePropertyValue_V1::set_allocated_propid(::Property::PropertyIdentifier* propid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propid_);
  }
  if (propid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propid));
    if (message_arena != submessage_arena) {
      propid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propid_ = propid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpUpdatePropertyValue.V1.propId)
}

// .Property.ScalarPropertyAssignment scalar = 2;
inline bool OpUpdatePropertyValue_V1::_internal_has_scalar() const {
  return ValueType_case() == kScalar;
}
inline bool OpUpdatePropertyValue_V1::has_scalar() const {
  return _internal_has_scalar();
}
inline void OpUpdatePropertyValue_V1::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline ::Property::ScalarPropertyAssignment* OpUpdatePropertyValue_V1::release_scalar() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.scalar)
  if (_internal_has_scalar()) {
    clear_has_ValueType();
    ::Property::ScalarPropertyAssignment* temp = _impl_.ValueType_.scalar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::ScalarPropertyAssignment& OpUpdatePropertyValue_V1::_internal_scalar() const {
  return _internal_has_scalar()
      ? *_impl_.ValueType_.scalar_
      : reinterpret_cast< ::Property::ScalarPropertyAssignment&>(::Property::_ScalarPropertyAssignment_default_instance_);
}
inline const ::Property::ScalarPropertyAssignment& OpUpdatePropertyValue_V1::scalar() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.scalar)
  return _internal_scalar();
}
inline ::Property::ScalarPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.scalar)
  if (_internal_has_scalar()) {
    clear_has_ValueType();
    ::Property::ScalarPropertyAssignment* temp = _impl_.ValueType_.scalar_;
    _impl_.ValueType_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_scalar(::Property::ScalarPropertyAssignment* scalar) {
  clear_ValueType();
  if (scalar) {
    set_has_scalar();
    _impl_.ValueType_.scalar_ = scalar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.scalar)
}
inline ::Property::ScalarPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_scalar() {
  if (!_internal_has_scalar()) {
    clear_ValueType();
    set_has_scalar();
    _impl_.ValueType_.scalar_ = CreateMaybeMessage< ::Property::ScalarPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.scalar_;
}
inline ::Property::ScalarPropertyAssignment* OpUpdatePropertyValue_V1::mutable_scalar() {
  ::Property::ScalarPropertyAssignment* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.scalar)
  return _msg;
}

// .Property.StringPropertyAssignment string = 3;
inline bool OpUpdatePropertyValue_V1::_internal_has_string() const {
  return ValueType_case() == kString;
}
inline bool OpUpdatePropertyValue_V1::has_string() const {
  return _internal_has_string();
}
inline void OpUpdatePropertyValue_V1::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline ::Property::StringPropertyAssignment* OpUpdatePropertyValue_V1::release_string() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.string)
  if (_internal_has_string()) {
    clear_has_ValueType();
    ::Property::StringPropertyAssignment* temp = _impl_.ValueType_.string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::StringPropertyAssignment& OpUpdatePropertyValue_V1::_internal_string() const {
  return _internal_has_string()
      ? *_impl_.ValueType_.string_
      : reinterpret_cast< ::Property::StringPropertyAssignment&>(::Property::_StringPropertyAssignment_default_instance_);
}
inline const ::Property::StringPropertyAssignment& OpUpdatePropertyValue_V1::string() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.string)
  return _internal_string();
}
inline ::Property::StringPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.string)
  if (_internal_has_string()) {
    clear_has_ValueType();
    ::Property::StringPropertyAssignment* temp = _impl_.ValueType_.string_;
    _impl_.ValueType_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_string(::Property::StringPropertyAssignment* string) {
  clear_ValueType();
  if (string) {
    set_has_string();
    _impl_.ValueType_.string_ = string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.string)
}
inline ::Property::StringPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_ValueType();
    set_has_string();
    _impl_.ValueType_.string_ = CreateMaybeMessage< ::Property::StringPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.string_;
}
inline ::Property::StringPropertyAssignment* OpUpdatePropertyValue_V1::mutable_string() {
  ::Property::StringPropertyAssignment* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.string)
  return _msg;
}

// .Property.VectorPropertyAssignment vector = 4;
inline bool OpUpdatePropertyValue_V1::_internal_has_vector() const {
  return ValueType_case() == kVector;
}
inline bool OpUpdatePropertyValue_V1::has_vector() const {
  return _internal_has_vector();
}
inline void OpUpdatePropertyValue_V1::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline ::Property::VectorPropertyAssignment* OpUpdatePropertyValue_V1::release_vector() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.vector)
  if (_internal_has_vector()) {
    clear_has_ValueType();
    ::Property::VectorPropertyAssignment* temp = _impl_.ValueType_.vector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::VectorPropertyAssignment& OpUpdatePropertyValue_V1::_internal_vector() const {
  return _internal_has_vector()
      ? *_impl_.ValueType_.vector_
      : reinterpret_cast< ::Property::VectorPropertyAssignment&>(::Property::_VectorPropertyAssignment_default_instance_);
}
inline const ::Property::VectorPropertyAssignment& OpUpdatePropertyValue_V1::vector() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.vector)
  return _internal_vector();
}
inline ::Property::VectorPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.vector)
  if (_internal_has_vector()) {
    clear_has_ValueType();
    ::Property::VectorPropertyAssignment* temp = _impl_.ValueType_.vector_;
    _impl_.ValueType_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_vector(::Property::VectorPropertyAssignment* vector) {
  clear_ValueType();
  if (vector) {
    set_has_vector();
    _impl_.ValueType_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.vector)
}
inline ::Property::VectorPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_vector() {
  if (!_internal_has_vector()) {
    clear_ValueType();
    set_has_vector();
    _impl_.ValueType_.vector_ = CreateMaybeMessage< ::Property::VectorPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.vector_;
}
inline ::Property::VectorPropertyAssignment* OpUpdatePropertyValue_V1::mutable_vector() {
  ::Property::VectorPropertyAssignment* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.vector)
  return _msg;
}

// .Property.ColorPropertyAssignment color = 5;
inline bool OpUpdatePropertyValue_V1::_internal_has_color() const {
  return ValueType_case() == kColor;
}
inline bool OpUpdatePropertyValue_V1::has_color() const {
  return _internal_has_color();
}
inline void OpUpdatePropertyValue_V1::set_has_color() {
  _impl_._oneof_case_[0] = kColor;
}
inline ::Property::ColorPropertyAssignment* OpUpdatePropertyValue_V1::release_color() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.color)
  if (_internal_has_color()) {
    clear_has_ValueType();
    ::Property::ColorPropertyAssignment* temp = _impl_.ValueType_.color_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::ColorPropertyAssignment& OpUpdatePropertyValue_V1::_internal_color() const {
  return _internal_has_color()
      ? *_impl_.ValueType_.color_
      : reinterpret_cast< ::Property::ColorPropertyAssignment&>(::Property::_ColorPropertyAssignment_default_instance_);
}
inline const ::Property::ColorPropertyAssignment& OpUpdatePropertyValue_V1::color() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.color)
  return _internal_color();
}
inline ::Property::ColorPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.color)
  if (_internal_has_color()) {
    clear_has_ValueType();
    ::Property::ColorPropertyAssignment* temp = _impl_.ValueType_.color_;
    _impl_.ValueType_.color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_color(::Property::ColorPropertyAssignment* color) {
  clear_ValueType();
  if (color) {
    set_has_color();
    _impl_.ValueType_.color_ = color;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.color)
}
inline ::Property::ColorPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_color() {
  if (!_internal_has_color()) {
    clear_ValueType();
    set_has_color();
    _impl_.ValueType_.color_ = CreateMaybeMessage< ::Property::ColorPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.color_;
}
inline ::Property::ColorPropertyAssignment* OpUpdatePropertyValue_V1::mutable_color() {
  ::Property::ColorPropertyAssignment* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.color)
  return _msg;
}

// .Property.TransformPropertyAssignment transform = 6;
inline bool OpUpdatePropertyValue_V1::_internal_has_transform() const {
  return ValueType_case() == kTransform;
}
inline bool OpUpdatePropertyValue_V1::has_transform() const {
  return _internal_has_transform();
}
inline void OpUpdatePropertyValue_V1::set_has_transform() {
  _impl_._oneof_case_[0] = kTransform;
}
inline ::Property::TransformPropertyAssignment* OpUpdatePropertyValue_V1::release_transform() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.transform)
  if (_internal_has_transform()) {
    clear_has_ValueType();
    ::Property::TransformPropertyAssignment* temp = _impl_.ValueType_.transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::TransformPropertyAssignment& OpUpdatePropertyValue_V1::_internal_transform() const {
  return _internal_has_transform()
      ? *_impl_.ValueType_.transform_
      : reinterpret_cast< ::Property::TransformPropertyAssignment&>(::Property::_TransformPropertyAssignment_default_instance_);
}
inline const ::Property::TransformPropertyAssignment& OpUpdatePropertyValue_V1::transform() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.transform)
  return _internal_transform();
}
inline ::Property::TransformPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.transform)
  if (_internal_has_transform()) {
    clear_has_ValueType();
    ::Property::TransformPropertyAssignment* temp = _impl_.ValueType_.transform_;
    _impl_.ValueType_.transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_transform(::Property::TransformPropertyAssignment* transform) {
  clear_ValueType();
  if (transform) {
    set_has_transform();
    _impl_.ValueType_.transform_ = transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.transform)
}
inline ::Property::TransformPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_transform() {
  if (!_internal_has_transform()) {
    clear_ValueType();
    set_has_transform();
    _impl_.ValueType_.transform_ = CreateMaybeMessage< ::Property::TransformPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.transform_;
}
inline ::Property::TransformPropertyAssignment* OpUpdatePropertyValue_V1::mutable_transform() {
  ::Property::TransformPropertyAssignment* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.transform)
  return _msg;
}

// .Property.BooleanPropertyAssignment boolean = 7;
inline bool OpUpdatePropertyValue_V1::_internal_has_boolean() const {
  return ValueType_case() == kBoolean;
}
inline bool OpUpdatePropertyValue_V1::has_boolean() const {
  return _internal_has_boolean();
}
inline void OpUpdatePropertyValue_V1::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline ::Property::BooleanPropertyAssignment* OpUpdatePropertyValue_V1::release_boolean() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.boolean)
  if (_internal_has_boolean()) {
    clear_has_ValueType();
    ::Property::BooleanPropertyAssignment* temp = _impl_.ValueType_.boolean_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.boolean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::BooleanPropertyAssignment& OpUpdatePropertyValue_V1::_internal_boolean() const {
  return _internal_has_boolean()
      ? *_impl_.ValueType_.boolean_
      : reinterpret_cast< ::Property::BooleanPropertyAssignment&>(::Property::_BooleanPropertyAssignment_default_instance_);
}
inline const ::Property::BooleanPropertyAssignment& OpUpdatePropertyValue_V1::boolean() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.boolean)
  return _internal_boolean();
}
inline ::Property::BooleanPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_boolean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.boolean)
  if (_internal_has_boolean()) {
    clear_has_ValueType();
    ::Property::BooleanPropertyAssignment* temp = _impl_.ValueType_.boolean_;
    _impl_.ValueType_.boolean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_boolean(::Property::BooleanPropertyAssignment* boolean) {
  clear_ValueType();
  if (boolean) {
    set_has_boolean();
    _impl_.ValueType_.boolean_ = boolean;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.boolean)
}
inline ::Property::BooleanPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_boolean() {
  if (!_internal_has_boolean()) {
    clear_ValueType();
    set_has_boolean();
    _impl_.ValueType_.boolean_ = CreateMaybeMessage< ::Property::BooleanPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.boolean_;
}
inline ::Property::BooleanPropertyAssignment* OpUpdatePropertyValue_V1::mutable_boolean() {
  ::Property::BooleanPropertyAssignment* _msg = _internal_mutable_boolean();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.boolean)
  return _msg;
}

// .Property.JsonPropertyAssignment json = 9;
inline bool OpUpdatePropertyValue_V1::_internal_has_json() const {
  return ValueType_case() == kJson;
}
inline bool OpUpdatePropertyValue_V1::has_json() const {
  return _internal_has_json();
}
inline void OpUpdatePropertyValue_V1::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline ::Property::JsonPropertyAssignment* OpUpdatePropertyValue_V1::release_json() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.json)
  if (_internal_has_json()) {
    clear_has_ValueType();
    ::Property::JsonPropertyAssignment* temp = _impl_.ValueType_.json_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::JsonPropertyAssignment& OpUpdatePropertyValue_V1::_internal_json() const {
  return _internal_has_json()
      ? *_impl_.ValueType_.json_
      : reinterpret_cast< ::Property::JsonPropertyAssignment&>(::Property::_JsonPropertyAssignment_default_instance_);
}
inline const ::Property::JsonPropertyAssignment& OpUpdatePropertyValue_V1::json() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.json)
  return _internal_json();
}
inline ::Property::JsonPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_json() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.json)
  if (_internal_has_json()) {
    clear_has_ValueType();
    ::Property::JsonPropertyAssignment* temp = _impl_.ValueType_.json_;
    _impl_.ValueType_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_json(::Property::JsonPropertyAssignment* json) {
  clear_ValueType();
  if (json) {
    set_has_json();
    _impl_.ValueType_.json_ = json;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.json)
}
inline ::Property::JsonPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_ValueType();
    set_has_json();
    _impl_.ValueType_.json_ = CreateMaybeMessage< ::Property::JsonPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.json_;
}
inline ::Property::JsonPropertyAssignment* OpUpdatePropertyValue_V1::mutable_json() {
  ::Property::JsonPropertyAssignment* _msg = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.json)
  return _msg;
}

// .Property.LinkPropertyAssignment link = 10;
inline bool OpUpdatePropertyValue_V1::_internal_has_link() const {
  return ValueType_case() == kLink;
}
inline bool OpUpdatePropertyValue_V1::has_link() const {
  return _internal_has_link();
}
inline void OpUpdatePropertyValue_V1::set_has_link() {
  _impl_._oneof_case_[0] = kLink;
}
inline ::Property::LinkPropertyAssignment* OpUpdatePropertyValue_V1::release_link() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.V1.link)
  if (_internal_has_link()) {
    clear_has_ValueType();
    ::Property::LinkPropertyAssignment* temp = _impl_.ValueType_.link_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ValueType_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::LinkPropertyAssignment& OpUpdatePropertyValue_V1::_internal_link() const {
  return _internal_has_link()
      ? *_impl_.ValueType_.link_
      : reinterpret_cast< ::Property::LinkPropertyAssignment&>(::Property::_LinkPropertyAssignment_default_instance_);
}
inline const ::Property::LinkPropertyAssignment& OpUpdatePropertyValue_V1::link() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.V1.link)
  return _internal_link();
}
inline ::Property::LinkPropertyAssignment* OpUpdatePropertyValue_V1::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.V1.link)
  if (_internal_has_link()) {
    clear_has_ValueType();
    ::Property::LinkPropertyAssignment* temp = _impl_.ValueType_.link_;
    _impl_.ValueType_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue_V1::unsafe_arena_set_allocated_link(::Property::LinkPropertyAssignment* link) {
  clear_ValueType();
  if (link) {
    set_has_link();
    _impl_.ValueType_.link_ = link;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.V1.link)
}
inline ::Property::LinkPropertyAssignment* OpUpdatePropertyValue_V1::_internal_mutable_link() {
  if (!_internal_has_link()) {
    clear_ValueType();
    set_has_link();
    _impl_.ValueType_.link_ = CreateMaybeMessage< ::Property::LinkPropertyAssignment >(GetArenaForAllocation());
  }
  return _impl_.ValueType_.link_;
}
inline ::Property::LinkPropertyAssignment* OpUpdatePropertyValue_V1::mutable_link() {
  ::Property::LinkPropertyAssignment* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.V1.link)
  return _msg;
}

inline bool OpUpdatePropertyValue_V1::has_ValueType() const {
  return ValueType_case() != VALUETYPE_NOT_SET;
}
inline void OpUpdatePropertyValue_V1::clear_has_ValueType() {
  _impl_._oneof_case_[0] = VALUETYPE_NOT_SET;
}
inline OpUpdatePropertyValue_V1::ValueTypeCase OpUpdatePropertyValue_V1::ValueType_case() const {
  return OpUpdatePropertyValue_V1::ValueTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpUpdatePropertyValue

// .Journal.OpUpdatePropertyValue.V1 v1 = 1;
inline bool OpUpdatePropertyValue::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpUpdatePropertyValue::has_v1() const {
  return _internal_has_v1();
}
inline void OpUpdatePropertyValue::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpUpdatePropertyValue::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpUpdatePropertyValue_V1* OpUpdatePropertyValue::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpUpdatePropertyValue.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpUpdatePropertyValue_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpUpdatePropertyValue_V1& OpUpdatePropertyValue::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpUpdatePropertyValue_V1&>(::Journal::_OpUpdatePropertyValue_V1_default_instance_);
}
inline const ::Journal::OpUpdatePropertyValue_V1& OpUpdatePropertyValue::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpUpdatePropertyValue.v1)
  return _internal_v1();
}
inline ::Journal::OpUpdatePropertyValue_V1* OpUpdatePropertyValue::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUpdatePropertyValue.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpUpdatePropertyValue_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUpdatePropertyValue::unsafe_arena_set_allocated_v1(::Journal::OpUpdatePropertyValue_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUpdatePropertyValue.v1)
}
inline ::Journal::OpUpdatePropertyValue_V1* OpUpdatePropertyValue::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpUpdatePropertyValue_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpUpdatePropertyValue_V1* OpUpdatePropertyValue::mutable_v1() {
  ::Journal::OpUpdatePropertyValue_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpUpdatePropertyValue.v1)
  return _msg;
}

inline bool OpUpdatePropertyValue::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpUpdatePropertyValue::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpUpdatePropertyValue::VCase OpUpdatePropertyValue::V_case() const {
  return OpUpdatePropertyValue::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpDeclareProperty_V1

// .Property.PropertyIdentifier propId = 1;
inline bool OpDeclareProperty_V1::_internal_has_propid() const {
  return this != internal_default_instance() && _impl_.propid_ != nullptr;
}
inline bool OpDeclareProperty_V1::has_propid() const {
  return _internal_has_propid();
}
inline const ::Property::PropertyIdentifier& OpDeclareProperty_V1::_internal_propid() const {
  const ::Property::PropertyIdentifier* p = _impl_.propid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& OpDeclareProperty_V1::propid() const {
  // @@protoc_insertion_point(field_get:Journal.OpDeclareProperty.V1.propId)
  return _internal_propid();
}
inline void OpDeclareProperty_V1::unsafe_arena_set_allocated_propid(
    ::Property::PropertyIdentifier* propid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propid_);
  }
  _impl_.propid_ = propid;
  if (propid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpDeclareProperty.V1.propId)
}
inline ::Property::PropertyIdentifier* OpDeclareProperty_V1::release_propid() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propid_;
  _impl_.propid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* OpDeclareProperty_V1::unsafe_arena_release_propid() {
  // @@protoc_insertion_point(field_release:Journal.OpDeclareProperty.V1.propId)
  
  ::Property::PropertyIdentifier* temp = _impl_.propid_;
  _impl_.propid_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* OpDeclareProperty_V1::_internal_mutable_propid() {
  
  if (_impl_.propid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propid_ = p;
  }
  return _impl_.propid_;
}
inline ::Property::PropertyIdentifier* OpDeclareProperty_V1::mutable_propid() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propid();
  // @@protoc_insertion_point(field_mutable:Journal.OpDeclareProperty.V1.propId)
  return _msg;
}
inline void OpDeclareProperty_V1::set_allocated_propid(::Property::PropertyIdentifier* propid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propid_);
  }
  if (propid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propid));
    if (message_arena != submessage_arena) {
      propid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propid_ = propid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpDeclareProperty.V1.propId)
}

// .Property.AnyPropertyDeclaration decl = 2;
inline bool OpDeclareProperty_V1::_internal_has_decl() const {
  return this != internal_default_instance() && _impl_.decl_ != nullptr;
}
inline bool OpDeclareProperty_V1::has_decl() const {
  return _internal_has_decl();
}
inline const ::Property::AnyPropertyDeclaration& OpDeclareProperty_V1::_internal_decl() const {
  const ::Property::AnyPropertyDeclaration* p = _impl_.decl_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::AnyPropertyDeclaration&>(
      ::Property::_AnyPropertyDeclaration_default_instance_);
}
inline const ::Property::AnyPropertyDeclaration& OpDeclareProperty_V1::decl() const {
  // @@protoc_insertion_point(field_get:Journal.OpDeclareProperty.V1.decl)
  return _internal_decl();
}
inline void OpDeclareProperty_V1::unsafe_arena_set_allocated_decl(
    ::Property::AnyPropertyDeclaration* decl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.decl_);
  }
  _impl_.decl_ = decl;
  if (decl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpDeclareProperty.V1.decl)
}
inline ::Property::AnyPropertyDeclaration* OpDeclareProperty_V1::release_decl() {
  
  ::Property::AnyPropertyDeclaration* temp = _impl_.decl_;
  _impl_.decl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::AnyPropertyDeclaration* OpDeclareProperty_V1::unsafe_arena_release_decl() {
  // @@protoc_insertion_point(field_release:Journal.OpDeclareProperty.V1.decl)
  
  ::Property::AnyPropertyDeclaration* temp = _impl_.decl_;
  _impl_.decl_ = nullptr;
  return temp;
}
inline ::Property::AnyPropertyDeclaration* OpDeclareProperty_V1::_internal_mutable_decl() {
  
  if (_impl_.decl_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::AnyPropertyDeclaration>(GetArenaForAllocation());
    _impl_.decl_ = p;
  }
  return _impl_.decl_;
}
inline ::Property::AnyPropertyDeclaration* OpDeclareProperty_V1::mutable_decl() {
  ::Property::AnyPropertyDeclaration* _msg = _internal_mutable_decl();
  // @@protoc_insertion_point(field_mutable:Journal.OpDeclareProperty.V1.decl)
  return _msg;
}
inline void OpDeclareProperty_V1::set_allocated_decl(::Property::AnyPropertyDeclaration* decl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.decl_);
  }
  if (decl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(decl));
    if (message_arena != submessage_arena) {
      decl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.decl_ = decl;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpDeclareProperty.V1.decl)
}

// -------------------------------------------------------------------

// OpDeclareProperty

// .Journal.OpDeclareProperty.V1 v1 = 1;
inline bool OpDeclareProperty::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpDeclareProperty::has_v1() const {
  return _internal_has_v1();
}
inline void OpDeclareProperty::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpDeclareProperty::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpDeclareProperty_V1* OpDeclareProperty::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpDeclareProperty.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpDeclareProperty_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpDeclareProperty_V1& OpDeclareProperty::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpDeclareProperty_V1&>(::Journal::_OpDeclareProperty_V1_default_instance_);
}
inline const ::Journal::OpDeclareProperty_V1& OpDeclareProperty::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpDeclareProperty.v1)
  return _internal_v1();
}
inline ::Journal::OpDeclareProperty_V1* OpDeclareProperty::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpDeclareProperty.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpDeclareProperty_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpDeclareProperty::unsafe_arena_set_allocated_v1(::Journal::OpDeclareProperty_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpDeclareProperty.v1)
}
inline ::Journal::OpDeclareProperty_V1* OpDeclareProperty::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpDeclareProperty_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpDeclareProperty_V1* OpDeclareProperty::mutable_v1() {
  ::Journal::OpDeclareProperty_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpDeclareProperty.v1)
  return _msg;
}

inline bool OpDeclareProperty::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpDeclareProperty::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpDeclareProperty::VCase OpDeclareProperty::V_case() const {
  return OpDeclareProperty::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpBlindDataOp

// string blindDataIdentifier = 1;
inline void OpBlindDataOp::clear_blinddataidentifier() {
  _impl_.blinddataidentifier_.ClearToEmpty();
}
inline const std::string& OpBlindDataOp::blinddataidentifier() const {
  // @@protoc_insertion_point(field_get:Journal.OpBlindDataOp.blindDataIdentifier)
  return _internal_blinddataidentifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpBlindDataOp::set_blinddataidentifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blinddataidentifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpBlindDataOp.blindDataIdentifier)
}
inline std::string* OpBlindDataOp::mutable_blinddataidentifier() {
  std::string* _s = _internal_mutable_blinddataidentifier();
  // @@protoc_insertion_point(field_mutable:Journal.OpBlindDataOp.blindDataIdentifier)
  return _s;
}
inline const std::string& OpBlindDataOp::_internal_blinddataidentifier() const {
  return _impl_.blinddataidentifier_.Get();
}
inline void OpBlindDataOp::_internal_set_blinddataidentifier(const std::string& value) {
  
  _impl_.blinddataidentifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OpBlindDataOp::_internal_mutable_blinddataidentifier() {
  
  return _impl_.blinddataidentifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OpBlindDataOp::release_blinddataidentifier() {
  // @@protoc_insertion_point(field_release:Journal.OpBlindDataOp.blindDataIdentifier)
  return _impl_.blinddataidentifier_.Release();
}
inline void OpBlindDataOp::set_allocated_blinddataidentifier(std::string* blinddataidentifier) {
  if (blinddataidentifier != nullptr) {
    
  } else {
    
  }
  _impl_.blinddataidentifier_.SetAllocated(blinddataidentifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blinddataidentifier_.IsDefault()) {
    _impl_.blinddataidentifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpBlindDataOp.blindDataIdentifier)
}

// bytes data = 2;
inline void OpBlindDataOp::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& OpBlindDataOp::data() const {
  // @@protoc_insertion_point(field_get:Journal.OpBlindDataOp.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpBlindDataOp::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpBlindDataOp.data)
}
inline std::string* OpBlindDataOp::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Journal.OpBlindDataOp.data)
  return _s;
}
inline const std::string& OpBlindDataOp::_internal_data() const {
  return _impl_.data_.Get();
}
inline void OpBlindDataOp::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* OpBlindDataOp::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* OpBlindDataOp::release_data() {
  // @@protoc_insertion_point(field_release:Journal.OpBlindDataOp.data)
  return _impl_.data_.Release();
}
inline void OpBlindDataOp::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpBlindDataOp.data)
}

// -------------------------------------------------------------------

// UserAuthorityPayload

// string message = 10;
inline bool UserAuthorityPayload::_internal_has_message() const {
  return FinalizationPayload_case() == kMessage;
}
inline bool UserAuthorityPayload::has_message() const {
  return _internal_has_message();
}
inline void UserAuthorityPayload::set_has_message() {
  _impl_._oneof_case_[0] = kMessage;
}
inline void UserAuthorityPayload::clear_message() {
  if (_internal_has_message()) {
    _impl_.FinalizationPayload_.message_.Destroy();
    clear_has_FinalizationPayload();
  }
}
inline const std::string& UserAuthorityPayload::message() const {
  // @@protoc_insertion_point(field_get:Journal.UserAuthorityPayload.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline void UserAuthorityPayload::set_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_message()) {
    clear_FinalizationPayload();
    set_has_message();
    _impl_.FinalizationPayload_.message_.InitDefault();
  }
  _impl_.FinalizationPayload_.message_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.UserAuthorityPayload.message)
}
inline std::string* UserAuthorityPayload::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Journal.UserAuthorityPayload.message)
  return _s;
}
inline const std::string& UserAuthorityPayload::_internal_message() const {
  if (_internal_has_message()) {
    return _impl_.FinalizationPayload_.message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserAuthorityPayload::_internal_set_message(const std::string& value) {
  if (!_internal_has_message()) {
    clear_FinalizationPayload();
    set_has_message();
    _impl_.FinalizationPayload_.message_.InitDefault();
  }
  _impl_.FinalizationPayload_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAuthorityPayload::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_FinalizationPayload();
    set_has_message();
    _impl_.FinalizationPayload_.message_.InitDefault();
  }
  return _impl_.FinalizationPayload_.message_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserAuthorityPayload::release_message() {
  // @@protoc_insertion_point(field_release:Journal.UserAuthorityPayload.message)
  if (_internal_has_message()) {
    clear_has_FinalizationPayload();
    return _impl_.FinalizationPayload_.message_.Release();
  } else {
    return nullptr;
  }
}
inline void UserAuthorityPayload::set_allocated_message(std::string* message) {
  if (has_FinalizationPayload()) {
    clear_FinalizationPayload();
  }
  if (message != nullptr) {
    set_has_message();
    _impl_.FinalizationPayload_.message_.InitAllocated(message, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Journal.UserAuthorityPayload.message)
}

// string json = 11;
inline bool UserAuthorityPayload::_internal_has_json() const {
  return FinalizationPayload_case() == kJson;
}
inline bool UserAuthorityPayload::has_json() const {
  return _internal_has_json();
}
inline void UserAuthorityPayload::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline void UserAuthorityPayload::clear_json() {
  if (_internal_has_json()) {
    _impl_.FinalizationPayload_.json_.Destroy();
    clear_has_FinalizationPayload();
  }
}
inline const std::string& UserAuthorityPayload::json() const {
  // @@protoc_insertion_point(field_get:Journal.UserAuthorityPayload.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline void UserAuthorityPayload::set_json(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_json()) {
    clear_FinalizationPayload();
    set_has_json();
    _impl_.FinalizationPayload_.json_.InitDefault();
  }
  _impl_.FinalizationPayload_.json_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.UserAuthorityPayload.json)
}
inline std::string* UserAuthorityPayload::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:Journal.UserAuthorityPayload.json)
  return _s;
}
inline const std::string& UserAuthorityPayload::_internal_json() const {
  if (_internal_has_json()) {
    return _impl_.FinalizationPayload_.json_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserAuthorityPayload::_internal_set_json(const std::string& value) {
  if (!_internal_has_json()) {
    clear_FinalizationPayload();
    set_has_json();
    _impl_.FinalizationPayload_.json_.InitDefault();
  }
  _impl_.FinalizationPayload_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAuthorityPayload::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_FinalizationPayload();
    set_has_json();
    _impl_.FinalizationPayload_.json_.InitDefault();
  }
  return _impl_.FinalizationPayload_.json_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserAuthorityPayload::release_json() {
  // @@protoc_insertion_point(field_release:Journal.UserAuthorityPayload.json)
  if (_internal_has_json()) {
    clear_has_FinalizationPayload();
    return _impl_.FinalizationPayload_.json_.Release();
  } else {
    return nullptr;
  }
}
inline void UserAuthorityPayload::set_allocated_json(std::string* json) {
  if (has_FinalizationPayload()) {
    clear_FinalizationPayload();
  }
  if (json != nullptr) {
    set_has_json();
    _impl_.FinalizationPayload_.json_.InitAllocated(json, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Journal.UserAuthorityPayload.json)
}

inline bool UserAuthorityPayload::has_FinalizationPayload() const {
  return FinalizationPayload_case() != FINALIZATIONPAYLOAD_NOT_SET;
}
inline void UserAuthorityPayload::clear_has_FinalizationPayload() {
  _impl_._oneof_case_[0] = FINALIZATIONPAYLOAD_NOT_SET;
}
inline UserAuthorityPayload::FinalizationPayloadCase UserAuthorityPayload::FinalizationPayload_case() const {
  return UserAuthorityPayload::FinalizationPayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpUserAuthorityData_V1

// string authorityRequestedKey = 1;
inline void OpUserAuthorityData_V1::clear_authorityrequestedkey() {
  _impl_.authorityrequestedkey_.ClearToEmpty();
}
inline const std::string& OpUserAuthorityData_V1::authorityrequestedkey() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.V1.authorityRequestedKey)
  return _internal_authorityrequestedkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpUserAuthorityData_V1::set_authorityrequestedkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorityrequestedkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpUserAuthorityData.V1.authorityRequestedKey)
}
inline std::string* OpUserAuthorityData_V1::mutable_authorityrequestedkey() {
  std::string* _s = _internal_mutable_authorityrequestedkey();
  // @@protoc_insertion_point(field_mutable:Journal.OpUserAuthorityData.V1.authorityRequestedKey)
  return _s;
}
inline const std::string& OpUserAuthorityData_V1::_internal_authorityrequestedkey() const {
  return _impl_.authorityrequestedkey_.Get();
}
inline void OpUserAuthorityData_V1::_internal_set_authorityrequestedkey(const std::string& value) {
  
  _impl_.authorityrequestedkey_.Set(value, GetArenaForAllocation());
}
inline std::string* OpUserAuthorityData_V1::_internal_mutable_authorityrequestedkey() {
  
  return _impl_.authorityrequestedkey_.Mutable(GetArenaForAllocation());
}
inline std::string* OpUserAuthorityData_V1::release_authorityrequestedkey() {
  // @@protoc_insertion_point(field_release:Journal.OpUserAuthorityData.V1.authorityRequestedKey)
  return _impl_.authorityrequestedkey_.Release();
}
inline void OpUserAuthorityData_V1::set_allocated_authorityrequestedkey(std::string* authorityrequestedkey) {
  if (authorityrequestedkey != nullptr) {
    
  } else {
    
  }
  _impl_.authorityrequestedkey_.SetAllocated(authorityrequestedkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorityrequestedkey_.IsDefault()) {
    _impl_.authorityrequestedkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpUserAuthorityData.V1.authorityRequestedKey)
}

// .Journal.OpUserAuthorityData.V1.AuthorityCoordinationEventEnum coordinationEventType = 2;
inline void OpUserAuthorityData_V1::clear_coordinationeventtype() {
  _impl_.coordinationeventtype_ = 0;
}
inline ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum OpUserAuthorityData_V1::_internal_coordinationeventtype() const {
  return static_cast< ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum >(_impl_.coordinationeventtype_);
}
inline ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum OpUserAuthorityData_V1::coordinationeventtype() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.V1.coordinationEventType)
  return _internal_coordinationeventtype();
}
inline void OpUserAuthorityData_V1::_internal_set_coordinationeventtype(::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum value) {
  
  _impl_.coordinationeventtype_ = value;
}
inline void OpUserAuthorityData_V1::set_coordinationeventtype(::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum value) {
  _internal_set_coordinationeventtype(value);
  // @@protoc_insertion_point(field_set:Journal.OpUserAuthorityData.V1.coordinationEventType)
}

// string requestorConnectionId = 3;
inline void OpUserAuthorityData_V1::clear_requestorconnectionid() {
  _impl_.requestorconnectionid_.ClearToEmpty();
}
inline const std::string& OpUserAuthorityData_V1::requestorconnectionid() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.V1.requestorConnectionId)
  return _internal_requestorconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpUserAuthorityData_V1::set_requestorconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requestorconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Journal.OpUserAuthorityData.V1.requestorConnectionId)
}
inline std::string* OpUserAuthorityData_V1::mutable_requestorconnectionid() {
  std::string* _s = _internal_mutable_requestorconnectionid();
  // @@protoc_insertion_point(field_mutable:Journal.OpUserAuthorityData.V1.requestorConnectionId)
  return _s;
}
inline const std::string& OpUserAuthorityData_V1::_internal_requestorconnectionid() const {
  return _impl_.requestorconnectionid_.Get();
}
inline void OpUserAuthorityData_V1::_internal_set_requestorconnectionid(const std::string& value) {
  
  _impl_.requestorconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* OpUserAuthorityData_V1::_internal_mutable_requestorconnectionid() {
  
  return _impl_.requestorconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* OpUserAuthorityData_V1::release_requestorconnectionid() {
  // @@protoc_insertion_point(field_release:Journal.OpUserAuthorityData.V1.requestorConnectionId)
  return _impl_.requestorconnectionid_.Release();
}
inline void OpUserAuthorityData_V1::set_allocated_requestorconnectionid(std::string* requestorconnectionid) {
  if (requestorconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.requestorconnectionid_.SetAllocated(requestorconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestorconnectionid_.IsDefault()) {
    _impl_.requestorconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Journal.OpUserAuthorityData.V1.requestorConnectionId)
}

// int32 ordinal = 5;
inline void OpUserAuthorityData_V1::clear_ordinal() {
  _impl_.ordinal_ = 0;
}
inline int32_t OpUserAuthorityData_V1::_internal_ordinal() const {
  return _impl_.ordinal_;
}
inline int32_t OpUserAuthorityData_V1::ordinal() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.V1.ordinal)
  return _internal_ordinal();
}
inline void OpUserAuthorityData_V1::_internal_set_ordinal(int32_t value) {
  
  _impl_.ordinal_ = value;
}
inline void OpUserAuthorityData_V1::set_ordinal(int32_t value) {
  _internal_set_ordinal(value);
  // @@protoc_insertion_point(field_set:Journal.OpUserAuthorityData.V1.ordinal)
}

// .Journal.UserAuthorityPayload payload = 4;
inline bool OpUserAuthorityData_V1::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool OpUserAuthorityData_V1::has_payload() const {
  return _internal_has_payload();
}
inline void OpUserAuthorityData_V1::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::Journal::UserAuthorityPayload& OpUserAuthorityData_V1::_internal_payload() const {
  const ::Journal::UserAuthorityPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::Journal::UserAuthorityPayload&>(
      ::Journal::_UserAuthorityPayload_default_instance_);
}
inline const ::Journal::UserAuthorityPayload& OpUserAuthorityData_V1::payload() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.V1.payload)
  return _internal_payload();
}
inline void OpUserAuthorityData_V1::unsafe_arena_set_allocated_payload(
    ::Journal::UserAuthorityPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUserAuthorityData.V1.payload)
}
inline ::Journal::UserAuthorityPayload* OpUserAuthorityData_V1::release_payload() {
  
  ::Journal::UserAuthorityPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Journal::UserAuthorityPayload* OpUserAuthorityData_V1::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:Journal.OpUserAuthorityData.V1.payload)
  
  ::Journal::UserAuthorityPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::Journal::UserAuthorityPayload* OpUserAuthorityData_V1::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::Journal::UserAuthorityPayload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::Journal::UserAuthorityPayload* OpUserAuthorityData_V1::mutable_payload() {
  ::Journal::UserAuthorityPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:Journal.OpUserAuthorityData.V1.payload)
  return _msg;
}
inline void OpUserAuthorityData_V1::set_allocated_payload(::Journal::UserAuthorityPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpUserAuthorityData.V1.payload)
}

// -------------------------------------------------------------------

// OpUserAuthorityData

// .Journal.OpUserAuthorityData.V1 v1 = 1;
inline bool OpUserAuthorityData::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpUserAuthorityData::has_v1() const {
  return _internal_has_v1();
}
inline void OpUserAuthorityData::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpUserAuthorityData::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpUserAuthorityData_V1* OpUserAuthorityData::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpUserAuthorityData.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpUserAuthorityData_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpUserAuthorityData_V1& OpUserAuthorityData::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpUserAuthorityData_V1&>(::Journal::_OpUserAuthorityData_V1_default_instance_);
}
inline const ::Journal::OpUserAuthorityData_V1& OpUserAuthorityData::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpUserAuthorityData.v1)
  return _internal_v1();
}
inline ::Journal::OpUserAuthorityData_V1* OpUserAuthorityData::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpUserAuthorityData.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpUserAuthorityData_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpUserAuthorityData::unsafe_arena_set_allocated_v1(::Journal::OpUserAuthorityData_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpUserAuthorityData.v1)
}
inline ::Journal::OpUserAuthorityData_V1* OpUserAuthorityData::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpUserAuthorityData_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpUserAuthorityData_V1* OpUserAuthorityData::mutable_v1() {
  ::Journal::OpUserAuthorityData_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpUserAuthorityData.v1)
  return _msg;
}

inline bool OpUserAuthorityData::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpUserAuthorityData::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpUserAuthorityData::VCase OpUserAuthorityData::V_case() const {
  return OpUserAuthorityData::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpSetPartHighlight_V1

// .JournalData.ObjectId objectId = 1;
inline bool OpSetPartHighlight_V1::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool OpSetPartHighlight_V1::has_objectid() const {
  return _internal_has_objectid();
}
inline const ::JournalData::ObjectId& OpSetPartHighlight_V1::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& OpSetPartHighlight_V1::objectid() const {
  // @@protoc_insertion_point(field_get:Journal.OpSetPartHighlight.V1.objectId)
  return _internal_objectid();
}
inline void OpSetPartHighlight_V1::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpSetPartHighlight.V1.objectId)
}
inline ::JournalData::ObjectId* OpSetPartHighlight_V1::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* OpSetPartHighlight_V1::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:Journal.OpSetPartHighlight.V1.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* OpSetPartHighlight_V1::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* OpSetPartHighlight_V1::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:Journal.OpSetPartHighlight.V1.objectId)
  return _msg;
}
inline void OpSetPartHighlight_V1::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectid));
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpSetPartHighlight.V1.objectId)
}

// bool set = 2;
inline void OpSetPartHighlight_V1::clear_set() {
  _impl_.set_ = false;
}
inline bool OpSetPartHighlight_V1::_internal_set() const {
  return _impl_.set_;
}
inline bool OpSetPartHighlight_V1::set() const {
  // @@protoc_insertion_point(field_get:Journal.OpSetPartHighlight.V1.set)
  return _internal_set();
}
inline void OpSetPartHighlight_V1::_internal_set_set(bool value) {
  
  _impl_.set_ = value;
}
inline void OpSetPartHighlight_V1::set_set(bool value) {
  _internal_set_set(value);
  // @@protoc_insertion_point(field_set:Journal.OpSetPartHighlight.V1.set)
}

// .JournalData.PartHighlightData highlightData = 10;
inline bool OpSetPartHighlight_V1::_internal_has_highlightdata() const {
  return this != internal_default_instance() && _impl_.highlightdata_ != nullptr;
}
inline bool OpSetPartHighlight_V1::has_highlightdata() const {
  return _internal_has_highlightdata();
}
inline const ::JournalData::PartHighlightData& OpSetPartHighlight_V1::_internal_highlightdata() const {
  const ::JournalData::PartHighlightData* p = _impl_.highlightdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::PartHighlightData&>(
      ::JournalData::_PartHighlightData_default_instance_);
}
inline const ::JournalData::PartHighlightData& OpSetPartHighlight_V1::highlightdata() const {
  // @@protoc_insertion_point(field_get:Journal.OpSetPartHighlight.V1.highlightData)
  return _internal_highlightdata();
}
inline void OpSetPartHighlight_V1::unsafe_arena_set_allocated_highlightdata(
    ::JournalData::PartHighlightData* highlightdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.highlightdata_);
  }
  _impl_.highlightdata_ = highlightdata;
  if (highlightdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpSetPartHighlight.V1.highlightData)
}
inline ::JournalData::PartHighlightData* OpSetPartHighlight_V1::release_highlightdata() {
  
  ::JournalData::PartHighlightData* temp = _impl_.highlightdata_;
  _impl_.highlightdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::PartHighlightData* OpSetPartHighlight_V1::unsafe_arena_release_highlightdata() {
  // @@protoc_insertion_point(field_release:Journal.OpSetPartHighlight.V1.highlightData)
  
  ::JournalData::PartHighlightData* temp = _impl_.highlightdata_;
  _impl_.highlightdata_ = nullptr;
  return temp;
}
inline ::JournalData::PartHighlightData* OpSetPartHighlight_V1::_internal_mutable_highlightdata() {
  
  if (_impl_.highlightdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::PartHighlightData>(GetArenaForAllocation());
    _impl_.highlightdata_ = p;
  }
  return _impl_.highlightdata_;
}
inline ::JournalData::PartHighlightData* OpSetPartHighlight_V1::mutable_highlightdata() {
  ::JournalData::PartHighlightData* _msg = _internal_mutable_highlightdata();
  // @@protoc_insertion_point(field_mutable:Journal.OpSetPartHighlight.V1.highlightData)
  return _msg;
}
inline void OpSetPartHighlight_V1::set_allocated_highlightdata(::JournalData::PartHighlightData* highlightdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.highlightdata_);
  }
  if (highlightdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(highlightdata));
    if (message_arena != submessage_arena) {
      highlightdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, highlightdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.highlightdata_ = highlightdata;
  // @@protoc_insertion_point(field_set_allocated:Journal.OpSetPartHighlight.V1.highlightData)
}

// -------------------------------------------------------------------

// OpSetPartHighlight

// .Journal.OpSetPartHighlight.V1 v1 = 1;
inline bool OpSetPartHighlight::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool OpSetPartHighlight::has_v1() const {
  return _internal_has_v1();
}
inline void OpSetPartHighlight::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void OpSetPartHighlight::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Journal::OpSetPartHighlight_V1* OpSetPartHighlight::release_v1() {
  // @@protoc_insertion_point(field_release:Journal.OpSetPartHighlight.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpSetPartHighlight_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpSetPartHighlight_V1& OpSetPartHighlight::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Journal::OpSetPartHighlight_V1&>(::Journal::_OpSetPartHighlight_V1_default_instance_);
}
inline const ::Journal::OpSetPartHighlight_V1& OpSetPartHighlight::v1() const {
  // @@protoc_insertion_point(field_get:Journal.OpSetPartHighlight.v1)
  return _internal_v1();
}
inline ::Journal::OpSetPartHighlight_V1* OpSetPartHighlight::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Journal.OpSetPartHighlight.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Journal::OpSetPartHighlight_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpSetPartHighlight::unsafe_arena_set_allocated_v1(::Journal::OpSetPartHighlight_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Journal.OpSetPartHighlight.v1)
}
inline ::Journal::OpSetPartHighlight_V1* OpSetPartHighlight::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Journal::OpSetPartHighlight_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Journal::OpSetPartHighlight_V1* OpSetPartHighlight::mutable_v1() {
  ::Journal::OpSetPartHighlight_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Journal.OpSetPartHighlight.v1)
  return _msg;
}

inline bool OpSetPartHighlight::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void OpSetPartHighlight::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline OpSetPartHighlight::VCase OpSetPartHighlight::V_case() const {
  return OpSetPartHighlight::VCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Journal

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Journal::OpRemoveOps_V1_UndoRedoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Journal::OpRemoveOps_V1_UndoRedoType>() {
  return ::Journal::OpRemoveOps_V1_UndoRedoType_descriptor();
}
template <> struct is_proto_enum< ::Journal::OpRemoveOps_V2_UndoRedoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Journal::OpRemoveOps_V2_UndoRedoType>() {
  return ::Journal::OpRemoveOps_V2_UndoRedoType_descriptor();
}
template <> struct is_proto_enum< ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum>() {
  return ::Journal::OpUserAuthorityData_V1_AuthorityCoordinationEventEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_journal_5foperations_5fcommon_2eproto

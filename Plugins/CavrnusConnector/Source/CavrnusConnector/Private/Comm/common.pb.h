// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace Common {
class AxisAlignedBoundingBox;
struct AxisAlignedBoundingBoxDefaultTypeInternal;
extern AxisAlignedBoundingBoxDefaultTypeInternal _AxisAlignedBoundingBox_default_instance_;
class Color4;
struct Color4DefaultTypeInternal;
extern Color4DefaultTypeInternal _Color4_default_instance_;
class Float2;
struct Float2DefaultTypeInternal;
extern Float2DefaultTypeInternal _Float2_default_instance_;
class Float2Array;
struct Float2ArrayDefaultTypeInternal;
extern Float2ArrayDefaultTypeInternal _Float2Array_default_instance_;
class Float3;
struct Float3DefaultTypeInternal;
extern Float3DefaultTypeInternal _Float3_default_instance_;
class Float3Array;
struct Float3ArrayDefaultTypeInternal;
extern Float3ArrayDefaultTypeInternal _Float3Array_default_instance_;
class Float4;
struct Float4DefaultTypeInternal;
extern Float4DefaultTypeInternal _Float4_default_instance_;
class Float4Array;
struct Float4ArrayDefaultTypeInternal;
extern Float4ArrayDefaultTypeInternal _Float4Array_default_instance_;
class GenericMessage;
struct GenericMessageDefaultTypeInternal;
extern GenericMessageDefaultTypeInternal _GenericMessage_default_instance_;
class GenericMessage_V1;
struct GenericMessage_V1DefaultTypeInternal;
extern GenericMessage_V1DefaultTypeInternal _GenericMessage_V1_default_instance_;
class IntSpan;
struct IntSpanDefaultTypeInternal;
extern IntSpanDefaultTypeInternal _IntSpan_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Ping_V1;
struct Ping_V1DefaultTypeInternal;
extern Ping_V1DefaultTypeInternal _Ping_V1_default_instance_;
}  // namespace Common
PROTOBUF_NAMESPACE_OPEN
template<> ::Common::AxisAlignedBoundingBox* Arena::CreateMaybeMessage<::Common::AxisAlignedBoundingBox>(Arena*);
template<> ::Common::Color4* Arena::CreateMaybeMessage<::Common::Color4>(Arena*);
template<> ::Common::Float2* Arena::CreateMaybeMessage<::Common::Float2>(Arena*);
template<> ::Common::Float2Array* Arena::CreateMaybeMessage<::Common::Float2Array>(Arena*);
template<> ::Common::Float3* Arena::CreateMaybeMessage<::Common::Float3>(Arena*);
template<> ::Common::Float3Array* Arena::CreateMaybeMessage<::Common::Float3Array>(Arena*);
template<> ::Common::Float4* Arena::CreateMaybeMessage<::Common::Float4>(Arena*);
template<> ::Common::Float4Array* Arena::CreateMaybeMessage<::Common::Float4Array>(Arena*);
template<> ::Common::GenericMessage* Arena::CreateMaybeMessage<::Common::GenericMessage>(Arena*);
template<> ::Common::GenericMessage_V1* Arena::CreateMaybeMessage<::Common::GenericMessage_V1>(Arena*);
template<> ::Common::IntSpan* Arena::CreateMaybeMessage<::Common::IntSpan>(Arena*);
template<> ::Common::Ping* Arena::CreateMaybeMessage<::Common::Ping>(Arena*);
template<> ::Common::Ping_V1* Arena::CreateMaybeMessage<::Common::Ping_V1>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Common {

enum GenericMessage_V1_Category : int {
  GenericMessage_V1_Category_Log = 0,
  GenericMessage_V1_Category_UserMessage = 1,
  GenericMessage_V1_Category_CriticalServerMessage = 2,
  GenericMessage_V1_Category_ProgramError = 3,
  GenericMessage_V1_Category_GenericMessage_V1_Category_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GenericMessage_V1_Category_GenericMessage_V1_Category_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GenericMessage_V1_Category_IsValid(int value);
constexpr GenericMessage_V1_Category GenericMessage_V1_Category_Category_MIN = GenericMessage_V1_Category_Log;
constexpr GenericMessage_V1_Category GenericMessage_V1_Category_Category_MAX = GenericMessage_V1_Category_ProgramError;
constexpr int GenericMessage_V1_Category_Category_ARRAYSIZE = GenericMessage_V1_Category_Category_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GenericMessage_V1_Category_descriptor();
template<typename T>
inline const std::string& GenericMessage_V1_Category_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GenericMessage_V1_Category>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GenericMessage_V1_Category_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GenericMessage_V1_Category_descriptor(), enum_t_value);
}
inline bool GenericMessage_V1_Category_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GenericMessage_V1_Category* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GenericMessage_V1_Category>(
    GenericMessage_V1_Category_descriptor(), name, value);
}
enum ComparisonMethod : int {
  Equal = 0,
  NotEqual = 1,
  Less = 10,
  LessOrEqual = 11,
  GreaterOrEqual = 20,
  Greater = 21,
  ComparisonMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ComparisonMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ComparisonMethod_IsValid(int value);
constexpr ComparisonMethod ComparisonMethod_MIN = Equal;
constexpr ComparisonMethod ComparisonMethod_MAX = Greater;
constexpr int ComparisonMethod_ARRAYSIZE = ComparisonMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComparisonMethod_descriptor();
template<typename T>
inline const std::string& ComparisonMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComparisonMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComparisonMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComparisonMethod_descriptor(), enum_t_value);
}
inline bool ComparisonMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ComparisonMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComparisonMethod>(
    ComparisonMethod_descriptor(), name, value);
}
// ===================================================================

class Float2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float2) */ {
 public:
  inline Float2() : Float2(nullptr) {}
  ~Float2() override;
  explicit PROTOBUF_CONSTEXPR Float2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float2(const Float2& from);
  Float2(Float2&& from) noexcept
    : Float2() {
    *this = ::std::move(from);
  }

  inline Float2& operator=(const Float2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float2& operator=(Float2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float2* internal_default_instance() {
    return reinterpret_cast<const Float2*>(
               &_Float2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Float2& a, Float2& b) {
    a.Swap(&b);
  }
  inline void Swap(Float2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float2& from) {
    Float2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float2";
  }
  protected:
  explicit Float2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Float2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Float2Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float2Array) */ {
 public:
  inline Float2Array() : Float2Array(nullptr) {}
  ~Float2Array() override;
  explicit PROTOBUF_CONSTEXPR Float2Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float2Array(const Float2Array& from);
  Float2Array(Float2Array&& from) noexcept
    : Float2Array() {
    *this = ::std::move(from);
  }

  inline Float2Array& operator=(const Float2Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float2Array& operator=(Float2Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float2Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float2Array* internal_default_instance() {
    return reinterpret_cast<const Float2Array*>(
               &_Float2Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Float2Array& a, Float2Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Float2Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float2Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float2Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float2Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float2Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float2Array& from) {
    Float2Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float2Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float2Array";
  }
  protected:
  explicit Float2Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF2ArrayFieldNumber = 1,
  };
  // bytes f2array = 1;
  void clear_f2array();
  const std::string& f2array() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f2array(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f2array();
  PROTOBUF_NODISCARD std::string* release_f2array();
  void set_allocated_f2array(std::string* f2array);
  private:
  const std::string& _internal_f2array() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f2array(const std::string& value);
  std::string* _internal_mutable_f2array();
  public:

  // @@protoc_insertion_point(class_scope:Common.Float2Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f2array_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Float3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float3) */ {
 public:
  inline Float3() : Float3(nullptr) {}
  ~Float3() override;
  explicit PROTOBUF_CONSTEXPR Float3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float3(const Float3& from);
  Float3(Float3&& from) noexcept
    : Float3() {
    *this = ::std::move(from);
  }

  inline Float3& operator=(const Float3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float3& operator=(Float3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float3* internal_default_instance() {
    return reinterpret_cast<const Float3*>(
               &_Float3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Float3& a, Float3& b) {
    a.Swap(&b);
  }
  inline void Swap(Float3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float3& from) {
    Float3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float3";
  }
  protected:
  explicit Float3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Float3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Float3Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float3Array) */ {
 public:
  inline Float3Array() : Float3Array(nullptr) {}
  ~Float3Array() override;
  explicit PROTOBUF_CONSTEXPR Float3Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float3Array(const Float3Array& from);
  Float3Array(Float3Array&& from) noexcept
    : Float3Array() {
    *this = ::std::move(from);
  }

  inline Float3Array& operator=(const Float3Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float3Array& operator=(Float3Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float3Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float3Array* internal_default_instance() {
    return reinterpret_cast<const Float3Array*>(
               &_Float3Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Float3Array& a, Float3Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Float3Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float3Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float3Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float3Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float3Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float3Array& from) {
    Float3Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float3Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float3Array";
  }
  protected:
  explicit Float3Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF3ArrayFieldNumber = 1,
  };
  // bytes f3array = 1;
  void clear_f3array();
  const std::string& f3array() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f3array(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f3array();
  PROTOBUF_NODISCARD std::string* release_f3array();
  void set_allocated_f3array(std::string* f3array);
  private:
  const std::string& _internal_f3array() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f3array(const std::string& value);
  std::string* _internal_mutable_f3array();
  public:

  // @@protoc_insertion_point(class_scope:Common.Float3Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f3array_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Float4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float4) */ {
 public:
  inline Float4() : Float4(nullptr) {}
  ~Float4() override;
  explicit PROTOBUF_CONSTEXPR Float4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float4(const Float4& from);
  Float4(Float4&& from) noexcept
    : Float4() {
    *this = ::std::move(from);
  }

  inline Float4& operator=(const Float4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float4& operator=(Float4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float4* internal_default_instance() {
    return reinterpret_cast<const Float4*>(
               &_Float4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Float4& a, Float4& b) {
    a.Swap(&b);
  }
  inline void Swap(Float4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float4& from) {
    Float4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float4* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float4";
  }
  protected:
  explicit Float4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // optional float w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Float4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    float w_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Float4Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Float4Array) */ {
 public:
  inline Float4Array() : Float4Array(nullptr) {}
  ~Float4Array() override;
  explicit PROTOBUF_CONSTEXPR Float4Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Float4Array(const Float4Array& from);
  Float4Array(Float4Array&& from) noexcept
    : Float4Array() {
    *this = ::std::move(from);
  }

  inline Float4Array& operator=(const Float4Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float4Array& operator=(Float4Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Float4Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Float4Array* internal_default_instance() {
    return reinterpret_cast<const Float4Array*>(
               &_Float4Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Float4Array& a, Float4Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Float4Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float4Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Float4Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Float4Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Float4Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Float4Array& from) {
    Float4Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float4Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Float4Array";
  }
  protected:
  explicit Float4Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF4ArrayFieldNumber = 1,
  };
  // bytes f4array = 1;
  void clear_f4array();
  const std::string& f4array() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f4array(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f4array();
  PROTOBUF_NODISCARD std::string* release_f4array();
  void set_allocated_f4array(std::string* f4array);
  private:
  const std::string& _internal_f4array() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f4array(const std::string& value);
  std::string* _internal_mutable_f4array();
  public:

  // @@protoc_insertion_point(class_scope:Common.Float4Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f4array_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class AxisAlignedBoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.AxisAlignedBoundingBox) */ {
 public:
  inline AxisAlignedBoundingBox() : AxisAlignedBoundingBox(nullptr) {}
  ~AxisAlignedBoundingBox() override;
  explicit PROTOBUF_CONSTEXPR AxisAlignedBoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AxisAlignedBoundingBox(const AxisAlignedBoundingBox& from);
  AxisAlignedBoundingBox(AxisAlignedBoundingBox&& from) noexcept
    : AxisAlignedBoundingBox() {
    *this = ::std::move(from);
  }

  inline AxisAlignedBoundingBox& operator=(const AxisAlignedBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline AxisAlignedBoundingBox& operator=(AxisAlignedBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AxisAlignedBoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const AxisAlignedBoundingBox* internal_default_instance() {
    return reinterpret_cast<const AxisAlignedBoundingBox*>(
               &_AxisAlignedBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AxisAlignedBoundingBox& a, AxisAlignedBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(AxisAlignedBoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AxisAlignedBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AxisAlignedBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AxisAlignedBoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AxisAlignedBoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AxisAlignedBoundingBox& from) {
    AxisAlignedBoundingBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AxisAlignedBoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.AxisAlignedBoundingBox";
  }
  protected:
  explicit AxisAlignedBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // .Common.Float3 min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::Common::Float3& min() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_min();
  ::Common::Float3* mutable_min();
  void set_allocated_min(::Common::Float3* min);
  private:
  const ::Common::Float3& _internal_min() const;
  ::Common::Float3* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::Common::Float3* min);
  ::Common::Float3* unsafe_arena_release_min();

  // .Common.Float3 max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::Common::Float3& max() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_max();
  ::Common::Float3* mutable_max();
  void set_allocated_max(::Common::Float3* max);
  private:
  const ::Common::Float3& _internal_max() const;
  ::Common::Float3* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::Common::Float3* max);
  ::Common::Float3* unsafe_arena_release_max();

  // @@protoc_insertion_point(class_scope:Common.AxisAlignedBoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float3* min_;
    ::Common::Float3* max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Color4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Color4) */ {
 public:
  inline Color4() : Color4(nullptr) {}
  ~Color4() override;
  explicit PROTOBUF_CONSTEXPR Color4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color4(const Color4& from);
  Color4(Color4&& from) noexcept
    : Color4() {
    *this = ::std::move(from);
  }

  inline Color4& operator=(const Color4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color4& operator=(Color4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color4* internal_default_instance() {
    return reinterpret_cast<const Color4*>(
               &_Color4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Color4& a, Color4& b) {
    a.Swap(&b);
  }
  inline void Swap(Color4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Color4& from) {
    Color4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color4* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Color4";
  }
  protected:
  explicit Color4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // float r = 1;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float g = 2;
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // float b = 3;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Color4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float r_;
    float g_;
    float b_;
    float a_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class IntSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.IntSpan) */ {
 public:
  inline IntSpan() : IntSpan(nullptr) {}
  ~IntSpan() override;
  explicit PROTOBUF_CONSTEXPR IntSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntSpan(const IntSpan& from);
  IntSpan(IntSpan&& from) noexcept
    : IntSpan() {
    *this = ::std::move(from);
  }

  inline IntSpan& operator=(const IntSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntSpan& operator=(IntSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntSpan* internal_default_instance() {
    return reinterpret_cast<const IntSpan*>(
               &_IntSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntSpan& a, IntSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(IntSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntSpan& from) {
    IntSpan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.IntSpan";
  }
  protected:
  explicit IntSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // int32 from = 1;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // int32 to = 2;
  void clear_to();
  int32_t to() const;
  void set_to(int32_t value);
  private:
  int32_t _internal_to() const;
  void _internal_set_to(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.IntSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t from_;
    int32_t to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class GenericMessage_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.GenericMessage.V1) */ {
 public:
  inline GenericMessage_V1() : GenericMessage_V1(nullptr) {}
  ~GenericMessage_V1() override;
  explicit PROTOBUF_CONSTEXPR GenericMessage_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericMessage_V1(const GenericMessage_V1& from);
  GenericMessage_V1(GenericMessage_V1&& from) noexcept
    : GenericMessage_V1() {
    *this = ::std::move(from);
  }

  inline GenericMessage_V1& operator=(const GenericMessage_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericMessage_V1& operator=(GenericMessage_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericMessage_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericMessage_V1* internal_default_instance() {
    return reinterpret_cast<const GenericMessage_V1*>(
               &_GenericMessage_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GenericMessage_V1& a, GenericMessage_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericMessage_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericMessage_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericMessage_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericMessage_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericMessage_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericMessage_V1& from) {
    GenericMessage_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericMessage_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.GenericMessage.V1";
  }
  protected:
  explicit GenericMessage_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GenericMessage_V1_Category Category;
  static constexpr Category Log =
    GenericMessage_V1_Category_Log;
  static constexpr Category UserMessage =
    GenericMessage_V1_Category_UserMessage;
  static constexpr Category CriticalServerMessage =
    GenericMessage_V1_Category_CriticalServerMessage;
  static constexpr Category ProgramError =
    GenericMessage_V1_Category_ProgramError;
  static inline bool Category_IsValid(int value) {
    return GenericMessage_V1_Category_IsValid(value);
  }
  static constexpr Category Category_MIN =
    GenericMessage_V1_Category_Category_MIN;
  static constexpr Category Category_MAX =
    GenericMessage_V1_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE =
    GenericMessage_V1_Category_Category_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Category_descriptor() {
    return GenericMessage_V1_Category_descriptor();
  }
  template<typename T>
  static inline const std::string& Category_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Category>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Category_Name.");
    return GenericMessage_V1_Category_Name(enum_t_value);
  }
  static inline bool Category_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Category* value) {
    return GenericMessage_V1_Category_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCategoryFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .Common.GenericMessage.V1.Category category = 1;
  void clear_category();
  ::Common::GenericMessage_V1_Category category() const;
  void set_category(::Common::GenericMessage_V1_Category value);
  private:
  ::Common::GenericMessage_V1_Category _internal_category() const;
  void _internal_set_category(::Common::GenericMessage_V1_Category value);
  public:

  // @@protoc_insertion_point(class_scope:Common.GenericMessage.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int category_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class GenericMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.GenericMessage) */ {
 public:
  inline GenericMessage() : GenericMessage(nullptr) {}
  ~GenericMessage() override;
  explicit PROTOBUF_CONSTEXPR GenericMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericMessage(const GenericMessage& from);
  GenericMessage(GenericMessage&& from) noexcept
    : GenericMessage() {
    *this = ::std::move(from);
  }

  inline GenericMessage& operator=(const GenericMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericMessage& operator=(GenericMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericMessage& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const GenericMessage* internal_default_instance() {
    return reinterpret_cast<const GenericMessage*>(
               &_GenericMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GenericMessage& a, GenericMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericMessage& from) {
    GenericMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.GenericMessage";
  }
  protected:
  explicit GenericMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GenericMessage_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Common.GenericMessage.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Common::GenericMessage_V1& v1() const;
  PROTOBUF_NODISCARD ::Common::GenericMessage_V1* release_v1();
  ::Common::GenericMessage_V1* mutable_v1();
  void set_allocated_v1(::Common::GenericMessage_V1* v1);
  private:
  const ::Common::GenericMessage_V1& _internal_v1() const;
  ::Common::GenericMessage_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Common::GenericMessage_V1* v1);
  ::Common::GenericMessage_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Common.GenericMessage)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Common::GenericMessage_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Ping_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Ping.V1) */ {
 public:
  inline Ping_V1() : Ping_V1(nullptr) {}
  ~Ping_V1() override;
  explicit PROTOBUF_CONSTEXPR Ping_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping_V1(const Ping_V1& from);
  Ping_V1(Ping_V1&& from) noexcept
    : Ping_V1() {
    *this = ::std::move(from);
  }

  inline Ping_V1& operator=(const Ping_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping_V1& operator=(Ping_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping_V1* internal_default_instance() {
    return reinterpret_cast<const Ping_V1*>(
               &_Ping_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Ping_V1& a, Ping_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping_V1& from) {
    Ping_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Ping.V1";
  }
  protected:
  explicit Ping_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSentTimeFieldNumber = 1,
  };
  // .google.protobuf.Timestamp sentTime = 1;
  bool has_senttime() const;
  private:
  bool _internal_has_senttime() const;
  public:
  void clear_senttime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& senttime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_senttime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_senttime();
  void set_allocated_senttime(::PROTOBUF_NAMESPACE_ID::Timestamp* senttime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_senttime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_senttime();
  public:
  void unsafe_arena_set_allocated_senttime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* senttime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_senttime();

  // @@protoc_insertion_point(class_scope:Common.Ping.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* senttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Ping_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Common.Ping.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Common::Ping_V1& v1() const;
  PROTOBUF_NODISCARD ::Common::Ping_V1* release_v1();
  ::Common::Ping_V1* mutable_v1();
  void set_allocated_v1(::Common::Ping_V1* v1);
  private:
  const ::Common::Ping_V1& _internal_v1() const;
  ::Common::Ping_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Common::Ping_V1* v1);
  ::Common::Ping_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Common.Ping)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Common::Ping_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Float2

// float x = 1;
inline void Float2::clear_x() {
  _impl_.x_ = 0;
}
inline float Float2::_internal_x() const {
  return _impl_.x_;
}
inline float Float2::x() const {
  // @@protoc_insertion_point(field_get:Common.Float2.x)
  return _internal_x();
}
inline void Float2::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Float2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Common.Float2.x)
}

// float y = 2;
inline void Float2::clear_y() {
  _impl_.y_ = 0;
}
inline float Float2::_internal_y() const {
  return _impl_.y_;
}
inline float Float2::y() const {
  // @@protoc_insertion_point(field_get:Common.Float2.y)
  return _internal_y();
}
inline void Float2::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Float2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Common.Float2.y)
}

// -------------------------------------------------------------------

// Float2Array

// bytes f2array = 1;
inline void Float2Array::clear_f2array() {
  _impl_.f2array_.ClearToEmpty();
}
inline const std::string& Float2Array::f2array() const {
  // @@protoc_insertion_point(field_get:Common.Float2Array.f2array)
  return _internal_f2array();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Float2Array::set_f2array(ArgT0&& arg0, ArgT... args) {
 
 _impl_.f2array_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Float2Array.f2array)
}
inline std::string* Float2Array::mutable_f2array() {
  std::string* _s = _internal_mutable_f2array();
  // @@protoc_insertion_point(field_mutable:Common.Float2Array.f2array)
  return _s;
}
inline const std::string& Float2Array::_internal_f2array() const {
  return _impl_.f2array_.Get();
}
inline void Float2Array::_internal_set_f2array(const std::string& value) {
  
  _impl_.f2array_.Set(value, GetArenaForAllocation());
}
inline std::string* Float2Array::_internal_mutable_f2array() {
  
  return _impl_.f2array_.Mutable(GetArenaForAllocation());
}
inline std::string* Float2Array::release_f2array() {
  // @@protoc_insertion_point(field_release:Common.Float2Array.f2array)
  return _impl_.f2array_.Release();
}
inline void Float2Array::set_allocated_f2array(std::string* f2array) {
  if (f2array != nullptr) {
    
  } else {
    
  }
  _impl_.f2array_.SetAllocated(f2array, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.f2array_.IsDefault()) {
    _impl_.f2array_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Float2Array.f2array)
}

// -------------------------------------------------------------------

// Float3

// float x = 1;
inline void Float3::clear_x() {
  _impl_.x_ = 0;
}
inline float Float3::_internal_x() const {
  return _impl_.x_;
}
inline float Float3::x() const {
  // @@protoc_insertion_point(field_get:Common.Float3.x)
  return _internal_x();
}
inline void Float3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Float3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Common.Float3.x)
}

// float y = 2;
inline void Float3::clear_y() {
  _impl_.y_ = 0;
}
inline float Float3::_internal_y() const {
  return _impl_.y_;
}
inline float Float3::y() const {
  // @@protoc_insertion_point(field_get:Common.Float3.y)
  return _internal_y();
}
inline void Float3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Float3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Common.Float3.y)
}

// float z = 3;
inline void Float3::clear_z() {
  _impl_.z_ = 0;
}
inline float Float3::_internal_z() const {
  return _impl_.z_;
}
inline float Float3::z() const {
  // @@protoc_insertion_point(field_get:Common.Float3.z)
  return _internal_z();
}
inline void Float3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Float3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Common.Float3.z)
}

// -------------------------------------------------------------------

// Float3Array

// bytes f3array = 1;
inline void Float3Array::clear_f3array() {
  _impl_.f3array_.ClearToEmpty();
}
inline const std::string& Float3Array::f3array() const {
  // @@protoc_insertion_point(field_get:Common.Float3Array.f3array)
  return _internal_f3array();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Float3Array::set_f3array(ArgT0&& arg0, ArgT... args) {
 
 _impl_.f3array_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Float3Array.f3array)
}
inline std::string* Float3Array::mutable_f3array() {
  std::string* _s = _internal_mutable_f3array();
  // @@protoc_insertion_point(field_mutable:Common.Float3Array.f3array)
  return _s;
}
inline const std::string& Float3Array::_internal_f3array() const {
  return _impl_.f3array_.Get();
}
inline void Float3Array::_internal_set_f3array(const std::string& value) {
  
  _impl_.f3array_.Set(value, GetArenaForAllocation());
}
inline std::string* Float3Array::_internal_mutable_f3array() {
  
  return _impl_.f3array_.Mutable(GetArenaForAllocation());
}
inline std::string* Float3Array::release_f3array() {
  // @@protoc_insertion_point(field_release:Common.Float3Array.f3array)
  return _impl_.f3array_.Release();
}
inline void Float3Array::set_allocated_f3array(std::string* f3array) {
  if (f3array != nullptr) {
    
  } else {
    
  }
  _impl_.f3array_.SetAllocated(f3array, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.f3array_.IsDefault()) {
    _impl_.f3array_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Float3Array.f3array)
}

// -------------------------------------------------------------------

// Float4

// float x = 1;
inline void Float4::clear_x() {
  _impl_.x_ = 0;
}
inline float Float4::_internal_x() const {
  return _impl_.x_;
}
inline float Float4::x() const {
  // @@protoc_insertion_point(field_get:Common.Float4.x)
  return _internal_x();
}
inline void Float4::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Float4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Common.Float4.x)
}

// float y = 2;
inline void Float4::clear_y() {
  _impl_.y_ = 0;
}
inline float Float4::_internal_y() const {
  return _impl_.y_;
}
inline float Float4::y() const {
  // @@protoc_insertion_point(field_get:Common.Float4.y)
  return _internal_y();
}
inline void Float4::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Float4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Common.Float4.y)
}

// float z = 3;
inline void Float4::clear_z() {
  _impl_.z_ = 0;
}
inline float Float4::_internal_z() const {
  return _impl_.z_;
}
inline float Float4::z() const {
  // @@protoc_insertion_point(field_get:Common.Float4.z)
  return _internal_z();
}
inline void Float4::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Float4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Common.Float4.z)
}

// optional float w = 4;
inline bool Float4::_internal_has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Float4::has_w() const {
  return _internal_has_w();
}
inline void Float4::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Float4::_internal_w() const {
  return _impl_.w_;
}
inline float Float4::w() const {
  // @@protoc_insertion_point(field_get:Common.Float4.w)
  return _internal_w();
}
inline void Float4::_internal_set_w(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.w_ = value;
}
inline void Float4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:Common.Float4.w)
}

// -------------------------------------------------------------------

// Float4Array

// bytes f4array = 1;
inline void Float4Array::clear_f4array() {
  _impl_.f4array_.ClearToEmpty();
}
inline const std::string& Float4Array::f4array() const {
  // @@protoc_insertion_point(field_get:Common.Float4Array.f4array)
  return _internal_f4array();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Float4Array::set_f4array(ArgT0&& arg0, ArgT... args) {
 
 _impl_.f4array_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Float4Array.f4array)
}
inline std::string* Float4Array::mutable_f4array() {
  std::string* _s = _internal_mutable_f4array();
  // @@protoc_insertion_point(field_mutable:Common.Float4Array.f4array)
  return _s;
}
inline const std::string& Float4Array::_internal_f4array() const {
  return _impl_.f4array_.Get();
}
inline void Float4Array::_internal_set_f4array(const std::string& value) {
  
  _impl_.f4array_.Set(value, GetArenaForAllocation());
}
inline std::string* Float4Array::_internal_mutable_f4array() {
  
  return _impl_.f4array_.Mutable(GetArenaForAllocation());
}
inline std::string* Float4Array::release_f4array() {
  // @@protoc_insertion_point(field_release:Common.Float4Array.f4array)
  return _impl_.f4array_.Release();
}
inline void Float4Array::set_allocated_f4array(std::string* f4array) {
  if (f4array != nullptr) {
    
  } else {
    
  }
  _impl_.f4array_.SetAllocated(f4array, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.f4array_.IsDefault()) {
    _impl_.f4array_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Float4Array.f4array)
}

// -------------------------------------------------------------------

// AxisAlignedBoundingBox

// .Common.Float3 min = 1;
inline bool AxisAlignedBoundingBox::_internal_has_min() const {
  return this != internal_default_instance() && _impl_.min_ != nullptr;
}
inline bool AxisAlignedBoundingBox::has_min() const {
  return _internal_has_min();
}
inline void AxisAlignedBoundingBox::clear_min() {
  if (GetArenaForAllocation() == nullptr && _impl_.min_ != nullptr) {
    delete _impl_.min_;
  }
  _impl_.min_ = nullptr;
}
inline const ::Common::Float3& AxisAlignedBoundingBox::_internal_min() const {
  const ::Common::Float3* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& AxisAlignedBoundingBox::min() const {
  // @@protoc_insertion_point(field_get:Common.AxisAlignedBoundingBox.min)
  return _internal_min();
}
inline void AxisAlignedBoundingBox::unsafe_arena_set_allocated_min(
    ::Common::Float3* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.AxisAlignedBoundingBox.min)
}
inline ::Common::Float3* AxisAlignedBoundingBox::release_min() {
  
  ::Common::Float3* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* AxisAlignedBoundingBox::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:Common.AxisAlignedBoundingBox.min)
  
  ::Common::Float3* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::Common::Float3* AxisAlignedBoundingBox::_internal_mutable_min() {
  
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::Common::Float3* AxisAlignedBoundingBox::mutable_min() {
  ::Common::Float3* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:Common.AxisAlignedBoundingBox.min)
  return _msg;
}
inline void AxisAlignedBoundingBox::set_allocated_min(::Common::Float3* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.min_;
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(min);
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:Common.AxisAlignedBoundingBox.min)
}

// .Common.Float3 max = 2;
inline bool AxisAlignedBoundingBox::_internal_has_max() const {
  return this != internal_default_instance() && _impl_.max_ != nullptr;
}
inline bool AxisAlignedBoundingBox::has_max() const {
  return _internal_has_max();
}
inline void AxisAlignedBoundingBox::clear_max() {
  if (GetArenaForAllocation() == nullptr && _impl_.max_ != nullptr) {
    delete _impl_.max_;
  }
  _impl_.max_ = nullptr;
}
inline const ::Common::Float3& AxisAlignedBoundingBox::_internal_max() const {
  const ::Common::Float3* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& AxisAlignedBoundingBox::max() const {
  // @@protoc_insertion_point(field_get:Common.AxisAlignedBoundingBox.max)
  return _internal_max();
}
inline void AxisAlignedBoundingBox::unsafe_arena_set_allocated_max(
    ::Common::Float3* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.AxisAlignedBoundingBox.max)
}
inline ::Common::Float3* AxisAlignedBoundingBox::release_max() {
  
  ::Common::Float3* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* AxisAlignedBoundingBox::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:Common.AxisAlignedBoundingBox.max)
  
  ::Common::Float3* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::Common::Float3* AxisAlignedBoundingBox::_internal_mutable_max() {
  
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::Common::Float3* AxisAlignedBoundingBox::mutable_max() {
  ::Common::Float3* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:Common.AxisAlignedBoundingBox.max)
  return _msg;
}
inline void AxisAlignedBoundingBox::set_allocated_max(::Common::Float3* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.max_;
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(max);
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:Common.AxisAlignedBoundingBox.max)
}

// -------------------------------------------------------------------

// Color4

// float r = 1;
inline void Color4::clear_r() {
  _impl_.r_ = 0;
}
inline float Color4::_internal_r() const {
  return _impl_.r_;
}
inline float Color4::r() const {
  // @@protoc_insertion_point(field_get:Common.Color4.r)
  return _internal_r();
}
inline void Color4::_internal_set_r(float value) {
  
  _impl_.r_ = value;
}
inline void Color4::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Common.Color4.r)
}

// float g = 2;
inline void Color4::clear_g() {
  _impl_.g_ = 0;
}
inline float Color4::_internal_g() const {
  return _impl_.g_;
}
inline float Color4::g() const {
  // @@protoc_insertion_point(field_get:Common.Color4.g)
  return _internal_g();
}
inline void Color4::_internal_set_g(float value) {
  
  _impl_.g_ = value;
}
inline void Color4::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:Common.Color4.g)
}

// float b = 3;
inline void Color4::clear_b() {
  _impl_.b_ = 0;
}
inline float Color4::_internal_b() const {
  return _impl_.b_;
}
inline float Color4::b() const {
  // @@protoc_insertion_point(field_get:Common.Color4.b)
  return _internal_b();
}
inline void Color4::_internal_set_b(float value) {
  
  _impl_.b_ = value;
}
inline void Color4::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Common.Color4.b)
}

// float a = 4;
inline void Color4::clear_a() {
  _impl_.a_ = 0;
}
inline float Color4::_internal_a() const {
  return _impl_.a_;
}
inline float Color4::a() const {
  // @@protoc_insertion_point(field_get:Common.Color4.a)
  return _internal_a();
}
inline void Color4::_internal_set_a(float value) {
  
  _impl_.a_ = value;
}
inline void Color4::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:Common.Color4.a)
}

// -------------------------------------------------------------------

// IntSpan

// int32 from = 1;
inline void IntSpan::clear_from() {
  _impl_.from_ = 0;
}
inline int32_t IntSpan::_internal_from() const {
  return _impl_.from_;
}
inline int32_t IntSpan::from() const {
  // @@protoc_insertion_point(field_get:Common.IntSpan.from)
  return _internal_from();
}
inline void IntSpan::_internal_set_from(int32_t value) {
  
  _impl_.from_ = value;
}
inline void IntSpan::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:Common.IntSpan.from)
}

// int32 to = 2;
inline void IntSpan::clear_to() {
  _impl_.to_ = 0;
}
inline int32_t IntSpan::_internal_to() const {
  return _impl_.to_;
}
inline int32_t IntSpan::to() const {
  // @@protoc_insertion_point(field_get:Common.IntSpan.to)
  return _internal_to();
}
inline void IntSpan::_internal_set_to(int32_t value) {
  
  _impl_.to_ = value;
}
inline void IntSpan::set_to(int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:Common.IntSpan.to)
}

// -------------------------------------------------------------------

// GenericMessage_V1

// .Common.GenericMessage.V1.Category category = 1;
inline void GenericMessage_V1::clear_category() {
  _impl_.category_ = 0;
}
inline ::Common::GenericMessage_V1_Category GenericMessage_V1::_internal_category() const {
  return static_cast< ::Common::GenericMessage_V1_Category >(_impl_.category_);
}
inline ::Common::GenericMessage_V1_Category GenericMessage_V1::category() const {
  // @@protoc_insertion_point(field_get:Common.GenericMessage.V1.category)
  return _internal_category();
}
inline void GenericMessage_V1::_internal_set_category(::Common::GenericMessage_V1_Category value) {
  
  _impl_.category_ = value;
}
inline void GenericMessage_V1::set_category(::Common::GenericMessage_V1_Category value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:Common.GenericMessage.V1.category)
}

// string message = 2;
inline void GenericMessage_V1::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GenericMessage_V1::message() const {
  // @@protoc_insertion_point(field_get:Common.GenericMessage.V1.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericMessage_V1::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.GenericMessage.V1.message)
}
inline std::string* GenericMessage_V1::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Common.GenericMessage.V1.message)
  return _s;
}
inline const std::string& GenericMessage_V1::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GenericMessage_V1::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericMessage_V1::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericMessage_V1::release_message() {
  // @@protoc_insertion_point(field_release:Common.GenericMessage.V1.message)
  return _impl_.message_.Release();
}
inline void GenericMessage_V1::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.GenericMessage.V1.message)
}

// -------------------------------------------------------------------

// GenericMessage

// .Common.GenericMessage.V1 v1 = 1;
inline bool GenericMessage::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool GenericMessage::has_v1() const {
  return _internal_has_v1();
}
inline void GenericMessage::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void GenericMessage::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Common::GenericMessage_V1* GenericMessage::release_v1() {
  // @@protoc_insertion_point(field_release:Common.GenericMessage.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Common::GenericMessage_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::GenericMessage_V1& GenericMessage::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Common::GenericMessage_V1&>(::Common::_GenericMessage_V1_default_instance_);
}
inline const ::Common::GenericMessage_V1& GenericMessage::v1() const {
  // @@protoc_insertion_point(field_get:Common.GenericMessage.v1)
  return _internal_v1();
}
inline ::Common::GenericMessage_V1* GenericMessage::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common.GenericMessage.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Common::GenericMessage_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericMessage::unsafe_arena_set_allocated_v1(::Common::GenericMessage_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.GenericMessage.v1)
}
inline ::Common::GenericMessage_V1* GenericMessage::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Common::GenericMessage_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Common::GenericMessage_V1* GenericMessage::mutable_v1() {
  ::Common::GenericMessage_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Common.GenericMessage.v1)
  return _msg;
}

inline bool GenericMessage::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void GenericMessage::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline GenericMessage::VCase GenericMessage::V_case() const {
  return GenericMessage::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ping_V1

// .google.protobuf.Timestamp sentTime = 1;
inline bool Ping_V1::_internal_has_senttime() const {
  return this != internal_default_instance() && _impl_.senttime_ != nullptr;
}
inline bool Ping_V1::has_senttime() const {
  return _internal_has_senttime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Ping_V1::_internal_senttime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.senttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Ping_V1::senttime() const {
  // @@protoc_insertion_point(field_get:Common.Ping.V1.sentTime)
  return _internal_senttime();
}
inline void Ping_V1::unsafe_arena_set_allocated_senttime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* senttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.senttime_);
  }
  _impl_.senttime_ = senttime;
  if (senttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Ping.V1.sentTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ping_V1::release_senttime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.senttime_;
  _impl_.senttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ping_V1::unsafe_arena_release_senttime() {
  // @@protoc_insertion_point(field_release:Common.Ping.V1.sentTime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.senttime_;
  _impl_.senttime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ping_V1::_internal_mutable_senttime() {
  
  if (_impl_.senttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.senttime_ = p;
  }
  return _impl_.senttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ping_V1::mutable_senttime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_senttime();
  // @@protoc_insertion_point(field_mutable:Common.Ping.V1.sentTime)
  return _msg;
}
inline void Ping_V1::set_allocated_senttime(::PROTOBUF_NAMESPACE_ID::Timestamp* senttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.senttime_);
  }
  if (senttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(senttime));
    if (message_arena != submessage_arena) {
      senttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, senttime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.senttime_ = senttime;
  // @@protoc_insertion_point(field_set_allocated:Common.Ping.V1.sentTime)
}

// -------------------------------------------------------------------

// Ping

// .Common.Ping.V1 v1 = 1;
inline bool Ping::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool Ping::has_v1() const {
  return _internal_has_v1();
}
inline void Ping::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void Ping::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Common::Ping_V1* Ping::release_v1() {
  // @@protoc_insertion_point(field_release:Common.Ping.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Common::Ping_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::Ping_V1& Ping::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Common::Ping_V1&>(::Common::_Ping_V1_default_instance_);
}
inline const ::Common::Ping_V1& Ping::v1() const {
  // @@protoc_insertion_point(field_get:Common.Ping.v1)
  return _internal_v1();
}
inline ::Common::Ping_V1* Ping::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common.Ping.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Common::Ping_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Ping::unsafe_arena_set_allocated_v1(::Common::Ping_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Ping.v1)
}
inline ::Common::Ping_V1* Ping::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Common::Ping_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Common::Ping_V1* Ping::mutable_v1() {
  ::Common::Ping_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Common.Ping.v1)
  return _msg;
}

inline bool Ping::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void Ping::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline Ping::VCase Ping::V_case() const {
  return Ping::VCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Common

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Common::GenericMessage_V1_Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::GenericMessage_V1_Category>() {
  return ::Common::GenericMessage_V1_Category_descriptor();
}
template <> struct is_proto_enum< ::Common::ComparisonMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ComparisonMethod>() {
  return ::Common::ComparisonMethod_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto

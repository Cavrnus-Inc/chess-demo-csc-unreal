// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: relay.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_relay_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_relay_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "relay_types.pb.h"
#include "properties.pb.h"
#include "common.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_relay_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_relay_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_relay_2eproto;
namespace ServerData {
class AllJoinableSpacesReq;
struct AllJoinableSpacesReqDefaultTypeInternal;
extern AllJoinableSpacesReqDefaultTypeInternal _AllJoinableSpacesReq_default_instance_;
class AllJoinableSpacesResp;
struct AllJoinableSpacesRespDefaultTypeInternal;
extern AllJoinableSpacesRespDefaultTypeInternal _AllJoinableSpacesResp_default_instance_;
class AuthenticateGuestReq;
struct AuthenticateGuestReqDefaultTypeInternal;
extern AuthenticateGuestReqDefaultTypeInternal _AuthenticateGuestReq_default_instance_;
class AuthenticateGuestResp;
struct AuthenticateGuestRespDefaultTypeInternal;
extern AuthenticateGuestRespDefaultTypeInternal _AuthenticateGuestResp_default_instance_;
class AuthenticateReq;
struct AuthenticateReqDefaultTypeInternal;
extern AuthenticateReqDefaultTypeInternal _AuthenticateReq_default_instance_;
class AuthenticateResp;
struct AuthenticateRespDefaultTypeInternal;
extern AuthenticateRespDefaultTypeInternal _AuthenticateResp_default_instance_;
class AuthenticateWithLinkReq;
struct AuthenticateWithLinkReqDefaultTypeInternal;
extern AuthenticateWithLinkReqDefaultTypeInternal _AuthenticateWithLinkReq_default_instance_;
class AuthenticateWithLinkResp;
struct AuthenticateWithLinkRespDefaultTypeInternal;
extern AuthenticateWithLinkRespDefaultTypeInternal _AuthenticateWithLinkResp_default_instance_;
class BeginTransientPropertyUpdate;
struct BeginTransientPropertyUpdateDefaultTypeInternal;
extern BeginTransientPropertyUpdateDefaultTypeInternal _BeginTransientPropertyUpdate_default_instance_;
class CancelTransientPropertyUpdate;
struct CancelTransientPropertyUpdateDefaultTypeInternal;
extern CancelTransientPropertyUpdateDefaultTypeInternal _CancelTransientPropertyUpdate_default_instance_;
class ChatAdded;
struct ChatAddedDefaultTypeInternal;
extern ChatAddedDefaultTypeInternal _ChatAdded_default_instance_;
class ChatBase;
struct ChatBaseDefaultTypeInternal;
extern ChatBaseDefaultTypeInternal _ChatBase_default_instance_;
class ChatRemoved;
struct ChatRemovedDefaultTypeInternal;
extern ChatRemovedDefaultTypeInternal _ChatRemoved_default_instance_;
class ChatUpdated;
struct ChatUpdatedDefaultTypeInternal;
extern ChatUpdatedDefaultTypeInternal _ChatUpdated_default_instance_;
class ContinueTransientPropertyUpdate;
struct ContinueTransientPropertyUpdateDefaultTypeInternal;
extern ContinueTransientPropertyUpdateDefaultTypeInternal _ContinueTransientPropertyUpdate_default_instance_;
class CreateSpaceReq;
struct CreateSpaceReqDefaultTypeInternal;
extern CreateSpaceReqDefaultTypeInternal _CreateSpaceReq_default_instance_;
class CreateSpaceResp;
struct CreateSpaceRespDefaultTypeInternal;
extern CreateSpaceRespDefaultTypeInternal _CreateSpaceResp_default_instance_;
class DefinePropertyDefaultValue;
struct DefinePropertyDefaultValueDefaultTypeInternal;
extern DefinePropertyDefaultValueDefaultTypeInternal _DefinePropertyDefaultValue_default_instance_;
class ExitAllSpacesAndLogoutReq;
struct ExitAllSpacesAndLogoutReqDefaultTypeInternal;
extern ExitAllSpacesAndLogoutReqDefaultTypeInternal _ExitAllSpacesAndLogoutReq_default_instance_;
class ExitAllSpacesAndLogoutResp;
struct ExitAllSpacesAndLogoutRespDefaultTypeInternal;
extern ExitAllSpacesAndLogoutRespDefaultTypeInternal _ExitAllSpacesAndLogoutResp_default_instance_;
class FetchAllUploadedContentReq;
struct FetchAllUploadedContentReqDefaultTypeInternal;
extern FetchAllUploadedContentReqDefaultTypeInternal _FetchAllUploadedContentReq_default_instance_;
class FetchAllUploadedContentResp;
struct FetchAllUploadedContentRespDefaultTypeInternal;
extern FetchAllUploadedContentRespDefaultTypeInternal _FetchAllUploadedContentResp_default_instance_;
class FetchFileByIdCompletedResp;
struct FetchFileByIdCompletedRespDefaultTypeInternal;
extern FetchFileByIdCompletedRespDefaultTypeInternal _FetchFileByIdCompletedResp_default_instance_;
class FetchFileByIdProgressResp;
struct FetchFileByIdProgressRespDefaultTypeInternal;
extern FetchFileByIdProgressRespDefaultTypeInternal _FetchFileByIdProgressResp_default_instance_;
class FetchFileByIdReq;
struct FetchFileByIdReqDefaultTypeInternal;
extern FetchFileByIdReqDefaultTypeInternal _FetchFileByIdReq_default_instance_;
class FinalizeTransientPropertyUpdate;
struct FinalizeTransientPropertyUpdateDefaultTypeInternal;
extern FinalizeTransientPropertyUpdateDefaultTypeInternal _FinalizeTransientPropertyUpdate_default_instance_;
class GetAudioInputDevicesReq;
struct GetAudioInputDevicesReqDefaultTypeInternal;
extern GetAudioInputDevicesReqDefaultTypeInternal _GetAudioInputDevicesReq_default_instance_;
class GetAudioInputDevicesResp;
struct GetAudioInputDevicesRespDefaultTypeInternal;
extern GetAudioInputDevicesRespDefaultTypeInternal _GetAudioInputDevicesResp_default_instance_;
class GetAudioOutputDevicesReq;
struct GetAudioOutputDevicesReqDefaultTypeInternal;
extern GetAudioOutputDevicesReqDefaultTypeInternal _GetAudioOutputDevicesReq_default_instance_;
class GetAudioOutputDevicesResp;
struct GetAudioOutputDevicesRespDefaultTypeInternal;
extern GetAudioOutputDevicesRespDefaultTypeInternal _GetAudioOutputDevicesResp_default_instance_;
class GetVideoInputDevicesReq;
struct GetVideoInputDevicesReqDefaultTypeInternal;
extern GetVideoInputDevicesReqDefaultTypeInternal _GetVideoInputDevicesReq_default_instance_;
class GetVideoInputDevicesResp;
struct GetVideoInputDevicesRespDefaultTypeInternal;
extern GetVideoInputDevicesRespDefaultTypeInternal _GetVideoInputDevicesResp_default_instance_;
class JoinSpaceFromIdReq;
struct JoinSpaceFromIdReqDefaultTypeInternal;
extern JoinSpaceFromIdReqDefaultTypeInternal _JoinSpaceFromIdReq_default_instance_;
class JoinSpaceFromIdResp;
struct JoinSpaceFromIdRespDefaultTypeInternal;
extern JoinSpaceFromIdRespDefaultTypeInternal _JoinSpaceFromIdResp_default_instance_;
class KeepAlive;
struct KeepAliveDefaultTypeInternal;
extern KeepAliveDefaultTypeInternal _KeepAlive_default_instance_;
class LocalPropertyHandledResp;
struct LocalPropertyHandledRespDefaultTypeInternal;
extern LocalPropertyHandledRespDefaultTypeInternal _LocalPropertyHandledResp_default_instance_;
class ObjectAdded;
struct ObjectAddedDefaultTypeInternal;
extern ObjectAddedDefaultTypeInternal _ObjectAdded_default_instance_;
class ObjectRemoved;
struct ObjectRemovedDefaultTypeInternal;
extern ObjectRemovedDefaultTypeInternal _ObjectRemoved_default_instance_;
class PermissionStatus;
struct PermissionStatusDefaultTypeInternal;
extern PermissionStatusDefaultTypeInternal _PermissionStatus_default_instance_;
class PermissionStatusReq;
struct PermissionStatusReqDefaultTypeInternal;
extern PermissionStatusReqDefaultTypeInternal _PermissionStatusReq_default_instance_;
class PostChat;
struct PostChatDefaultTypeInternal;
extern PostChatDefaultTypeInternal _PostChat_default_instance_;
class PostCreateObject;
struct PostCreateObjectDefaultTypeInternal;
extern PostCreateObjectDefaultTypeInternal _PostCreateObject_default_instance_;
class PostPropertyUpdate;
struct PostPropertyUpdateDefaultTypeInternal;
extern PostPropertyUpdateDefaultTypeInternal _PostPropertyUpdate_default_instance_;
class PostRemoveObject;
struct PostRemoveObjectDefaultTypeInternal;
extern PostRemoveObjectDefaultTypeInternal _PostRemoveObject_default_instance_;
class PropMetadataStatus;
struct PropMetadataStatusDefaultTypeInternal;
extern PropMetadataStatusDefaultTypeInternal _PropMetadataStatus_default_instance_;
class PropertyValue;
struct PropertyValueDefaultTypeInternal;
extern PropertyValueDefaultTypeInternal _PropertyValue_default_instance_;
class PropertyValueStatus;
struct PropertyValueStatusDefaultTypeInternal;
extern PropertyValueStatusDefaultTypeInternal _PropertyValueStatus_default_instance_;
class RelayClientMessage;
struct RelayClientMessageDefaultTypeInternal;
extern RelayClientMessageDefaultTypeInternal _RelayClientMessage_default_instance_;
class RelayClientMessageBatch;
struct RelayClientMessageBatchDefaultTypeInternal;
extern RelayClientMessageBatchDefaultTypeInternal _RelayClientMessageBatch_default_instance_;
class RelayRemoteMessage;
struct RelayRemoteMessageDefaultTypeInternal;
extern RelayRemoteMessageDefaultTypeInternal _RelayRemoteMessage_default_instance_;
class RelayRemoteMessageBatch;
struct RelayRemoteMessageBatchDefaultTypeInternal;
extern RelayRemoteMessageBatchDefaultTypeInternal _RelayRemoteMessageBatch_default_instance_;
class SetAudioInputDeviceReq;
struct SetAudioInputDeviceReqDefaultTypeInternal;
extern SetAudioInputDeviceReqDefaultTypeInternal _SetAudioInputDeviceReq_default_instance_;
class SetAudioOutputDeviceReq;
struct SetAudioOutputDeviceReqDefaultTypeInternal;
extern SetAudioOutputDeviceReqDefaultTypeInternal _SetAudioOutputDeviceReq_default_instance_;
class SetVideoInputDeviceReq;
struct SetVideoInputDeviceReqDefaultTypeInternal;
extern SetVideoInputDeviceReqDefaultTypeInternal _SetVideoInputDeviceReq_default_instance_;
class ShutdownSpaceConnectionReq;
struct ShutdownSpaceConnectionReqDefaultTypeInternal;
extern ShutdownSpaceConnectionReqDefaultTypeInternal _ShutdownSpaceConnectionReq_default_instance_;
class ShutdownSpaceConnectionResp;
struct ShutdownSpaceConnectionRespDefaultTypeInternal;
extern ShutdownSpaceConnectionRespDefaultTypeInternal _ShutdownSpaceConnectionResp_default_instance_;
class SpaceInfo;
struct SpaceInfoDefaultTypeInternal;
extern SpaceInfoDefaultTypeInternal _SpaceInfo_default_instance_;
class StatusMessage;
struct StatusMessageDefaultTypeInternal;
extern StatusMessageDefaultTypeInternal _StatusMessage_default_instance_;
class TransformPropertyValue;
struct TransformPropertyValueDefaultTypeInternal;
extern TransformPropertyValueDefaultTypeInternal _TransformPropertyValue_default_instance_;
class UpdateLocalUserCoPresence;
struct UpdateLocalUserCoPresenceDefaultTypeInternal;
extern UpdateLocalUserCoPresenceDefaultTypeInternal _UpdateLocalUserCoPresence_default_instance_;
class UpdateLocalUserMuted;
struct UpdateLocalUserMutedDefaultTypeInternal;
extern UpdateLocalUserMutedDefaultTypeInternal _UpdateLocalUserMuted_default_instance_;
class UpdateLocalUserStreamState;
struct UpdateLocalUserStreamStateDefaultTypeInternal;
extern UpdateLocalUserStreamStateDefaultTypeInternal _UpdateLocalUserStreamState_default_instance_;
class UpdateTime;
struct UpdateTimeDefaultTypeInternal;
extern UpdateTimeDefaultTypeInternal _UpdateTime_default_instance_;
class UploadLocalFileReq;
struct UploadLocalFileReqDefaultTypeInternal;
extern UploadLocalFileReqDefaultTypeInternal _UploadLocalFileReq_default_instance_;
class UploadLocalFileResp;
struct UploadLocalFileRespDefaultTypeInternal;
extern UploadLocalFileRespDefaultTypeInternal _UploadLocalFileResp_default_instance_;
class UserAdded;
struct UserAddedDefaultTypeInternal;
extern UserAddedDefaultTypeInternal _UserAdded_default_instance_;
class UserRemoved;
struct UserRemovedDefaultTypeInternal;
extern UserRemovedDefaultTypeInternal _UserRemoved_default_instance_;
class UserVideoFrame;
struct UserVideoFrameDefaultTypeInternal;
extern UserVideoFrameDefaultTypeInternal _UserVideoFrame_default_instance_;
}  // namespace ServerData
PROTOBUF_NAMESPACE_OPEN
template<> ::ServerData::AllJoinableSpacesReq* Arena::CreateMaybeMessage<::ServerData::AllJoinableSpacesReq>(Arena*);
template<> ::ServerData::AllJoinableSpacesResp* Arena::CreateMaybeMessage<::ServerData::AllJoinableSpacesResp>(Arena*);
template<> ::ServerData::AuthenticateGuestReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateGuestReq>(Arena*);
template<> ::ServerData::AuthenticateGuestResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateGuestResp>(Arena*);
template<> ::ServerData::AuthenticateReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateReq>(Arena*);
template<> ::ServerData::AuthenticateResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateResp>(Arena*);
template<> ::ServerData::AuthenticateWithLinkReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateWithLinkReq>(Arena*);
template<> ::ServerData::AuthenticateWithLinkResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateWithLinkResp>(Arena*);
template<> ::ServerData::BeginTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::BeginTransientPropertyUpdate>(Arena*);
template<> ::ServerData::CancelTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::CancelTransientPropertyUpdate>(Arena*);
template<> ::ServerData::ChatAdded* Arena::CreateMaybeMessage<::ServerData::ChatAdded>(Arena*);
template<> ::ServerData::ChatBase* Arena::CreateMaybeMessage<::ServerData::ChatBase>(Arena*);
template<> ::ServerData::ChatRemoved* Arena::CreateMaybeMessage<::ServerData::ChatRemoved>(Arena*);
template<> ::ServerData::ChatUpdated* Arena::CreateMaybeMessage<::ServerData::ChatUpdated>(Arena*);
template<> ::ServerData::ContinueTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::ContinueTransientPropertyUpdate>(Arena*);
template<> ::ServerData::CreateSpaceReq* Arena::CreateMaybeMessage<::ServerData::CreateSpaceReq>(Arena*);
template<> ::ServerData::CreateSpaceResp* Arena::CreateMaybeMessage<::ServerData::CreateSpaceResp>(Arena*);
template<> ::ServerData::DefinePropertyDefaultValue* Arena::CreateMaybeMessage<::ServerData::DefinePropertyDefaultValue>(Arena*);
template<> ::ServerData::ExitAllSpacesAndLogoutReq* Arena::CreateMaybeMessage<::ServerData::ExitAllSpacesAndLogoutReq>(Arena*);
template<> ::ServerData::ExitAllSpacesAndLogoutResp* Arena::CreateMaybeMessage<::ServerData::ExitAllSpacesAndLogoutResp>(Arena*);
template<> ::ServerData::FetchAllUploadedContentReq* Arena::CreateMaybeMessage<::ServerData::FetchAllUploadedContentReq>(Arena*);
template<> ::ServerData::FetchAllUploadedContentResp* Arena::CreateMaybeMessage<::ServerData::FetchAllUploadedContentResp>(Arena*);
template<> ::ServerData::FetchFileByIdCompletedResp* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdCompletedResp>(Arena*);
template<> ::ServerData::FetchFileByIdProgressResp* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdProgressResp>(Arena*);
template<> ::ServerData::FetchFileByIdReq* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdReq>(Arena*);
template<> ::ServerData::FinalizeTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::FinalizeTransientPropertyUpdate>(Arena*);
template<> ::ServerData::GetAudioInputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetAudioInputDevicesReq>(Arena*);
template<> ::ServerData::GetAudioInputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetAudioInputDevicesResp>(Arena*);
template<> ::ServerData::GetAudioOutputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetAudioOutputDevicesReq>(Arena*);
template<> ::ServerData::GetAudioOutputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetAudioOutputDevicesResp>(Arena*);
template<> ::ServerData::GetVideoInputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetVideoInputDevicesReq>(Arena*);
template<> ::ServerData::GetVideoInputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetVideoInputDevicesResp>(Arena*);
template<> ::ServerData::JoinSpaceFromIdReq* Arena::CreateMaybeMessage<::ServerData::JoinSpaceFromIdReq>(Arena*);
template<> ::ServerData::JoinSpaceFromIdResp* Arena::CreateMaybeMessage<::ServerData::JoinSpaceFromIdResp>(Arena*);
template<> ::ServerData::KeepAlive* Arena::CreateMaybeMessage<::ServerData::KeepAlive>(Arena*);
template<> ::ServerData::LocalPropertyHandledResp* Arena::CreateMaybeMessage<::ServerData::LocalPropertyHandledResp>(Arena*);
template<> ::ServerData::ObjectAdded* Arena::CreateMaybeMessage<::ServerData::ObjectAdded>(Arena*);
template<> ::ServerData::ObjectRemoved* Arena::CreateMaybeMessage<::ServerData::ObjectRemoved>(Arena*);
template<> ::ServerData::PermissionStatus* Arena::CreateMaybeMessage<::ServerData::PermissionStatus>(Arena*);
template<> ::ServerData::PermissionStatusReq* Arena::CreateMaybeMessage<::ServerData::PermissionStatusReq>(Arena*);
template<> ::ServerData::PostChat* Arena::CreateMaybeMessage<::ServerData::PostChat>(Arena*);
template<> ::ServerData::PostCreateObject* Arena::CreateMaybeMessage<::ServerData::PostCreateObject>(Arena*);
template<> ::ServerData::PostPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::PostPropertyUpdate>(Arena*);
template<> ::ServerData::PostRemoveObject* Arena::CreateMaybeMessage<::ServerData::PostRemoveObject>(Arena*);
template<> ::ServerData::PropMetadataStatus* Arena::CreateMaybeMessage<::ServerData::PropMetadataStatus>(Arena*);
template<> ::ServerData::PropertyValue* Arena::CreateMaybeMessage<::ServerData::PropertyValue>(Arena*);
template<> ::ServerData::PropertyValueStatus* Arena::CreateMaybeMessage<::ServerData::PropertyValueStatus>(Arena*);
template<> ::ServerData::RelayClientMessage* Arena::CreateMaybeMessage<::ServerData::RelayClientMessage>(Arena*);
template<> ::ServerData::RelayClientMessageBatch* Arena::CreateMaybeMessage<::ServerData::RelayClientMessageBatch>(Arena*);
template<> ::ServerData::RelayRemoteMessage* Arena::CreateMaybeMessage<::ServerData::RelayRemoteMessage>(Arena*);
template<> ::ServerData::RelayRemoteMessageBatch* Arena::CreateMaybeMessage<::ServerData::RelayRemoteMessageBatch>(Arena*);
template<> ::ServerData::SetAudioInputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetAudioInputDeviceReq>(Arena*);
template<> ::ServerData::SetAudioOutputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetAudioOutputDeviceReq>(Arena*);
template<> ::ServerData::SetVideoInputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetVideoInputDeviceReq>(Arena*);
template<> ::ServerData::ShutdownSpaceConnectionReq* Arena::CreateMaybeMessage<::ServerData::ShutdownSpaceConnectionReq>(Arena*);
template<> ::ServerData::ShutdownSpaceConnectionResp* Arena::CreateMaybeMessage<::ServerData::ShutdownSpaceConnectionResp>(Arena*);
template<> ::ServerData::SpaceInfo* Arena::CreateMaybeMessage<::ServerData::SpaceInfo>(Arena*);
template<> ::ServerData::StatusMessage* Arena::CreateMaybeMessage<::ServerData::StatusMessage>(Arena*);
template<> ::ServerData::TransformPropertyValue* Arena::CreateMaybeMessage<::ServerData::TransformPropertyValue>(Arena*);
template<> ::ServerData::UpdateLocalUserCoPresence* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserCoPresence>(Arena*);
template<> ::ServerData::UpdateLocalUserMuted* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserMuted>(Arena*);
template<> ::ServerData::UpdateLocalUserStreamState* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserStreamState>(Arena*);
template<> ::ServerData::UpdateTime* Arena::CreateMaybeMessage<::ServerData::UpdateTime>(Arena*);
template<> ::ServerData::UploadLocalFileReq* Arena::CreateMaybeMessage<::ServerData::UploadLocalFileReq>(Arena*);
template<> ::ServerData::UploadLocalFileResp* Arena::CreateMaybeMessage<::ServerData::UploadLocalFileResp>(Arena*);
template<> ::ServerData::UserAdded* Arena::CreateMaybeMessage<::ServerData::UserAdded>(Arena*);
template<> ::ServerData::UserRemoved* Arena::CreateMaybeMessage<::ServerData::UserRemoved>(Arena*);
template<> ::ServerData::UserVideoFrame* Arena::CreateMaybeMessage<::ServerData::UserVideoFrame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ServerData {

enum ChatBase_ChatMessageSourceTypeEnum : int {
  ChatBase_ChatMessageSourceTypeEnum_Chat = 0,
  ChatBase_ChatMessageSourceTypeEnum_Transcription = 1,
  ChatBase_ChatMessageSourceTypeEnum_ChatBase_ChatMessageSourceTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatBase_ChatMessageSourceTypeEnum_ChatBase_ChatMessageSourceTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatBase_ChatMessageSourceTypeEnum_IsValid(int value);
constexpr ChatBase_ChatMessageSourceTypeEnum ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MIN = ChatBase_ChatMessageSourceTypeEnum_Chat;
constexpr ChatBase_ChatMessageSourceTypeEnum ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX = ChatBase_ChatMessageSourceTypeEnum_Transcription;
constexpr int ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_ARRAYSIZE = ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatBase_ChatMessageSourceTypeEnum_descriptor();
template<typename T>
inline const std::string& ChatBase_ChatMessageSourceTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatBase_ChatMessageSourceTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatBase_ChatMessageSourceTypeEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatBase_ChatMessageSourceTypeEnum_descriptor(), enum_t_value);
}
inline bool ChatBase_ChatMessageSourceTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatBase_ChatMessageSourceTypeEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatBase_ChatMessageSourceTypeEnum>(
    ChatBase_ChatMessageSourceTypeEnum_descriptor(), name, value);
}
// ===================================================================

class RelayClientMessageBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayClientMessageBatch) */ {
 public:
  inline RelayClientMessageBatch() : RelayClientMessageBatch(nullptr) {}
  ~RelayClientMessageBatch() override;
  explicit PROTOBUF_CONSTEXPR RelayClientMessageBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayClientMessageBatch(const RelayClientMessageBatch& from);
  RelayClientMessageBatch(RelayClientMessageBatch&& from) noexcept
    : RelayClientMessageBatch() {
    *this = ::std::move(from);
  }

  inline RelayClientMessageBatch& operator=(const RelayClientMessageBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayClientMessageBatch& operator=(RelayClientMessageBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayClientMessageBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayClientMessageBatch* internal_default_instance() {
    return reinterpret_cast<const RelayClientMessageBatch*>(
               &_RelayClientMessageBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RelayClientMessageBatch& a, RelayClientMessageBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayClientMessageBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayClientMessageBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayClientMessageBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayClientMessageBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayClientMessageBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayClientMessageBatch& from) {
    RelayClientMessageBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayClientMessageBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayClientMessageBatch";
  }
  protected:
  explicit RelayClientMessageBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .ServerData.RelayClientMessage Messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::ServerData::RelayClientMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >*
      mutable_messages();
  private:
  const ::ServerData::RelayClientMessage& _internal_messages(int index) const;
  ::ServerData::RelayClientMessage* _internal_add_messages();
  public:
  const ::ServerData::RelayClientMessage& messages(int index) const;
  ::ServerData::RelayClientMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:ServerData.RelayClientMessageBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayClientMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayClientMessage) */ {
 public:
  inline RelayClientMessage() : RelayClientMessage(nullptr) {}
  ~RelayClientMessage() override;
  explicit PROTOBUF_CONSTEXPR RelayClientMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayClientMessage(const RelayClientMessage& from);
  RelayClientMessage(RelayClientMessage&& from) noexcept
    : RelayClientMessage() {
    *this = ::std::move(from);
  }

  inline RelayClientMessage& operator=(const RelayClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayClientMessage& operator=(RelayClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kKeepAlive = 1,
    kUpdateTime = 2,
    kAuthenticateReq = 10,
    kAuthenticateGuestReq = 11,
    kExitAllSpacesAndLogoutReq = 12,
    kJoinSpaceFromIdReq = 20,
    kShutdownSpaceConnectionReq = 21,
    kCreateSpaceReq = 22,
    kGetAudioInputDevicesReq = 30,
    kGetAudioOutputDevicesReq = 31,
    kGetVideoInputDevicesReq = 32,
    kSetAudioInputDeviceReq = 33,
    kSetAudioOutputDeviceReq = 34,
    kSetVideoInputDeviceReq = 35,
    kDefinePropertyDefaultValue = 50,
    kPostPropertyUpdate = 53,
    kBeginTransientPropertyUpdate = 54,
    kContinueTransientPropertyUpdate = 55,
    kFinalizeTransientPropertyUpdate = 56,
    kCancelTransientPropertyUpdate = 57,
    kUpdateLocalUserMuted = 60,
    kUpdateLocalUserCoPresence = 61,
    kUpdateLocalUserStreamState = 62,
    kPostCreateObject = 70,
    kPostRemoveObject = 71,
    kPermissionStatusReq = 90,
    kAllJoinableSpacesReq = 100,
    kFetchFileByIdReq = 110,
    kFetchAllUploadedContentReq = 111,
    kUploadLocalFileReq = 112,
    kPostChat = 120,
    MSG_NOT_SET = 0,
  };

  static inline const RelayClientMessage* internal_default_instance() {
    return reinterpret_cast<const RelayClientMessage*>(
               &_RelayClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelayClientMessage& a, RelayClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayClientMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayClientMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayClientMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayClientMessage& from) {
    RelayClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayClientMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayClientMessage";
  }
  protected:
  explicit RelayClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeepAliveFieldNumber = 1,
    kUpdateTimeFieldNumber = 2,
    kAuthenticateReqFieldNumber = 10,
    kAuthenticateGuestReqFieldNumber = 11,
    kExitAllSpacesAndLogoutReqFieldNumber = 12,
    kJoinSpaceFromIdReqFieldNumber = 20,
    kShutdownSpaceConnectionReqFieldNumber = 21,
    kCreateSpaceReqFieldNumber = 22,
    kGetAudioInputDevicesReqFieldNumber = 30,
    kGetAudioOutputDevicesReqFieldNumber = 31,
    kGetVideoInputDevicesReqFieldNumber = 32,
    kSetAudioInputDeviceReqFieldNumber = 33,
    kSetAudioOutputDeviceReqFieldNumber = 34,
    kSetVideoInputDeviceReqFieldNumber = 35,
    kDefinePropertyDefaultValueFieldNumber = 50,
    kPostPropertyUpdateFieldNumber = 53,
    kBeginTransientPropertyUpdateFieldNumber = 54,
    kContinueTransientPropertyUpdateFieldNumber = 55,
    kFinalizeTransientPropertyUpdateFieldNumber = 56,
    kCancelTransientPropertyUpdateFieldNumber = 57,
    kUpdateLocalUserMutedFieldNumber = 60,
    kUpdateLocalUserCoPresenceFieldNumber = 61,
    kUpdateLocalUserStreamStateFieldNumber = 62,
    kPostCreateObjectFieldNumber = 70,
    kPostRemoveObjectFieldNumber = 71,
    kPermissionStatusReqFieldNumber = 90,
    kAllJoinableSpacesReqFieldNumber = 100,
    kFetchFileByIdReqFieldNumber = 110,
    kFetchAllUploadedContentReqFieldNumber = 111,
    kUploadLocalFileReqFieldNumber = 112,
    kPostChatFieldNumber = 120,
  };
  // .ServerData.KeepAlive KeepAlive = 1;
  bool has_keepalive() const;
  private:
  bool _internal_has_keepalive() const;
  public:
  void clear_keepalive();
  const ::ServerData::KeepAlive& keepalive() const;
  PROTOBUF_NODISCARD ::ServerData::KeepAlive* release_keepalive();
  ::ServerData::KeepAlive* mutable_keepalive();
  void set_allocated_keepalive(::ServerData::KeepAlive* keepalive);
  private:
  const ::ServerData::KeepAlive& _internal_keepalive() const;
  ::ServerData::KeepAlive* _internal_mutable_keepalive();
  public:
  void unsafe_arena_set_allocated_keepalive(
      ::ServerData::KeepAlive* keepalive);
  ::ServerData::KeepAlive* unsafe_arena_release_keepalive();

  // .ServerData.UpdateTime UpdateTime = 2;
  bool has_updatetime() const;
  private:
  bool _internal_has_updatetime() const;
  public:
  void clear_updatetime();
  const ::ServerData::UpdateTime& updatetime() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateTime* release_updatetime();
  ::ServerData::UpdateTime* mutable_updatetime();
  void set_allocated_updatetime(::ServerData::UpdateTime* updatetime);
  private:
  const ::ServerData::UpdateTime& _internal_updatetime() const;
  ::ServerData::UpdateTime* _internal_mutable_updatetime();
  public:
  void unsafe_arena_set_allocated_updatetime(
      ::ServerData::UpdateTime* updatetime);
  ::ServerData::UpdateTime* unsafe_arena_release_updatetime();

  // .ServerData.AuthenticateReq AuthenticateReq = 10;
  bool has_authenticatereq() const;
  private:
  bool _internal_has_authenticatereq() const;
  public:
  void clear_authenticatereq();
  const ::ServerData::AuthenticateReq& authenticatereq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateReq* release_authenticatereq();
  ::ServerData::AuthenticateReq* mutable_authenticatereq();
  void set_allocated_authenticatereq(::ServerData::AuthenticateReq* authenticatereq);
  private:
  const ::ServerData::AuthenticateReq& _internal_authenticatereq() const;
  ::ServerData::AuthenticateReq* _internal_mutable_authenticatereq();
  public:
  void unsafe_arena_set_allocated_authenticatereq(
      ::ServerData::AuthenticateReq* authenticatereq);
  ::ServerData::AuthenticateReq* unsafe_arena_release_authenticatereq();

  // .ServerData.AuthenticateGuestReq AuthenticateGuestReq = 11;
  bool has_authenticateguestreq() const;
  private:
  bool _internal_has_authenticateguestreq() const;
  public:
  void clear_authenticateguestreq();
  const ::ServerData::AuthenticateGuestReq& authenticateguestreq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateGuestReq* release_authenticateguestreq();
  ::ServerData::AuthenticateGuestReq* mutable_authenticateguestreq();
  void set_allocated_authenticateguestreq(::ServerData::AuthenticateGuestReq* authenticateguestreq);
  private:
  const ::ServerData::AuthenticateGuestReq& _internal_authenticateguestreq() const;
  ::ServerData::AuthenticateGuestReq* _internal_mutable_authenticateguestreq();
  public:
  void unsafe_arena_set_allocated_authenticateguestreq(
      ::ServerData::AuthenticateGuestReq* authenticateguestreq);
  ::ServerData::AuthenticateGuestReq* unsafe_arena_release_authenticateguestreq();

  // .ServerData.ExitAllSpacesAndLogoutReq ExitAllSpacesAndLogoutReq = 12;
  bool has_exitallspacesandlogoutreq() const;
  private:
  bool _internal_has_exitallspacesandlogoutreq() const;
  public:
  void clear_exitallspacesandlogoutreq();
  const ::ServerData::ExitAllSpacesAndLogoutReq& exitallspacesandlogoutreq() const;
  PROTOBUF_NODISCARD ::ServerData::ExitAllSpacesAndLogoutReq* release_exitallspacesandlogoutreq();
  ::ServerData::ExitAllSpacesAndLogoutReq* mutable_exitallspacesandlogoutreq();
  void set_allocated_exitallspacesandlogoutreq(::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq);
  private:
  const ::ServerData::ExitAllSpacesAndLogoutReq& _internal_exitallspacesandlogoutreq() const;
  ::ServerData::ExitAllSpacesAndLogoutReq* _internal_mutable_exitallspacesandlogoutreq();
  public:
  void unsafe_arena_set_allocated_exitallspacesandlogoutreq(
      ::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq);
  ::ServerData::ExitAllSpacesAndLogoutReq* unsafe_arena_release_exitallspacesandlogoutreq();

  // .ServerData.JoinSpaceFromIdReq JoinSpaceFromIdReq = 20;
  bool has_joinspacefromidreq() const;
  private:
  bool _internal_has_joinspacefromidreq() const;
  public:
  void clear_joinspacefromidreq();
  const ::ServerData::JoinSpaceFromIdReq& joinspacefromidreq() const;
  PROTOBUF_NODISCARD ::ServerData::JoinSpaceFromIdReq* release_joinspacefromidreq();
  ::ServerData::JoinSpaceFromIdReq* mutable_joinspacefromidreq();
  void set_allocated_joinspacefromidreq(::ServerData::JoinSpaceFromIdReq* joinspacefromidreq);
  private:
  const ::ServerData::JoinSpaceFromIdReq& _internal_joinspacefromidreq() const;
  ::ServerData::JoinSpaceFromIdReq* _internal_mutable_joinspacefromidreq();
  public:
  void unsafe_arena_set_allocated_joinspacefromidreq(
      ::ServerData::JoinSpaceFromIdReq* joinspacefromidreq);
  ::ServerData::JoinSpaceFromIdReq* unsafe_arena_release_joinspacefromidreq();

  // .ServerData.ShutdownSpaceConnectionReq ShutdownSpaceConnectionReq = 21;
  bool has_shutdownspaceconnectionreq() const;
  private:
  bool _internal_has_shutdownspaceconnectionreq() const;
  public:
  void clear_shutdownspaceconnectionreq();
  const ::ServerData::ShutdownSpaceConnectionReq& shutdownspaceconnectionreq() const;
  PROTOBUF_NODISCARD ::ServerData::ShutdownSpaceConnectionReq* release_shutdownspaceconnectionreq();
  ::ServerData::ShutdownSpaceConnectionReq* mutable_shutdownspaceconnectionreq();
  void set_allocated_shutdownspaceconnectionreq(::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq);
  private:
  const ::ServerData::ShutdownSpaceConnectionReq& _internal_shutdownspaceconnectionreq() const;
  ::ServerData::ShutdownSpaceConnectionReq* _internal_mutable_shutdownspaceconnectionreq();
  public:
  void unsafe_arena_set_allocated_shutdownspaceconnectionreq(
      ::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq);
  ::ServerData::ShutdownSpaceConnectionReq* unsafe_arena_release_shutdownspaceconnectionreq();

  // .ServerData.CreateSpaceReq CreateSpaceReq = 22;
  bool has_createspacereq() const;
  private:
  bool _internal_has_createspacereq() const;
  public:
  void clear_createspacereq();
  const ::ServerData::CreateSpaceReq& createspacereq() const;
  PROTOBUF_NODISCARD ::ServerData::CreateSpaceReq* release_createspacereq();
  ::ServerData::CreateSpaceReq* mutable_createspacereq();
  void set_allocated_createspacereq(::ServerData::CreateSpaceReq* createspacereq);
  private:
  const ::ServerData::CreateSpaceReq& _internal_createspacereq() const;
  ::ServerData::CreateSpaceReq* _internal_mutable_createspacereq();
  public:
  void unsafe_arena_set_allocated_createspacereq(
      ::ServerData::CreateSpaceReq* createspacereq);
  ::ServerData::CreateSpaceReq* unsafe_arena_release_createspacereq();

  // .ServerData.GetAudioInputDevicesReq GetAudioInputDevicesReq = 30;
  bool has_getaudioinputdevicesreq() const;
  private:
  bool _internal_has_getaudioinputdevicesreq() const;
  public:
  void clear_getaudioinputdevicesreq();
  const ::ServerData::GetAudioInputDevicesReq& getaudioinputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioInputDevicesReq* release_getaudioinputdevicesreq();
  ::ServerData::GetAudioInputDevicesReq* mutable_getaudioinputdevicesreq();
  void set_allocated_getaudioinputdevicesreq(::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq);
  private:
  const ::ServerData::GetAudioInputDevicesReq& _internal_getaudioinputdevicesreq() const;
  ::ServerData::GetAudioInputDevicesReq* _internal_mutable_getaudioinputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getaudioinputdevicesreq(
      ::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq);
  ::ServerData::GetAudioInputDevicesReq* unsafe_arena_release_getaudioinputdevicesreq();

  // .ServerData.GetAudioOutputDevicesReq GetAudioOutputDevicesReq = 31;
  bool has_getaudiooutputdevicesreq() const;
  private:
  bool _internal_has_getaudiooutputdevicesreq() const;
  public:
  void clear_getaudiooutputdevicesreq();
  const ::ServerData::GetAudioOutputDevicesReq& getaudiooutputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioOutputDevicesReq* release_getaudiooutputdevicesreq();
  ::ServerData::GetAudioOutputDevicesReq* mutable_getaudiooutputdevicesreq();
  void set_allocated_getaudiooutputdevicesreq(::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq);
  private:
  const ::ServerData::GetAudioOutputDevicesReq& _internal_getaudiooutputdevicesreq() const;
  ::ServerData::GetAudioOutputDevicesReq* _internal_mutable_getaudiooutputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getaudiooutputdevicesreq(
      ::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq);
  ::ServerData::GetAudioOutputDevicesReq* unsafe_arena_release_getaudiooutputdevicesreq();

  // .ServerData.GetVideoInputDevicesReq GetVideoInputDevicesReq = 32;
  bool has_getvideoinputdevicesreq() const;
  private:
  bool _internal_has_getvideoinputdevicesreq() const;
  public:
  void clear_getvideoinputdevicesreq();
  const ::ServerData::GetVideoInputDevicesReq& getvideoinputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetVideoInputDevicesReq* release_getvideoinputdevicesreq();
  ::ServerData::GetVideoInputDevicesReq* mutable_getvideoinputdevicesreq();
  void set_allocated_getvideoinputdevicesreq(::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq);
  private:
  const ::ServerData::GetVideoInputDevicesReq& _internal_getvideoinputdevicesreq() const;
  ::ServerData::GetVideoInputDevicesReq* _internal_mutable_getvideoinputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getvideoinputdevicesreq(
      ::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq);
  ::ServerData::GetVideoInputDevicesReq* unsafe_arena_release_getvideoinputdevicesreq();

  // .ServerData.SetAudioInputDeviceReq SetAudioInputDeviceReq = 33;
  bool has_setaudioinputdevicereq() const;
  private:
  bool _internal_has_setaudioinputdevicereq() const;
  public:
  void clear_setaudioinputdevicereq();
  const ::ServerData::SetAudioInputDeviceReq& setaudioinputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetAudioInputDeviceReq* release_setaudioinputdevicereq();
  ::ServerData::SetAudioInputDeviceReq* mutable_setaudioinputdevicereq();
  void set_allocated_setaudioinputdevicereq(::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq);
  private:
  const ::ServerData::SetAudioInputDeviceReq& _internal_setaudioinputdevicereq() const;
  ::ServerData::SetAudioInputDeviceReq* _internal_mutable_setaudioinputdevicereq();
  public:
  void unsafe_arena_set_allocated_setaudioinputdevicereq(
      ::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq);
  ::ServerData::SetAudioInputDeviceReq* unsafe_arena_release_setaudioinputdevicereq();

  // .ServerData.SetAudioOutputDeviceReq SetAudioOutputDeviceReq = 34;
  bool has_setaudiooutputdevicereq() const;
  private:
  bool _internal_has_setaudiooutputdevicereq() const;
  public:
  void clear_setaudiooutputdevicereq();
  const ::ServerData::SetAudioOutputDeviceReq& setaudiooutputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetAudioOutputDeviceReq* release_setaudiooutputdevicereq();
  ::ServerData::SetAudioOutputDeviceReq* mutable_setaudiooutputdevicereq();
  void set_allocated_setaudiooutputdevicereq(::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq);
  private:
  const ::ServerData::SetAudioOutputDeviceReq& _internal_setaudiooutputdevicereq() const;
  ::ServerData::SetAudioOutputDeviceReq* _internal_mutable_setaudiooutputdevicereq();
  public:
  void unsafe_arena_set_allocated_setaudiooutputdevicereq(
      ::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq);
  ::ServerData::SetAudioOutputDeviceReq* unsafe_arena_release_setaudiooutputdevicereq();

  // .ServerData.SetVideoInputDeviceReq SetVideoInputDeviceReq = 35;
  bool has_setvideoinputdevicereq() const;
  private:
  bool _internal_has_setvideoinputdevicereq() const;
  public:
  void clear_setvideoinputdevicereq();
  const ::ServerData::SetVideoInputDeviceReq& setvideoinputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetVideoInputDeviceReq* release_setvideoinputdevicereq();
  ::ServerData::SetVideoInputDeviceReq* mutable_setvideoinputdevicereq();
  void set_allocated_setvideoinputdevicereq(::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq);
  private:
  const ::ServerData::SetVideoInputDeviceReq& _internal_setvideoinputdevicereq() const;
  ::ServerData::SetVideoInputDeviceReq* _internal_mutable_setvideoinputdevicereq();
  public:
  void unsafe_arena_set_allocated_setvideoinputdevicereq(
      ::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq);
  ::ServerData::SetVideoInputDeviceReq* unsafe_arena_release_setvideoinputdevicereq();

  // .ServerData.DefinePropertyDefaultValue DefinePropertyDefaultValue = 50;
  bool has_definepropertydefaultvalue() const;
  private:
  bool _internal_has_definepropertydefaultvalue() const;
  public:
  void clear_definepropertydefaultvalue();
  const ::ServerData::DefinePropertyDefaultValue& definepropertydefaultvalue() const;
  PROTOBUF_NODISCARD ::ServerData::DefinePropertyDefaultValue* release_definepropertydefaultvalue();
  ::ServerData::DefinePropertyDefaultValue* mutable_definepropertydefaultvalue();
  void set_allocated_definepropertydefaultvalue(::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue);
  private:
  const ::ServerData::DefinePropertyDefaultValue& _internal_definepropertydefaultvalue() const;
  ::ServerData::DefinePropertyDefaultValue* _internal_mutable_definepropertydefaultvalue();
  public:
  void unsafe_arena_set_allocated_definepropertydefaultvalue(
      ::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue);
  ::ServerData::DefinePropertyDefaultValue* unsafe_arena_release_definepropertydefaultvalue();

  // .ServerData.PostPropertyUpdate PostPropertyUpdate = 53;
  bool has_postpropertyupdate() const;
  private:
  bool _internal_has_postpropertyupdate() const;
  public:
  void clear_postpropertyupdate();
  const ::ServerData::PostPropertyUpdate& postpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::PostPropertyUpdate* release_postpropertyupdate();
  ::ServerData::PostPropertyUpdate* mutable_postpropertyupdate();
  void set_allocated_postpropertyupdate(::ServerData::PostPropertyUpdate* postpropertyupdate);
  private:
  const ::ServerData::PostPropertyUpdate& _internal_postpropertyupdate() const;
  ::ServerData::PostPropertyUpdate* _internal_mutable_postpropertyupdate();
  public:
  void unsafe_arena_set_allocated_postpropertyupdate(
      ::ServerData::PostPropertyUpdate* postpropertyupdate);
  ::ServerData::PostPropertyUpdate* unsafe_arena_release_postpropertyupdate();

  // .ServerData.BeginTransientPropertyUpdate BeginTransientPropertyUpdate = 54;
  bool has_begintransientpropertyupdate() const;
  private:
  bool _internal_has_begintransientpropertyupdate() const;
  public:
  void clear_begintransientpropertyupdate();
  const ::ServerData::BeginTransientPropertyUpdate& begintransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::BeginTransientPropertyUpdate* release_begintransientpropertyupdate();
  ::ServerData::BeginTransientPropertyUpdate* mutable_begintransientpropertyupdate();
  void set_allocated_begintransientpropertyupdate(::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate);
  private:
  const ::ServerData::BeginTransientPropertyUpdate& _internal_begintransientpropertyupdate() const;
  ::ServerData::BeginTransientPropertyUpdate* _internal_mutable_begintransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_begintransientpropertyupdate(
      ::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate);
  ::ServerData::BeginTransientPropertyUpdate* unsafe_arena_release_begintransientpropertyupdate();

  // .ServerData.ContinueTransientPropertyUpdate ContinueTransientPropertyUpdate = 55;
  bool has_continuetransientpropertyupdate() const;
  private:
  bool _internal_has_continuetransientpropertyupdate() const;
  public:
  void clear_continuetransientpropertyupdate();
  const ::ServerData::ContinueTransientPropertyUpdate& continuetransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::ContinueTransientPropertyUpdate* release_continuetransientpropertyupdate();
  ::ServerData::ContinueTransientPropertyUpdate* mutable_continuetransientpropertyupdate();
  void set_allocated_continuetransientpropertyupdate(::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate);
  private:
  const ::ServerData::ContinueTransientPropertyUpdate& _internal_continuetransientpropertyupdate() const;
  ::ServerData::ContinueTransientPropertyUpdate* _internal_mutable_continuetransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_continuetransientpropertyupdate(
      ::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate);
  ::ServerData::ContinueTransientPropertyUpdate* unsafe_arena_release_continuetransientpropertyupdate();

  // .ServerData.FinalizeTransientPropertyUpdate FinalizeTransientPropertyUpdate = 56;
  bool has_finalizetransientpropertyupdate() const;
  private:
  bool _internal_has_finalizetransientpropertyupdate() const;
  public:
  void clear_finalizetransientpropertyupdate();
  const ::ServerData::FinalizeTransientPropertyUpdate& finalizetransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::FinalizeTransientPropertyUpdate* release_finalizetransientpropertyupdate();
  ::ServerData::FinalizeTransientPropertyUpdate* mutable_finalizetransientpropertyupdate();
  void set_allocated_finalizetransientpropertyupdate(::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate);
  private:
  const ::ServerData::FinalizeTransientPropertyUpdate& _internal_finalizetransientpropertyupdate() const;
  ::ServerData::FinalizeTransientPropertyUpdate* _internal_mutable_finalizetransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_finalizetransientpropertyupdate(
      ::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate);
  ::ServerData::FinalizeTransientPropertyUpdate* unsafe_arena_release_finalizetransientpropertyupdate();

  // .ServerData.CancelTransientPropertyUpdate CancelTransientPropertyUpdate = 57;
  bool has_canceltransientpropertyupdate() const;
  private:
  bool _internal_has_canceltransientpropertyupdate() const;
  public:
  void clear_canceltransientpropertyupdate();
  const ::ServerData::CancelTransientPropertyUpdate& canceltransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::CancelTransientPropertyUpdate* release_canceltransientpropertyupdate();
  ::ServerData::CancelTransientPropertyUpdate* mutable_canceltransientpropertyupdate();
  void set_allocated_canceltransientpropertyupdate(::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate);
  private:
  const ::ServerData::CancelTransientPropertyUpdate& _internal_canceltransientpropertyupdate() const;
  ::ServerData::CancelTransientPropertyUpdate* _internal_mutable_canceltransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_canceltransientpropertyupdate(
      ::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate);
  ::ServerData::CancelTransientPropertyUpdate* unsafe_arena_release_canceltransientpropertyupdate();

  // .ServerData.UpdateLocalUserMuted UpdateLocalUserMuted = 60;
  bool has_updatelocalusermuted() const;
  private:
  bool _internal_has_updatelocalusermuted() const;
  public:
  void clear_updatelocalusermuted();
  const ::ServerData::UpdateLocalUserMuted& updatelocalusermuted() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserMuted* release_updatelocalusermuted();
  ::ServerData::UpdateLocalUserMuted* mutable_updatelocalusermuted();
  void set_allocated_updatelocalusermuted(::ServerData::UpdateLocalUserMuted* updatelocalusermuted);
  private:
  const ::ServerData::UpdateLocalUserMuted& _internal_updatelocalusermuted() const;
  ::ServerData::UpdateLocalUserMuted* _internal_mutable_updatelocalusermuted();
  public:
  void unsafe_arena_set_allocated_updatelocalusermuted(
      ::ServerData::UpdateLocalUserMuted* updatelocalusermuted);
  ::ServerData::UpdateLocalUserMuted* unsafe_arena_release_updatelocalusermuted();

  // .ServerData.UpdateLocalUserCoPresence UpdateLocalUserCoPresence = 61;
  bool has_updatelocalusercopresence() const;
  private:
  bool _internal_has_updatelocalusercopresence() const;
  public:
  void clear_updatelocalusercopresence();
  const ::ServerData::UpdateLocalUserCoPresence& updatelocalusercopresence() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserCoPresence* release_updatelocalusercopresence();
  ::ServerData::UpdateLocalUserCoPresence* mutable_updatelocalusercopresence();
  void set_allocated_updatelocalusercopresence(::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence);
  private:
  const ::ServerData::UpdateLocalUserCoPresence& _internal_updatelocalusercopresence() const;
  ::ServerData::UpdateLocalUserCoPresence* _internal_mutable_updatelocalusercopresence();
  public:
  void unsafe_arena_set_allocated_updatelocalusercopresence(
      ::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence);
  ::ServerData::UpdateLocalUserCoPresence* unsafe_arena_release_updatelocalusercopresence();

  // .ServerData.UpdateLocalUserStreamState UpdateLocalUserStreamState = 62;
  bool has_updatelocaluserstreamstate() const;
  private:
  bool _internal_has_updatelocaluserstreamstate() const;
  public:
  void clear_updatelocaluserstreamstate();
  const ::ServerData::UpdateLocalUserStreamState& updatelocaluserstreamstate() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserStreamState* release_updatelocaluserstreamstate();
  ::ServerData::UpdateLocalUserStreamState* mutable_updatelocaluserstreamstate();
  void set_allocated_updatelocaluserstreamstate(::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate);
  private:
  const ::ServerData::UpdateLocalUserStreamState& _internal_updatelocaluserstreamstate() const;
  ::ServerData::UpdateLocalUserStreamState* _internal_mutable_updatelocaluserstreamstate();
  public:
  void unsafe_arena_set_allocated_updatelocaluserstreamstate(
      ::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate);
  ::ServerData::UpdateLocalUserStreamState* unsafe_arena_release_updatelocaluserstreamstate();

  // .ServerData.PostCreateObject PostCreateObject = 70;
  bool has_postcreateobject() const;
  private:
  bool _internal_has_postcreateobject() const;
  public:
  void clear_postcreateobject();
  const ::ServerData::PostCreateObject& postcreateobject() const;
  PROTOBUF_NODISCARD ::ServerData::PostCreateObject* release_postcreateobject();
  ::ServerData::PostCreateObject* mutable_postcreateobject();
  void set_allocated_postcreateobject(::ServerData::PostCreateObject* postcreateobject);
  private:
  const ::ServerData::PostCreateObject& _internal_postcreateobject() const;
  ::ServerData::PostCreateObject* _internal_mutable_postcreateobject();
  public:
  void unsafe_arena_set_allocated_postcreateobject(
      ::ServerData::PostCreateObject* postcreateobject);
  ::ServerData::PostCreateObject* unsafe_arena_release_postcreateobject();

  // .ServerData.PostRemoveObject PostRemoveObject = 71;
  bool has_postremoveobject() const;
  private:
  bool _internal_has_postremoveobject() const;
  public:
  void clear_postremoveobject();
  const ::ServerData::PostRemoveObject& postremoveobject() const;
  PROTOBUF_NODISCARD ::ServerData::PostRemoveObject* release_postremoveobject();
  ::ServerData::PostRemoveObject* mutable_postremoveobject();
  void set_allocated_postremoveobject(::ServerData::PostRemoveObject* postremoveobject);
  private:
  const ::ServerData::PostRemoveObject& _internal_postremoveobject() const;
  ::ServerData::PostRemoveObject* _internal_mutable_postremoveobject();
  public:
  void unsafe_arena_set_allocated_postremoveobject(
      ::ServerData::PostRemoveObject* postremoveobject);
  ::ServerData::PostRemoveObject* unsafe_arena_release_postremoveobject();

  // .ServerData.PermissionStatusReq PermissionStatusReq = 90;
  bool has_permissionstatusreq() const;
  private:
  bool _internal_has_permissionstatusreq() const;
  public:
  void clear_permissionstatusreq();
  const ::ServerData::PermissionStatusReq& permissionstatusreq() const;
  PROTOBUF_NODISCARD ::ServerData::PermissionStatusReq* release_permissionstatusreq();
  ::ServerData::PermissionStatusReq* mutable_permissionstatusreq();
  void set_allocated_permissionstatusreq(::ServerData::PermissionStatusReq* permissionstatusreq);
  private:
  const ::ServerData::PermissionStatusReq& _internal_permissionstatusreq() const;
  ::ServerData::PermissionStatusReq* _internal_mutable_permissionstatusreq();
  public:
  void unsafe_arena_set_allocated_permissionstatusreq(
      ::ServerData::PermissionStatusReq* permissionstatusreq);
  ::ServerData::PermissionStatusReq* unsafe_arena_release_permissionstatusreq();

  // .ServerData.AllJoinableSpacesReq AllJoinableSpacesReq = 100;
  bool has_alljoinablespacesreq() const;
  private:
  bool _internal_has_alljoinablespacesreq() const;
  public:
  void clear_alljoinablespacesreq();
  const ::ServerData::AllJoinableSpacesReq& alljoinablespacesreq() const;
  PROTOBUF_NODISCARD ::ServerData::AllJoinableSpacesReq* release_alljoinablespacesreq();
  ::ServerData::AllJoinableSpacesReq* mutable_alljoinablespacesreq();
  void set_allocated_alljoinablespacesreq(::ServerData::AllJoinableSpacesReq* alljoinablespacesreq);
  private:
  const ::ServerData::AllJoinableSpacesReq& _internal_alljoinablespacesreq() const;
  ::ServerData::AllJoinableSpacesReq* _internal_mutable_alljoinablespacesreq();
  public:
  void unsafe_arena_set_allocated_alljoinablespacesreq(
      ::ServerData::AllJoinableSpacesReq* alljoinablespacesreq);
  ::ServerData::AllJoinableSpacesReq* unsafe_arena_release_alljoinablespacesreq();

  // .ServerData.FetchFileByIdReq FetchFileByIdReq = 110;
  bool has_fetchfilebyidreq() const;
  private:
  bool _internal_has_fetchfilebyidreq() const;
  public:
  void clear_fetchfilebyidreq();
  const ::ServerData::FetchFileByIdReq& fetchfilebyidreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdReq* release_fetchfilebyidreq();
  ::ServerData::FetchFileByIdReq* mutable_fetchfilebyidreq();
  void set_allocated_fetchfilebyidreq(::ServerData::FetchFileByIdReq* fetchfilebyidreq);
  private:
  const ::ServerData::FetchFileByIdReq& _internal_fetchfilebyidreq() const;
  ::ServerData::FetchFileByIdReq* _internal_mutable_fetchfilebyidreq();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidreq(
      ::ServerData::FetchFileByIdReq* fetchfilebyidreq);
  ::ServerData::FetchFileByIdReq* unsafe_arena_release_fetchfilebyidreq();

  // .ServerData.FetchAllUploadedContentReq FetchAllUploadedContentReq = 111;
  bool has_fetchalluploadedcontentreq() const;
  private:
  bool _internal_has_fetchalluploadedcontentreq() const;
  public:
  void clear_fetchalluploadedcontentreq();
  const ::ServerData::FetchAllUploadedContentReq& fetchalluploadedcontentreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUploadedContentReq* release_fetchalluploadedcontentreq();
  ::ServerData::FetchAllUploadedContentReq* mutable_fetchalluploadedcontentreq();
  void set_allocated_fetchalluploadedcontentreq(::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq);
  private:
  const ::ServerData::FetchAllUploadedContentReq& _internal_fetchalluploadedcontentreq() const;
  ::ServerData::FetchAllUploadedContentReq* _internal_mutable_fetchalluploadedcontentreq();
  public:
  void unsafe_arena_set_allocated_fetchalluploadedcontentreq(
      ::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq);
  ::ServerData::FetchAllUploadedContentReq* unsafe_arena_release_fetchalluploadedcontentreq();

  // .ServerData.UploadLocalFileReq UploadLocalFileReq = 112;
  bool has_uploadlocalfilereq() const;
  private:
  bool _internal_has_uploadlocalfilereq() const;
  public:
  void clear_uploadlocalfilereq();
  const ::ServerData::UploadLocalFileReq& uploadlocalfilereq() const;
  PROTOBUF_NODISCARD ::ServerData::UploadLocalFileReq* release_uploadlocalfilereq();
  ::ServerData::UploadLocalFileReq* mutable_uploadlocalfilereq();
  void set_allocated_uploadlocalfilereq(::ServerData::UploadLocalFileReq* uploadlocalfilereq);
  private:
  const ::ServerData::UploadLocalFileReq& _internal_uploadlocalfilereq() const;
  ::ServerData::UploadLocalFileReq* _internal_mutable_uploadlocalfilereq();
  public:
  void unsafe_arena_set_allocated_uploadlocalfilereq(
      ::ServerData::UploadLocalFileReq* uploadlocalfilereq);
  ::ServerData::UploadLocalFileReq* unsafe_arena_release_uploadlocalfilereq();

  // .ServerData.PostChat PostChat = 120;
  bool has_postchat() const;
  private:
  bool _internal_has_postchat() const;
  public:
  void clear_postchat();
  const ::ServerData::PostChat& postchat() const;
  PROTOBUF_NODISCARD ::ServerData::PostChat* release_postchat();
  ::ServerData::PostChat* mutable_postchat();
  void set_allocated_postchat(::ServerData::PostChat* postchat);
  private:
  const ::ServerData::PostChat& _internal_postchat() const;
  ::ServerData::PostChat* _internal_mutable_postchat();
  public:
  void unsafe_arena_set_allocated_postchat(
      ::ServerData::PostChat* postchat);
  ::ServerData::PostChat* unsafe_arena_release_postchat();

  void clear_Msg();
  MsgCase Msg_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.RelayClientMessage)
 private:
  class _Internal;
  void set_has_keepalive();
  void set_has_updatetime();
  void set_has_authenticatereq();
  void set_has_authenticateguestreq();
  void set_has_exitallspacesandlogoutreq();
  void set_has_joinspacefromidreq();
  void set_has_shutdownspaceconnectionreq();
  void set_has_createspacereq();
  void set_has_getaudioinputdevicesreq();
  void set_has_getaudiooutputdevicesreq();
  void set_has_getvideoinputdevicesreq();
  void set_has_setaudioinputdevicereq();
  void set_has_setaudiooutputdevicereq();
  void set_has_setvideoinputdevicereq();
  void set_has_definepropertydefaultvalue();
  void set_has_postpropertyupdate();
  void set_has_begintransientpropertyupdate();
  void set_has_continuetransientpropertyupdate();
  void set_has_finalizetransientpropertyupdate();
  void set_has_canceltransientpropertyupdate();
  void set_has_updatelocalusermuted();
  void set_has_updatelocalusercopresence();
  void set_has_updatelocaluserstreamstate();
  void set_has_postcreateobject();
  void set_has_postremoveobject();
  void set_has_permissionstatusreq();
  void set_has_alljoinablespacesreq();
  void set_has_fetchfilebyidreq();
  void set_has_fetchalluploadedcontentreq();
  void set_has_uploadlocalfilereq();
  void set_has_postchat();

  inline bool has_Msg() const;
  inline void clear_has_Msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::KeepAlive* keepalive_;
      ::ServerData::UpdateTime* updatetime_;
      ::ServerData::AuthenticateReq* authenticatereq_;
      ::ServerData::AuthenticateGuestReq* authenticateguestreq_;
      ::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq_;
      ::ServerData::JoinSpaceFromIdReq* joinspacefromidreq_;
      ::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq_;
      ::ServerData::CreateSpaceReq* createspacereq_;
      ::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq_;
      ::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq_;
      ::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq_;
      ::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq_;
      ::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq_;
      ::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq_;
      ::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue_;
      ::ServerData::PostPropertyUpdate* postpropertyupdate_;
      ::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate_;
      ::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate_;
      ::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate_;
      ::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate_;
      ::ServerData::UpdateLocalUserMuted* updatelocalusermuted_;
      ::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence_;
      ::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate_;
      ::ServerData::PostCreateObject* postcreateobject_;
      ::ServerData::PostRemoveObject* postremoveobject_;
      ::ServerData::PermissionStatusReq* permissionstatusreq_;
      ::ServerData::AllJoinableSpacesReq* alljoinablespacesreq_;
      ::ServerData::FetchFileByIdReq* fetchfilebyidreq_;
      ::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq_;
      ::ServerData::UploadLocalFileReq* uploadlocalfilereq_;
      ::ServerData::PostChat* postchat_;
    } Msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayRemoteMessageBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayRemoteMessageBatch) */ {
 public:
  inline RelayRemoteMessageBatch() : RelayRemoteMessageBatch(nullptr) {}
  ~RelayRemoteMessageBatch() override;
  explicit PROTOBUF_CONSTEXPR RelayRemoteMessageBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayRemoteMessageBatch(const RelayRemoteMessageBatch& from);
  RelayRemoteMessageBatch(RelayRemoteMessageBatch&& from) noexcept
    : RelayRemoteMessageBatch() {
    *this = ::std::move(from);
  }

  inline RelayRemoteMessageBatch& operator=(const RelayRemoteMessageBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayRemoteMessageBatch& operator=(RelayRemoteMessageBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayRemoteMessageBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayRemoteMessageBatch* internal_default_instance() {
    return reinterpret_cast<const RelayRemoteMessageBatch*>(
               &_RelayRemoteMessageBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RelayRemoteMessageBatch& a, RelayRemoteMessageBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayRemoteMessageBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayRemoteMessageBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayRemoteMessageBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayRemoteMessageBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayRemoteMessageBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayRemoteMessageBatch& from) {
    RelayRemoteMessageBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayRemoteMessageBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayRemoteMessageBatch";
  }
  protected:
  explicit RelayRemoteMessageBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .ServerData.RelayRemoteMessage Messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::ServerData::RelayRemoteMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >*
      mutable_messages();
  private:
  const ::ServerData::RelayRemoteMessage& _internal_messages(int index) const;
  ::ServerData::RelayRemoteMessage* _internal_add_messages();
  public:
  const ::ServerData::RelayRemoteMessage& messages(int index) const;
  ::ServerData::RelayRemoteMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:ServerData.RelayRemoteMessageBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayRemoteMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayRemoteMessage) */ {
 public:
  inline RelayRemoteMessage() : RelayRemoteMessage(nullptr) {}
  ~RelayRemoteMessage() override;
  explicit PROTOBUF_CONSTEXPR RelayRemoteMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayRemoteMessage(const RelayRemoteMessage& from);
  RelayRemoteMessage(RelayRemoteMessage&& from) noexcept
    : RelayRemoteMessage() {
    *this = ::std::move(from);
  }

  inline RelayRemoteMessage& operator=(const RelayRemoteMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayRemoteMessage& operator=(RelayRemoteMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayRemoteMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kMessage = 1,
    kAuthenticateResp = 2,
    kAuthenticateGuestResp = 3,
    kExitAllSpacesAndLogoutResp = 4,
    kJoinSpaceFromIdResp = 10,
    kShutdownSpaceConnectionResp = 11,
    kCreateSpaceResp = 12,
    kGetAudioInputDevicesResp = 20,
    kGetAudioOutputDevicesResp = 21,
    kGetVideoInputDevicesResp = 22,
    kPropertyValueStatus = 50,
    kLocalPropertyHandledResp = 51,
    kPropMetadataStatus = 52,
    kUserAdded = 60,
    kUserRemoved = 61,
    kUserVideoFrame = 65,
    kSpaceAdded = 70,
    kSpaceUpdated = 71,
    kSpaceRemoved = 72,
    kObjectAdded = 80,
    kObjectRemoved = 81,
    kPermissionStatus = 90,
    kAllJoinableSpacesResp = 100,
    kFetchFileByIdProgressResp = 110,
    kFetchFileByIdCompletedResp = 111,
    kFetchAllUploadedContentResp = 112,
    kUploadLocalFileResp = 113,
    kChatAdded = 120,
    kChatUpdated = 121,
    kChatRemoved = 122,
    MSG_NOT_SET = 0,
  };

  static inline const RelayRemoteMessage* internal_default_instance() {
    return reinterpret_cast<const RelayRemoteMessage*>(
               &_RelayRemoteMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RelayRemoteMessage& a, RelayRemoteMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayRemoteMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayRemoteMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayRemoteMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayRemoteMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayRemoteMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayRemoteMessage& from) {
    RelayRemoteMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayRemoteMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayRemoteMessage";
  }
  protected:
  explicit RelayRemoteMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kAuthenticateRespFieldNumber = 2,
    kAuthenticateGuestRespFieldNumber = 3,
    kExitAllSpacesAndLogoutRespFieldNumber = 4,
    kJoinSpaceFromIdRespFieldNumber = 10,
    kShutdownSpaceConnectionRespFieldNumber = 11,
    kCreateSpaceRespFieldNumber = 12,
    kGetAudioInputDevicesRespFieldNumber = 20,
    kGetAudioOutputDevicesRespFieldNumber = 21,
    kGetVideoInputDevicesRespFieldNumber = 22,
    kPropertyValueStatusFieldNumber = 50,
    kLocalPropertyHandledRespFieldNumber = 51,
    kPropMetadataStatusFieldNumber = 52,
    kUserAddedFieldNumber = 60,
    kUserRemovedFieldNumber = 61,
    kUserVideoFrameFieldNumber = 65,
    kSpaceAddedFieldNumber = 70,
    kSpaceUpdatedFieldNumber = 71,
    kSpaceRemovedFieldNumber = 72,
    kObjectAddedFieldNumber = 80,
    kObjectRemovedFieldNumber = 81,
    kPermissionStatusFieldNumber = 90,
    kAllJoinableSpacesRespFieldNumber = 100,
    kFetchFileByIdProgressRespFieldNumber = 110,
    kFetchFileByIdCompletedRespFieldNumber = 111,
    kFetchAllUploadedContentRespFieldNumber = 112,
    kUploadLocalFileRespFieldNumber = 113,
    kChatAddedFieldNumber = 120,
    kChatUpdatedFieldNumber = 121,
    kChatRemovedFieldNumber = 122,
  };
  // .ServerData.StatusMessage Message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::ServerData::StatusMessage& message() const;
  PROTOBUF_NODISCARD ::ServerData::StatusMessage* release_message();
  ::ServerData::StatusMessage* mutable_message();
  void set_allocated_message(::ServerData::StatusMessage* message);
  private:
  const ::ServerData::StatusMessage& _internal_message() const;
  ::ServerData::StatusMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::ServerData::StatusMessage* message);
  ::ServerData::StatusMessage* unsafe_arena_release_message();

  // .ServerData.AuthenticateResp AuthenticateResp = 2;
  bool has_authenticateresp() const;
  private:
  bool _internal_has_authenticateresp() const;
  public:
  void clear_authenticateresp();
  const ::ServerData::AuthenticateResp& authenticateresp() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateResp* release_authenticateresp();
  ::ServerData::AuthenticateResp* mutable_authenticateresp();
  void set_allocated_authenticateresp(::ServerData::AuthenticateResp* authenticateresp);
  private:
  const ::ServerData::AuthenticateResp& _internal_authenticateresp() const;
  ::ServerData::AuthenticateResp* _internal_mutable_authenticateresp();
  public:
  void unsafe_arena_set_allocated_authenticateresp(
      ::ServerData::AuthenticateResp* authenticateresp);
  ::ServerData::AuthenticateResp* unsafe_arena_release_authenticateresp();

  // .ServerData.AuthenticateGuestResp AuthenticateGuestResp = 3;
  bool has_authenticateguestresp() const;
  private:
  bool _internal_has_authenticateguestresp() const;
  public:
  void clear_authenticateguestresp();
  const ::ServerData::AuthenticateGuestResp& authenticateguestresp() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateGuestResp* release_authenticateguestresp();
  ::ServerData::AuthenticateGuestResp* mutable_authenticateguestresp();
  void set_allocated_authenticateguestresp(::ServerData::AuthenticateGuestResp* authenticateguestresp);
  private:
  const ::ServerData::AuthenticateGuestResp& _internal_authenticateguestresp() const;
  ::ServerData::AuthenticateGuestResp* _internal_mutable_authenticateguestresp();
  public:
  void unsafe_arena_set_allocated_authenticateguestresp(
      ::ServerData::AuthenticateGuestResp* authenticateguestresp);
  ::ServerData::AuthenticateGuestResp* unsafe_arena_release_authenticateguestresp();

  // .ServerData.ExitAllSpacesAndLogoutResp ExitAllSpacesAndLogoutResp = 4;
  bool has_exitallspacesandlogoutresp() const;
  private:
  bool _internal_has_exitallspacesandlogoutresp() const;
  public:
  void clear_exitallspacesandlogoutresp();
  const ::ServerData::ExitAllSpacesAndLogoutResp& exitallspacesandlogoutresp() const;
  PROTOBUF_NODISCARD ::ServerData::ExitAllSpacesAndLogoutResp* release_exitallspacesandlogoutresp();
  ::ServerData::ExitAllSpacesAndLogoutResp* mutable_exitallspacesandlogoutresp();
  void set_allocated_exitallspacesandlogoutresp(::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp);
  private:
  const ::ServerData::ExitAllSpacesAndLogoutResp& _internal_exitallspacesandlogoutresp() const;
  ::ServerData::ExitAllSpacesAndLogoutResp* _internal_mutable_exitallspacesandlogoutresp();
  public:
  void unsafe_arena_set_allocated_exitallspacesandlogoutresp(
      ::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp);
  ::ServerData::ExitAllSpacesAndLogoutResp* unsafe_arena_release_exitallspacesandlogoutresp();

  // .ServerData.JoinSpaceFromIdResp JoinSpaceFromIdResp = 10;
  bool has_joinspacefromidresp() const;
  private:
  bool _internal_has_joinspacefromidresp() const;
  public:
  void clear_joinspacefromidresp();
  const ::ServerData::JoinSpaceFromIdResp& joinspacefromidresp() const;
  PROTOBUF_NODISCARD ::ServerData::JoinSpaceFromIdResp* release_joinspacefromidresp();
  ::ServerData::JoinSpaceFromIdResp* mutable_joinspacefromidresp();
  void set_allocated_joinspacefromidresp(::ServerData::JoinSpaceFromIdResp* joinspacefromidresp);
  private:
  const ::ServerData::JoinSpaceFromIdResp& _internal_joinspacefromidresp() const;
  ::ServerData::JoinSpaceFromIdResp* _internal_mutable_joinspacefromidresp();
  public:
  void unsafe_arena_set_allocated_joinspacefromidresp(
      ::ServerData::JoinSpaceFromIdResp* joinspacefromidresp);
  ::ServerData::JoinSpaceFromIdResp* unsafe_arena_release_joinspacefromidresp();

  // .ServerData.ShutdownSpaceConnectionResp ShutdownSpaceConnectionResp = 11;
  bool has_shutdownspaceconnectionresp() const;
  private:
  bool _internal_has_shutdownspaceconnectionresp() const;
  public:
  void clear_shutdownspaceconnectionresp();
  const ::ServerData::ShutdownSpaceConnectionResp& shutdownspaceconnectionresp() const;
  PROTOBUF_NODISCARD ::ServerData::ShutdownSpaceConnectionResp* release_shutdownspaceconnectionresp();
  ::ServerData::ShutdownSpaceConnectionResp* mutable_shutdownspaceconnectionresp();
  void set_allocated_shutdownspaceconnectionresp(::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp);
  private:
  const ::ServerData::ShutdownSpaceConnectionResp& _internal_shutdownspaceconnectionresp() const;
  ::ServerData::ShutdownSpaceConnectionResp* _internal_mutable_shutdownspaceconnectionresp();
  public:
  void unsafe_arena_set_allocated_shutdownspaceconnectionresp(
      ::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp);
  ::ServerData::ShutdownSpaceConnectionResp* unsafe_arena_release_shutdownspaceconnectionresp();

  // .ServerData.CreateSpaceResp CreateSpaceResp = 12;
  bool has_createspaceresp() const;
  private:
  bool _internal_has_createspaceresp() const;
  public:
  void clear_createspaceresp();
  const ::ServerData::CreateSpaceResp& createspaceresp() const;
  PROTOBUF_NODISCARD ::ServerData::CreateSpaceResp* release_createspaceresp();
  ::ServerData::CreateSpaceResp* mutable_createspaceresp();
  void set_allocated_createspaceresp(::ServerData::CreateSpaceResp* createspaceresp);
  private:
  const ::ServerData::CreateSpaceResp& _internal_createspaceresp() const;
  ::ServerData::CreateSpaceResp* _internal_mutable_createspaceresp();
  public:
  void unsafe_arena_set_allocated_createspaceresp(
      ::ServerData::CreateSpaceResp* createspaceresp);
  ::ServerData::CreateSpaceResp* unsafe_arena_release_createspaceresp();

  // .ServerData.GetAudioInputDevicesResp GetAudioInputDevicesResp = 20;
  bool has_getaudioinputdevicesresp() const;
  private:
  bool _internal_has_getaudioinputdevicesresp() const;
  public:
  void clear_getaudioinputdevicesresp();
  const ::ServerData::GetAudioInputDevicesResp& getaudioinputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioInputDevicesResp* release_getaudioinputdevicesresp();
  ::ServerData::GetAudioInputDevicesResp* mutable_getaudioinputdevicesresp();
  void set_allocated_getaudioinputdevicesresp(::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp);
  private:
  const ::ServerData::GetAudioInputDevicesResp& _internal_getaudioinputdevicesresp() const;
  ::ServerData::GetAudioInputDevicesResp* _internal_mutable_getaudioinputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getaudioinputdevicesresp(
      ::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp);
  ::ServerData::GetAudioInputDevicesResp* unsafe_arena_release_getaudioinputdevicesresp();

  // .ServerData.GetAudioOutputDevicesResp GetAudioOutputDevicesResp = 21;
  bool has_getaudiooutputdevicesresp() const;
  private:
  bool _internal_has_getaudiooutputdevicesresp() const;
  public:
  void clear_getaudiooutputdevicesresp();
  const ::ServerData::GetAudioOutputDevicesResp& getaudiooutputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioOutputDevicesResp* release_getaudiooutputdevicesresp();
  ::ServerData::GetAudioOutputDevicesResp* mutable_getaudiooutputdevicesresp();
  void set_allocated_getaudiooutputdevicesresp(::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp);
  private:
  const ::ServerData::GetAudioOutputDevicesResp& _internal_getaudiooutputdevicesresp() const;
  ::ServerData::GetAudioOutputDevicesResp* _internal_mutable_getaudiooutputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getaudiooutputdevicesresp(
      ::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp);
  ::ServerData::GetAudioOutputDevicesResp* unsafe_arena_release_getaudiooutputdevicesresp();

  // .ServerData.GetVideoInputDevicesResp GetVideoInputDevicesResp = 22;
  bool has_getvideoinputdevicesresp() const;
  private:
  bool _internal_has_getvideoinputdevicesresp() const;
  public:
  void clear_getvideoinputdevicesresp();
  const ::ServerData::GetVideoInputDevicesResp& getvideoinputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetVideoInputDevicesResp* release_getvideoinputdevicesresp();
  ::ServerData::GetVideoInputDevicesResp* mutable_getvideoinputdevicesresp();
  void set_allocated_getvideoinputdevicesresp(::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp);
  private:
  const ::ServerData::GetVideoInputDevicesResp& _internal_getvideoinputdevicesresp() const;
  ::ServerData::GetVideoInputDevicesResp* _internal_mutable_getvideoinputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getvideoinputdevicesresp(
      ::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp);
  ::ServerData::GetVideoInputDevicesResp* unsafe_arena_release_getvideoinputdevicesresp();

  // .ServerData.PropertyValueStatus PropertyValueStatus = 50;
  bool has_propertyvaluestatus() const;
  private:
  bool _internal_has_propertyvaluestatus() const;
  public:
  void clear_propertyvaluestatus();
  const ::ServerData::PropertyValueStatus& propertyvaluestatus() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValueStatus* release_propertyvaluestatus();
  ::ServerData::PropertyValueStatus* mutable_propertyvaluestatus();
  void set_allocated_propertyvaluestatus(::ServerData::PropertyValueStatus* propertyvaluestatus);
  private:
  const ::ServerData::PropertyValueStatus& _internal_propertyvaluestatus() const;
  ::ServerData::PropertyValueStatus* _internal_mutable_propertyvaluestatus();
  public:
  void unsafe_arena_set_allocated_propertyvaluestatus(
      ::ServerData::PropertyValueStatus* propertyvaluestatus);
  ::ServerData::PropertyValueStatus* unsafe_arena_release_propertyvaluestatus();

  // .ServerData.LocalPropertyHandledResp LocalPropertyHandledResp = 51;
  bool has_localpropertyhandledresp() const;
  private:
  bool _internal_has_localpropertyhandledresp() const;
  public:
  void clear_localpropertyhandledresp();
  const ::ServerData::LocalPropertyHandledResp& localpropertyhandledresp() const;
  PROTOBUF_NODISCARD ::ServerData::LocalPropertyHandledResp* release_localpropertyhandledresp();
  ::ServerData::LocalPropertyHandledResp* mutable_localpropertyhandledresp();
  void set_allocated_localpropertyhandledresp(::ServerData::LocalPropertyHandledResp* localpropertyhandledresp);
  private:
  const ::ServerData::LocalPropertyHandledResp& _internal_localpropertyhandledresp() const;
  ::ServerData::LocalPropertyHandledResp* _internal_mutable_localpropertyhandledresp();
  public:
  void unsafe_arena_set_allocated_localpropertyhandledresp(
      ::ServerData::LocalPropertyHandledResp* localpropertyhandledresp);
  ::ServerData::LocalPropertyHandledResp* unsafe_arena_release_localpropertyhandledresp();

  // .ServerData.PropMetadataStatus PropMetadataStatus = 52;
  bool has_propmetadatastatus() const;
  private:
  bool _internal_has_propmetadatastatus() const;
  public:
  void clear_propmetadatastatus();
  const ::ServerData::PropMetadataStatus& propmetadatastatus() const;
  PROTOBUF_NODISCARD ::ServerData::PropMetadataStatus* release_propmetadatastatus();
  ::ServerData::PropMetadataStatus* mutable_propmetadatastatus();
  void set_allocated_propmetadatastatus(::ServerData::PropMetadataStatus* propmetadatastatus);
  private:
  const ::ServerData::PropMetadataStatus& _internal_propmetadatastatus() const;
  ::ServerData::PropMetadataStatus* _internal_mutable_propmetadatastatus();
  public:
  void unsafe_arena_set_allocated_propmetadatastatus(
      ::ServerData::PropMetadataStatus* propmetadatastatus);
  ::ServerData::PropMetadataStatus* unsafe_arena_release_propmetadatastatus();

  // .ServerData.UserAdded UserAdded = 60;
  bool has_useradded() const;
  private:
  bool _internal_has_useradded() const;
  public:
  void clear_useradded();
  const ::ServerData::UserAdded& useradded() const;
  PROTOBUF_NODISCARD ::ServerData::UserAdded* release_useradded();
  ::ServerData::UserAdded* mutable_useradded();
  void set_allocated_useradded(::ServerData::UserAdded* useradded);
  private:
  const ::ServerData::UserAdded& _internal_useradded() const;
  ::ServerData::UserAdded* _internal_mutable_useradded();
  public:
  void unsafe_arena_set_allocated_useradded(
      ::ServerData::UserAdded* useradded);
  ::ServerData::UserAdded* unsafe_arena_release_useradded();

  // .ServerData.UserRemoved UserRemoved = 61;
  bool has_userremoved() const;
  private:
  bool _internal_has_userremoved() const;
  public:
  void clear_userremoved();
  const ::ServerData::UserRemoved& userremoved() const;
  PROTOBUF_NODISCARD ::ServerData::UserRemoved* release_userremoved();
  ::ServerData::UserRemoved* mutable_userremoved();
  void set_allocated_userremoved(::ServerData::UserRemoved* userremoved);
  private:
  const ::ServerData::UserRemoved& _internal_userremoved() const;
  ::ServerData::UserRemoved* _internal_mutable_userremoved();
  public:
  void unsafe_arena_set_allocated_userremoved(
      ::ServerData::UserRemoved* userremoved);
  ::ServerData::UserRemoved* unsafe_arena_release_userremoved();

  // .ServerData.UserVideoFrame UserVideoFrame = 65;
  bool has_uservideoframe() const;
  private:
  bool _internal_has_uservideoframe() const;
  public:
  void clear_uservideoframe();
  const ::ServerData::UserVideoFrame& uservideoframe() const;
  PROTOBUF_NODISCARD ::ServerData::UserVideoFrame* release_uservideoframe();
  ::ServerData::UserVideoFrame* mutable_uservideoframe();
  void set_allocated_uservideoframe(::ServerData::UserVideoFrame* uservideoframe);
  private:
  const ::ServerData::UserVideoFrame& _internal_uservideoframe() const;
  ::ServerData::UserVideoFrame* _internal_mutable_uservideoframe();
  public:
  void unsafe_arena_set_allocated_uservideoframe(
      ::ServerData::UserVideoFrame* uservideoframe);
  ::ServerData::UserVideoFrame* unsafe_arena_release_uservideoframe();

  // .ServerData.SpaceInfo SpaceAdded = 70;
  bool has_spaceadded() const;
  private:
  bool _internal_has_spaceadded() const;
  public:
  void clear_spaceadded();
  const ::ServerData::SpaceInfo& spaceadded() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceadded();
  ::ServerData::SpaceInfo* mutable_spaceadded();
  void set_allocated_spaceadded(::ServerData::SpaceInfo* spaceadded);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceadded() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceadded();
  public:
  void unsafe_arena_set_allocated_spaceadded(
      ::ServerData::SpaceInfo* spaceadded);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceadded();

  // .ServerData.SpaceInfo SpaceUpdated = 71;
  bool has_spaceupdated() const;
  private:
  bool _internal_has_spaceupdated() const;
  public:
  void clear_spaceupdated();
  const ::ServerData::SpaceInfo& spaceupdated() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceupdated();
  ::ServerData::SpaceInfo* mutable_spaceupdated();
  void set_allocated_spaceupdated(::ServerData::SpaceInfo* spaceupdated);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceupdated() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceupdated();
  public:
  void unsafe_arena_set_allocated_spaceupdated(
      ::ServerData::SpaceInfo* spaceupdated);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceupdated();

  // .ServerData.SpaceInfo SpaceRemoved = 72;
  bool has_spaceremoved() const;
  private:
  bool _internal_has_spaceremoved() const;
  public:
  void clear_spaceremoved();
  const ::ServerData::SpaceInfo& spaceremoved() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceremoved();
  ::ServerData::SpaceInfo* mutable_spaceremoved();
  void set_allocated_spaceremoved(::ServerData::SpaceInfo* spaceremoved);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceremoved() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceremoved();
  public:
  void unsafe_arena_set_allocated_spaceremoved(
      ::ServerData::SpaceInfo* spaceremoved);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceremoved();

  // .ServerData.ObjectAdded ObjectAdded = 80;
  bool has_objectadded() const;
  private:
  bool _internal_has_objectadded() const;
  public:
  void clear_objectadded();
  const ::ServerData::ObjectAdded& objectadded() const;
  PROTOBUF_NODISCARD ::ServerData::ObjectAdded* release_objectadded();
  ::ServerData::ObjectAdded* mutable_objectadded();
  void set_allocated_objectadded(::ServerData::ObjectAdded* objectadded);
  private:
  const ::ServerData::ObjectAdded& _internal_objectadded() const;
  ::ServerData::ObjectAdded* _internal_mutable_objectadded();
  public:
  void unsafe_arena_set_allocated_objectadded(
      ::ServerData::ObjectAdded* objectadded);
  ::ServerData::ObjectAdded* unsafe_arena_release_objectadded();

  // .ServerData.ObjectRemoved ObjectRemoved = 81;
  bool has_objectremoved() const;
  private:
  bool _internal_has_objectremoved() const;
  public:
  void clear_objectremoved();
  const ::ServerData::ObjectRemoved& objectremoved() const;
  PROTOBUF_NODISCARD ::ServerData::ObjectRemoved* release_objectremoved();
  ::ServerData::ObjectRemoved* mutable_objectremoved();
  void set_allocated_objectremoved(::ServerData::ObjectRemoved* objectremoved);
  private:
  const ::ServerData::ObjectRemoved& _internal_objectremoved() const;
  ::ServerData::ObjectRemoved* _internal_mutable_objectremoved();
  public:
  void unsafe_arena_set_allocated_objectremoved(
      ::ServerData::ObjectRemoved* objectremoved);
  ::ServerData::ObjectRemoved* unsafe_arena_release_objectremoved();

  // .ServerData.PermissionStatus PermissionStatus = 90;
  bool has_permissionstatus() const;
  private:
  bool _internal_has_permissionstatus() const;
  public:
  void clear_permissionstatus();
  const ::ServerData::PermissionStatus& permissionstatus() const;
  PROTOBUF_NODISCARD ::ServerData::PermissionStatus* release_permissionstatus();
  ::ServerData::PermissionStatus* mutable_permissionstatus();
  void set_allocated_permissionstatus(::ServerData::PermissionStatus* permissionstatus);
  private:
  const ::ServerData::PermissionStatus& _internal_permissionstatus() const;
  ::ServerData::PermissionStatus* _internal_mutable_permissionstatus();
  public:
  void unsafe_arena_set_allocated_permissionstatus(
      ::ServerData::PermissionStatus* permissionstatus);
  ::ServerData::PermissionStatus* unsafe_arena_release_permissionstatus();

  // .ServerData.AllJoinableSpacesResp AllJoinableSpacesResp = 100;
  bool has_alljoinablespacesresp() const;
  private:
  bool _internal_has_alljoinablespacesresp() const;
  public:
  void clear_alljoinablespacesresp();
  const ::ServerData::AllJoinableSpacesResp& alljoinablespacesresp() const;
  PROTOBUF_NODISCARD ::ServerData::AllJoinableSpacesResp* release_alljoinablespacesresp();
  ::ServerData::AllJoinableSpacesResp* mutable_alljoinablespacesresp();
  void set_allocated_alljoinablespacesresp(::ServerData::AllJoinableSpacesResp* alljoinablespacesresp);
  private:
  const ::ServerData::AllJoinableSpacesResp& _internal_alljoinablespacesresp() const;
  ::ServerData::AllJoinableSpacesResp* _internal_mutable_alljoinablespacesresp();
  public:
  void unsafe_arena_set_allocated_alljoinablespacesresp(
      ::ServerData::AllJoinableSpacesResp* alljoinablespacesresp);
  ::ServerData::AllJoinableSpacesResp* unsafe_arena_release_alljoinablespacesresp();

  // .ServerData.FetchFileByIdProgressResp FetchFileByIdProgressResp = 110;
  bool has_fetchfilebyidprogressresp() const;
  private:
  bool _internal_has_fetchfilebyidprogressresp() const;
  public:
  void clear_fetchfilebyidprogressresp();
  const ::ServerData::FetchFileByIdProgressResp& fetchfilebyidprogressresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdProgressResp* release_fetchfilebyidprogressresp();
  ::ServerData::FetchFileByIdProgressResp* mutable_fetchfilebyidprogressresp();
  void set_allocated_fetchfilebyidprogressresp(::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp);
  private:
  const ::ServerData::FetchFileByIdProgressResp& _internal_fetchfilebyidprogressresp() const;
  ::ServerData::FetchFileByIdProgressResp* _internal_mutable_fetchfilebyidprogressresp();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidprogressresp(
      ::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp);
  ::ServerData::FetchFileByIdProgressResp* unsafe_arena_release_fetchfilebyidprogressresp();

  // .ServerData.FetchFileByIdCompletedResp FetchFileByIdCompletedResp = 111;
  bool has_fetchfilebyidcompletedresp() const;
  private:
  bool _internal_has_fetchfilebyidcompletedresp() const;
  public:
  void clear_fetchfilebyidcompletedresp();
  const ::ServerData::FetchFileByIdCompletedResp& fetchfilebyidcompletedresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdCompletedResp* release_fetchfilebyidcompletedresp();
  ::ServerData::FetchFileByIdCompletedResp* mutable_fetchfilebyidcompletedresp();
  void set_allocated_fetchfilebyidcompletedresp(::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp);
  private:
  const ::ServerData::FetchFileByIdCompletedResp& _internal_fetchfilebyidcompletedresp() const;
  ::ServerData::FetchFileByIdCompletedResp* _internal_mutable_fetchfilebyidcompletedresp();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidcompletedresp(
      ::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp);
  ::ServerData::FetchFileByIdCompletedResp* unsafe_arena_release_fetchfilebyidcompletedresp();

  // .ServerData.FetchAllUploadedContentResp FetchAllUploadedContentResp = 112;
  bool has_fetchalluploadedcontentresp() const;
  private:
  bool _internal_has_fetchalluploadedcontentresp() const;
  public:
  void clear_fetchalluploadedcontentresp();
  const ::ServerData::FetchAllUploadedContentResp& fetchalluploadedcontentresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUploadedContentResp* release_fetchalluploadedcontentresp();
  ::ServerData::FetchAllUploadedContentResp* mutable_fetchalluploadedcontentresp();
  void set_allocated_fetchalluploadedcontentresp(::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp);
  private:
  const ::ServerData::FetchAllUploadedContentResp& _internal_fetchalluploadedcontentresp() const;
  ::ServerData::FetchAllUploadedContentResp* _internal_mutable_fetchalluploadedcontentresp();
  public:
  void unsafe_arena_set_allocated_fetchalluploadedcontentresp(
      ::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp);
  ::ServerData::FetchAllUploadedContentResp* unsafe_arena_release_fetchalluploadedcontentresp();

  // .ServerData.UploadLocalFileResp UploadLocalFileResp = 113;
  bool has_uploadlocalfileresp() const;
  private:
  bool _internal_has_uploadlocalfileresp() const;
  public:
  void clear_uploadlocalfileresp();
  const ::ServerData::UploadLocalFileResp& uploadlocalfileresp() const;
  PROTOBUF_NODISCARD ::ServerData::UploadLocalFileResp* release_uploadlocalfileresp();
  ::ServerData::UploadLocalFileResp* mutable_uploadlocalfileresp();
  void set_allocated_uploadlocalfileresp(::ServerData::UploadLocalFileResp* uploadlocalfileresp);
  private:
  const ::ServerData::UploadLocalFileResp& _internal_uploadlocalfileresp() const;
  ::ServerData::UploadLocalFileResp* _internal_mutable_uploadlocalfileresp();
  public:
  void unsafe_arena_set_allocated_uploadlocalfileresp(
      ::ServerData::UploadLocalFileResp* uploadlocalfileresp);
  ::ServerData::UploadLocalFileResp* unsafe_arena_release_uploadlocalfileresp();

  // .ServerData.ChatAdded ChatAdded = 120;
  bool has_chatadded() const;
  private:
  bool _internal_has_chatadded() const;
  public:
  void clear_chatadded();
  const ::ServerData::ChatAdded& chatadded() const;
  PROTOBUF_NODISCARD ::ServerData::ChatAdded* release_chatadded();
  ::ServerData::ChatAdded* mutable_chatadded();
  void set_allocated_chatadded(::ServerData::ChatAdded* chatadded);
  private:
  const ::ServerData::ChatAdded& _internal_chatadded() const;
  ::ServerData::ChatAdded* _internal_mutable_chatadded();
  public:
  void unsafe_arena_set_allocated_chatadded(
      ::ServerData::ChatAdded* chatadded);
  ::ServerData::ChatAdded* unsafe_arena_release_chatadded();

  // .ServerData.ChatUpdated ChatUpdated = 121;
  bool has_chatupdated() const;
  private:
  bool _internal_has_chatupdated() const;
  public:
  void clear_chatupdated();
  const ::ServerData::ChatUpdated& chatupdated() const;
  PROTOBUF_NODISCARD ::ServerData::ChatUpdated* release_chatupdated();
  ::ServerData::ChatUpdated* mutable_chatupdated();
  void set_allocated_chatupdated(::ServerData::ChatUpdated* chatupdated);
  private:
  const ::ServerData::ChatUpdated& _internal_chatupdated() const;
  ::ServerData::ChatUpdated* _internal_mutable_chatupdated();
  public:
  void unsafe_arena_set_allocated_chatupdated(
      ::ServerData::ChatUpdated* chatupdated);
  ::ServerData::ChatUpdated* unsafe_arena_release_chatupdated();

  // .ServerData.ChatRemoved ChatRemoved = 122;
  bool has_chatremoved() const;
  private:
  bool _internal_has_chatremoved() const;
  public:
  void clear_chatremoved();
  const ::ServerData::ChatRemoved& chatremoved() const;
  PROTOBUF_NODISCARD ::ServerData::ChatRemoved* release_chatremoved();
  ::ServerData::ChatRemoved* mutable_chatremoved();
  void set_allocated_chatremoved(::ServerData::ChatRemoved* chatremoved);
  private:
  const ::ServerData::ChatRemoved& _internal_chatremoved() const;
  ::ServerData::ChatRemoved* _internal_mutable_chatremoved();
  public:
  void unsafe_arena_set_allocated_chatremoved(
      ::ServerData::ChatRemoved* chatremoved);
  ::ServerData::ChatRemoved* unsafe_arena_release_chatremoved();

  void clear_Msg();
  MsgCase Msg_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.RelayRemoteMessage)
 private:
  class _Internal;
  void set_has_message();
  void set_has_authenticateresp();
  void set_has_authenticateguestresp();
  void set_has_exitallspacesandlogoutresp();
  void set_has_joinspacefromidresp();
  void set_has_shutdownspaceconnectionresp();
  void set_has_createspaceresp();
  void set_has_getaudioinputdevicesresp();
  void set_has_getaudiooutputdevicesresp();
  void set_has_getvideoinputdevicesresp();
  void set_has_propertyvaluestatus();
  void set_has_localpropertyhandledresp();
  void set_has_propmetadatastatus();
  void set_has_useradded();
  void set_has_userremoved();
  void set_has_uservideoframe();
  void set_has_spaceadded();
  void set_has_spaceupdated();
  void set_has_spaceremoved();
  void set_has_objectadded();
  void set_has_objectremoved();
  void set_has_permissionstatus();
  void set_has_alljoinablespacesresp();
  void set_has_fetchfilebyidprogressresp();
  void set_has_fetchfilebyidcompletedresp();
  void set_has_fetchalluploadedcontentresp();
  void set_has_uploadlocalfileresp();
  void set_has_chatadded();
  void set_has_chatupdated();
  void set_has_chatremoved();

  inline bool has_Msg() const;
  inline void clear_has_Msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::StatusMessage* message_;
      ::ServerData::AuthenticateResp* authenticateresp_;
      ::ServerData::AuthenticateGuestResp* authenticateguestresp_;
      ::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp_;
      ::ServerData::JoinSpaceFromIdResp* joinspacefromidresp_;
      ::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp_;
      ::ServerData::CreateSpaceResp* createspaceresp_;
      ::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp_;
      ::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp_;
      ::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp_;
      ::ServerData::PropertyValueStatus* propertyvaluestatus_;
      ::ServerData::LocalPropertyHandledResp* localpropertyhandledresp_;
      ::ServerData::PropMetadataStatus* propmetadatastatus_;
      ::ServerData::UserAdded* useradded_;
      ::ServerData::UserRemoved* userremoved_;
      ::ServerData::UserVideoFrame* uservideoframe_;
      ::ServerData::SpaceInfo* spaceadded_;
      ::ServerData::SpaceInfo* spaceupdated_;
      ::ServerData::SpaceInfo* spaceremoved_;
      ::ServerData::ObjectAdded* objectadded_;
      ::ServerData::ObjectRemoved* objectremoved_;
      ::ServerData::PermissionStatus* permissionstatus_;
      ::ServerData::AllJoinableSpacesResp* alljoinablespacesresp_;
      ::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp_;
      ::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp_;
      ::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp_;
      ::ServerData::UploadLocalFileResp* uploadlocalfileresp_;
      ::ServerData::ChatAdded* chatadded_;
      ::ServerData::ChatUpdated* chatupdated_;
      ::ServerData::ChatRemoved* chatremoved_;
    } Msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class KeepAlive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerData.KeepAlive) */ {
 public:
  inline KeepAlive() : KeepAlive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR KeepAlive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepAlive(const KeepAlive& from);
  KeepAlive(KeepAlive&& from) noexcept
    : KeepAlive() {
    *this = ::std::move(from);
  }

  inline KeepAlive& operator=(const KeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAlive& operator=(KeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAlive* internal_default_instance() {
    return reinterpret_cast<const KeepAlive*>(
               &_KeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeepAlive& a, KeepAlive& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepAlive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAlive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAlive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepAlive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const KeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const KeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.KeepAlive";
  }
  protected:
  explicit KeepAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerData.KeepAlive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateTime) */ {
 public:
  inline UpdateTime() : UpdateTime(nullptr) {}
  ~UpdateTime() override;
  explicit PROTOBUF_CONSTEXPR UpdateTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTime(const UpdateTime& from);
  UpdateTime(UpdateTime&& from) noexcept
    : UpdateTime() {
    *this = ::std::move(from);
  }

  inline UpdateTime& operator=(const UpdateTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTime& operator=(UpdateTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTime* internal_default_instance() {
    return reinterpret_cast<const UpdateTime*>(
               &_UpdateTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateTime& a, UpdateTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTime& from) {
    UpdateTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateTime";
  }
  protected:
  explicit UpdateTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // double time = 1;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class StatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.StatusMessage) */ {
 public:
  inline StatusMessage() : StatusMessage(nullptr) {}
  ~StatusMessage() override;
  explicit PROTOBUF_CONSTEXPR StatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusMessage(const StatusMessage& from);
  StatusMessage(StatusMessage&& from) noexcept
    : StatusMessage() {
    *this = ::std::move(from);
  }

  inline StatusMessage& operator=(const StatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusMessage& operator=(StatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 1,
    kWarning = 2,
    kLog = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const StatusMessage* internal_default_instance() {
    return reinterpret_cast<const StatusMessage*>(
               &_StatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StatusMessage& a, StatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusMessage& from) {
    StatusMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.StatusMessage";
  }
  protected:
  explicit StatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kWarningFieldNumber = 2,
    kLogFieldNumber = 3,
  };
  // string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string warning = 2;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // string log = 3;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  void clear_Message();
  MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.StatusMessage)
 private:
  class _Internal;
  void set_has_error();
  void set_has_warning();
  void set_has_log();

  inline bool has_Message() const;
  inline void clear_has_Message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
    } Message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateReq) */ {
 public:
  inline AuthenticateReq() : AuthenticateReq(nullptr) {}
  ~AuthenticateReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateReq(const AuthenticateReq& from);
  AuthenticateReq(AuthenticateReq&& from) noexcept
    : AuthenticateReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateReq& operator=(const AuthenticateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateReq& operator=(AuthenticateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateReq*>(
               &_AuthenticateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AuthenticateReq& a, AuthenticateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateReq& from) {
    AuthenticateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateReq";
  }
  protected:
  explicit AuthenticateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kEmailFieldNumber = 11,
    kPasswordFieldNumber = 12,
    kReqIdFieldNumber = 1,
  };
  // string server = 10;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string email = 11;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 12;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateGuestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateGuestReq) */ {
 public:
  inline AuthenticateGuestReq() : AuthenticateGuestReq(nullptr) {}
  ~AuthenticateGuestReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateGuestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateGuestReq(const AuthenticateGuestReq& from);
  AuthenticateGuestReq(AuthenticateGuestReq&& from) noexcept
    : AuthenticateGuestReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateGuestReq& operator=(const AuthenticateGuestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateGuestReq& operator=(AuthenticateGuestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateGuestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateGuestReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateGuestReq*>(
               &_AuthenticateGuestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AuthenticateGuestReq& a, AuthenticateGuestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateGuestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateGuestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateGuestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateGuestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateGuestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateGuestReq& from) {
    AuthenticateGuestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateGuestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateGuestReq";
  }
  protected:
  explicit AuthenticateGuestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kScreenNameFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string server = 10;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string screenName = 11;
  void clear_screenname();
  const std::string& screenname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenname();
  PROTOBUF_NODISCARD std::string* release_screenname();
  void set_allocated_screenname(std::string* screenname);
  private:
  const std::string& _internal_screenname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenname(const std::string& value);
  std::string* _internal_mutable_screenname();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateGuestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenname_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateResp) */ {
 public:
  inline AuthenticateResp() : AuthenticateResp(nullptr) {}
  ~AuthenticateResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResp(const AuthenticateResp& from);
  AuthenticateResp(AuthenticateResp&& from) noexcept
    : AuthenticateResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateResp& operator=(const AuthenticateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResp& operator=(AuthenticateResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kAuth = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const AuthenticateResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResp*>(
               &_AuthenticateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AuthenticateResp& a, AuthenticateResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateResp& from) {
    AuthenticateResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateResp";
  }
  protected:
  explicit AuthenticateResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kAuthFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusAuth auth = 10;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::ServerData::CavrnusAuth& auth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuth* release_auth();
  ::ServerData::CavrnusAuth* mutable_auth();
  void set_allocated_auth(::ServerData::CavrnusAuth* auth);
  private:
  const ::ServerData::CavrnusAuth& _internal_auth() const;
  ::ServerData::CavrnusAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::ServerData::CavrnusAuth* auth);
  ::ServerData::CavrnusAuth* unsafe_arena_release_auth();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateResp)
 private:
  class _Internal;
  void set_has_auth();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusAuth* auth_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateGuestResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateGuestResp) */ {
 public:
  inline AuthenticateGuestResp() : AuthenticateGuestResp(nullptr) {}
  ~AuthenticateGuestResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateGuestResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateGuestResp(const AuthenticateGuestResp& from);
  AuthenticateGuestResp(AuthenticateGuestResp&& from) noexcept
    : AuthenticateGuestResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateGuestResp& operator=(const AuthenticateGuestResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateGuestResp& operator=(AuthenticateGuestResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateGuestResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kAuth = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const AuthenticateGuestResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateGuestResp*>(
               &_AuthenticateGuestResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AuthenticateGuestResp& a, AuthenticateGuestResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateGuestResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateGuestResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateGuestResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateGuestResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateGuestResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateGuestResp& from) {
    AuthenticateGuestResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateGuestResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateGuestResp";
  }
  protected:
  explicit AuthenticateGuestResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kAuthFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusAuth auth = 10;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::ServerData::CavrnusAuth& auth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuth* release_auth();
  ::ServerData::CavrnusAuth* mutable_auth();
  void set_allocated_auth(::ServerData::CavrnusAuth* auth);
  private:
  const ::ServerData::CavrnusAuth& _internal_auth() const;
  ::ServerData::CavrnusAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::ServerData::CavrnusAuth* auth);
  ::ServerData::CavrnusAuth* unsafe_arena_release_auth();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateGuestResp)
 private:
  class _Internal;
  void set_has_auth();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusAuth* auth_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateWithLinkReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateWithLinkReq) */ {
 public:
  inline AuthenticateWithLinkReq() : AuthenticateWithLinkReq(nullptr) {}
  ~AuthenticateWithLinkReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateWithLinkReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateWithLinkReq(const AuthenticateWithLinkReq& from);
  AuthenticateWithLinkReq(AuthenticateWithLinkReq&& from) noexcept
    : AuthenticateWithLinkReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateWithLinkReq& operator=(const AuthenticateWithLinkReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateWithLinkReq& operator=(AuthenticateWithLinkReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateWithLinkReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateWithLinkReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateWithLinkReq*>(
               &_AuthenticateWithLinkReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AuthenticateWithLinkReq& a, AuthenticateWithLinkReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateWithLinkReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateWithLinkReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateWithLinkReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateWithLinkReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateWithLinkReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateWithLinkReq& from) {
    AuthenticateWithLinkReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateWithLinkReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateWithLinkReq";
  }
  protected:
  explicit AuthenticateWithLinkReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string link = 10;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateWithLinkReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateWithLinkResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateWithLinkResp) */ {
 public:
  inline AuthenticateWithLinkResp() : AuthenticateWithLinkResp(nullptr) {}
  ~AuthenticateWithLinkResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateWithLinkResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateWithLinkResp(const AuthenticateWithLinkResp& from);
  AuthenticateWithLinkResp(AuthenticateWithLinkResp&& from) noexcept
    : AuthenticateWithLinkResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateWithLinkResp& operator=(const AuthenticateWithLinkResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateWithLinkResp& operator=(AuthenticateWithLinkResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateWithLinkResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kLinkAuth = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const AuthenticateWithLinkResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateWithLinkResp*>(
               &_AuthenticateWithLinkResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AuthenticateWithLinkResp& a, AuthenticateWithLinkResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateWithLinkResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateWithLinkResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateWithLinkResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateWithLinkResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateWithLinkResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateWithLinkResp& from) {
    AuthenticateWithLinkResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateWithLinkResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateWithLinkResp";
  }
  protected:
  explicit AuthenticateWithLinkResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kLinkAuthFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusAuthLinkResponse linkAuth = 10;
  bool has_linkauth() const;
  private:
  bool _internal_has_linkauth() const;
  public:
  void clear_linkauth();
  const ::ServerData::CavrnusAuthLinkResponse& linkauth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuthLinkResponse* release_linkauth();
  ::ServerData::CavrnusAuthLinkResponse* mutable_linkauth();
  void set_allocated_linkauth(::ServerData::CavrnusAuthLinkResponse* linkauth);
  private:
  const ::ServerData::CavrnusAuthLinkResponse& _internal_linkauth() const;
  ::ServerData::CavrnusAuthLinkResponse* _internal_mutable_linkauth();
  public:
  void unsafe_arena_set_allocated_linkauth(
      ::ServerData::CavrnusAuthLinkResponse* linkauth);
  ::ServerData::CavrnusAuthLinkResponse* unsafe_arena_release_linkauth();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateWithLinkResp)
 private:
  class _Internal;
  void set_has_linkauth();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusAuthLinkResponse* linkauth_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ExitAllSpacesAndLogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ExitAllSpacesAndLogoutReq) */ {
 public:
  inline ExitAllSpacesAndLogoutReq() : ExitAllSpacesAndLogoutReq(nullptr) {}
  ~ExitAllSpacesAndLogoutReq() override;
  explicit PROTOBUF_CONSTEXPR ExitAllSpacesAndLogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExitAllSpacesAndLogoutReq(const ExitAllSpacesAndLogoutReq& from);
  ExitAllSpacesAndLogoutReq(ExitAllSpacesAndLogoutReq&& from) noexcept
    : ExitAllSpacesAndLogoutReq() {
    *this = ::std::move(from);
  }

  inline ExitAllSpacesAndLogoutReq& operator=(const ExitAllSpacesAndLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitAllSpacesAndLogoutReq& operator=(ExitAllSpacesAndLogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitAllSpacesAndLogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExitAllSpacesAndLogoutReq* internal_default_instance() {
    return reinterpret_cast<const ExitAllSpacesAndLogoutReq*>(
               &_ExitAllSpacesAndLogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExitAllSpacesAndLogoutReq& a, ExitAllSpacesAndLogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitAllSpacesAndLogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitAllSpacesAndLogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExitAllSpacesAndLogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExitAllSpacesAndLogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExitAllSpacesAndLogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExitAllSpacesAndLogoutReq& from) {
    ExitAllSpacesAndLogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitAllSpacesAndLogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ExitAllSpacesAndLogoutReq";
  }
  protected:
  explicit ExitAllSpacesAndLogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ExitAllSpacesAndLogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ExitAllSpacesAndLogoutResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ExitAllSpacesAndLogoutResp) */ {
 public:
  inline ExitAllSpacesAndLogoutResp() : ExitAllSpacesAndLogoutResp(nullptr) {}
  ~ExitAllSpacesAndLogoutResp() override;
  explicit PROTOBUF_CONSTEXPR ExitAllSpacesAndLogoutResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExitAllSpacesAndLogoutResp(const ExitAllSpacesAndLogoutResp& from);
  ExitAllSpacesAndLogoutResp(ExitAllSpacesAndLogoutResp&& from) noexcept
    : ExitAllSpacesAndLogoutResp() {
    *this = ::std::move(from);
  }

  inline ExitAllSpacesAndLogoutResp& operator=(const ExitAllSpacesAndLogoutResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitAllSpacesAndLogoutResp& operator=(ExitAllSpacesAndLogoutResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitAllSpacesAndLogoutResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kLogoutSuccess = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const ExitAllSpacesAndLogoutResp* internal_default_instance() {
    return reinterpret_cast<const ExitAllSpacesAndLogoutResp*>(
               &_ExitAllSpacesAndLogoutResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExitAllSpacesAndLogoutResp& a, ExitAllSpacesAndLogoutResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitAllSpacesAndLogoutResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitAllSpacesAndLogoutResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExitAllSpacesAndLogoutResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExitAllSpacesAndLogoutResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExitAllSpacesAndLogoutResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExitAllSpacesAndLogoutResp& from) {
    ExitAllSpacesAndLogoutResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitAllSpacesAndLogoutResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ExitAllSpacesAndLogoutResp";
  }
  protected:
  explicit ExitAllSpacesAndLogoutResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpacesExitedFieldNumber = 20,
    kReqIdFieldNumber = 1,
    kLogoutSuccessFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // repeated int32 spacesExited = 20;
  int spacesexited_size() const;
  private:
  int _internal_spacesexited_size() const;
  public:
  void clear_spacesexited();
  private:
  int32_t _internal_spacesexited(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_spacesexited() const;
  void _internal_add_spacesexited(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_spacesexited();
  public:
  int32_t spacesexited(int index) const;
  void set_spacesexited(int index, int32_t value);
  void add_spacesexited(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      spacesexited() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_spacesexited();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // bool logoutSuccess = 10;
  bool has_logoutsuccess() const;
  private:
  bool _internal_has_logoutsuccess() const;
  public:
  void clear_logoutsuccess();
  bool logoutsuccess() const;
  void set_logoutsuccess(bool value);
  private:
  bool _internal_logoutsuccess() const;
  void _internal_set_logoutsuccess(bool value);
  public:

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.ExitAllSpacesAndLogoutResp)
 private:
  class _Internal;
  void set_has_logoutsuccess();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > spacesexited_;
    mutable std::atomic<int> _spacesexited_cached_byte_size_;
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool logoutsuccess_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class JoinSpaceFromIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.JoinSpaceFromIdReq) */ {
 public:
  inline JoinSpaceFromIdReq() : JoinSpaceFromIdReq(nullptr) {}
  ~JoinSpaceFromIdReq() override;
  explicit PROTOBUF_CONSTEXPR JoinSpaceFromIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinSpaceFromIdReq(const JoinSpaceFromIdReq& from);
  JoinSpaceFromIdReq(JoinSpaceFromIdReq&& from) noexcept
    : JoinSpaceFromIdReq() {
    *this = ::std::move(from);
  }

  inline JoinSpaceFromIdReq& operator=(const JoinSpaceFromIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinSpaceFromIdReq& operator=(JoinSpaceFromIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinSpaceFromIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinSpaceFromIdReq* internal_default_instance() {
    return reinterpret_cast<const JoinSpaceFromIdReq*>(
               &_JoinSpaceFromIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(JoinSpaceFromIdReq& a, JoinSpaceFromIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinSpaceFromIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinSpaceFromIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinSpaceFromIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinSpaceFromIdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinSpaceFromIdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinSpaceFromIdReq& from) {
    JoinSpaceFromIdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinSpaceFromIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.JoinSpaceFromIdReq";
  }
  protected:
  explicit JoinSpaceFromIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.JoinSpaceFromIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class JoinSpaceFromIdResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.JoinSpaceFromIdResp) */ {
 public:
  inline JoinSpaceFromIdResp() : JoinSpaceFromIdResp(nullptr) {}
  ~JoinSpaceFromIdResp() override;
  explicit PROTOBUF_CONSTEXPR JoinSpaceFromIdResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinSpaceFromIdResp(const JoinSpaceFromIdResp& from);
  JoinSpaceFromIdResp(JoinSpaceFromIdResp&& from) noexcept
    : JoinSpaceFromIdResp() {
    *this = ::std::move(from);
  }

  inline JoinSpaceFromIdResp& operator=(const JoinSpaceFromIdResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinSpaceFromIdResp& operator=(JoinSpaceFromIdResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinSpaceFromIdResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kSpaceConn = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const JoinSpaceFromIdResp* internal_default_instance() {
    return reinterpret_cast<const JoinSpaceFromIdResp*>(
               &_JoinSpaceFromIdResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(JoinSpaceFromIdResp& a, JoinSpaceFromIdResp& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinSpaceFromIdResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinSpaceFromIdResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinSpaceFromIdResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinSpaceFromIdResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinSpaceFromIdResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinSpaceFromIdResp& from) {
    JoinSpaceFromIdResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinSpaceFromIdResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.JoinSpaceFromIdResp";
  }
  protected:
  explicit JoinSpaceFromIdResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kSpaceConnFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 10;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.JoinSpaceFromIdResp)
 private:
  class _Internal;
  void set_has_spaceconn();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusSpaceConnection* spaceconn_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ShutdownSpaceConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ShutdownSpaceConnectionReq) */ {
 public:
  inline ShutdownSpaceConnectionReq() : ShutdownSpaceConnectionReq(nullptr) {}
  ~ShutdownSpaceConnectionReq() override;
  explicit PROTOBUF_CONSTEXPR ShutdownSpaceConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownSpaceConnectionReq(const ShutdownSpaceConnectionReq& from);
  ShutdownSpaceConnectionReq(ShutdownSpaceConnectionReq&& from) noexcept
    : ShutdownSpaceConnectionReq() {
    *this = ::std::move(from);
  }

  inline ShutdownSpaceConnectionReq& operator=(const ShutdownSpaceConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownSpaceConnectionReq& operator=(ShutdownSpaceConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownSpaceConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownSpaceConnectionReq* internal_default_instance() {
    return reinterpret_cast<const ShutdownSpaceConnectionReq*>(
               &_ShutdownSpaceConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ShutdownSpaceConnectionReq& a, ShutdownSpaceConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownSpaceConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownSpaceConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownSpaceConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownSpaceConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownSpaceConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownSpaceConnectionReq& from) {
    ShutdownSpaceConnectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownSpaceConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ShutdownSpaceConnectionReq";
  }
  protected:
  explicit ShutdownSpaceConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnectionFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusSpaceConnection SpaceConnection = 10;
  bool has_spaceconnection() const;
  private:
  bool _internal_has_spaceconnection() const;
  public:
  void clear_spaceconnection();
  const ::ServerData::CavrnusSpaceConnection& spaceconnection() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconnection();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconnection();
  void set_allocated_spaceconnection(::ServerData::CavrnusSpaceConnection* spaceconnection);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconnection() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconnection();
  public:
  void unsafe_arena_set_allocated_spaceconnection(
      ::ServerData::CavrnusSpaceConnection* spaceconnection);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconnection();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ShutdownSpaceConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconnection_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ShutdownSpaceConnectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ShutdownSpaceConnectionResp) */ {
 public:
  inline ShutdownSpaceConnectionResp() : ShutdownSpaceConnectionResp(nullptr) {}
  ~ShutdownSpaceConnectionResp() override;
  explicit PROTOBUF_CONSTEXPR ShutdownSpaceConnectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownSpaceConnectionResp(const ShutdownSpaceConnectionResp& from);
  ShutdownSpaceConnectionResp(ShutdownSpaceConnectionResp&& from) noexcept
    : ShutdownSpaceConnectionResp() {
    *this = ::std::move(from);
  }

  inline ShutdownSpaceConnectionResp& operator=(const ShutdownSpaceConnectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownSpaceConnectionResp& operator=(ShutdownSpaceConnectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownSpaceConnectionResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kSpaceConn = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const ShutdownSpaceConnectionResp* internal_default_instance() {
    return reinterpret_cast<const ShutdownSpaceConnectionResp*>(
               &_ShutdownSpaceConnectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ShutdownSpaceConnectionResp& a, ShutdownSpaceConnectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownSpaceConnectionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownSpaceConnectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownSpaceConnectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownSpaceConnectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownSpaceConnectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownSpaceConnectionResp& from) {
    ShutdownSpaceConnectionResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownSpaceConnectionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ShutdownSpaceConnectionResp";
  }
  protected:
  explicit ShutdownSpaceConnectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kSpaceConnFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 10;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.ShutdownSpaceConnectionResp)
 private:
  class _Internal;
  void set_has_spaceconn();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusSpaceConnection* spaceconn_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CreateSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CreateSpaceReq) */ {
 public:
  inline CreateSpaceReq() : CreateSpaceReq(nullptr) {}
  ~CreateSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR CreateSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSpaceReq(const CreateSpaceReq& from);
  CreateSpaceReq(CreateSpaceReq&& from) noexcept
    : CreateSpaceReq() {
    *this = ::std::move(from);
  }

  inline CreateSpaceReq& operator=(const CreateSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSpaceReq& operator=(CreateSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSpaceReq* internal_default_instance() {
    return reinterpret_cast<const CreateSpaceReq*>(
               &_CreateSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateSpaceReq& a, CreateSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSpaceReq& from) {
    CreateSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CreateSpaceReq";
  }
  protected:
  explicit CreateSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewSpaceNameFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string newSpaceName = 10;
  void clear_newspacename();
  const std::string& newspacename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newspacename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newspacename();
  PROTOBUF_NODISCARD std::string* release_newspacename();
  void set_allocated_newspacename(std::string* newspacename);
  private:
  const std::string& _internal_newspacename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newspacename(const std::string& value);
  std::string* _internal_mutable_newspacename();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CreateSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newspacename_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CreateSpaceResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CreateSpaceResp) */ {
 public:
  inline CreateSpaceResp() : CreateSpaceResp(nullptr) {}
  ~CreateSpaceResp() override;
  explicit PROTOBUF_CONSTEXPR CreateSpaceResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSpaceResp(const CreateSpaceResp& from);
  CreateSpaceResp(CreateSpaceResp&& from) noexcept
    : CreateSpaceResp() {
    *this = ::std::move(from);
  }

  inline CreateSpaceResp& operator=(const CreateSpaceResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSpaceResp& operator=(CreateSpaceResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSpaceResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kNewSpaceInfo = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const CreateSpaceResp* internal_default_instance() {
    return reinterpret_cast<const CreateSpaceResp*>(
               &_CreateSpaceResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateSpaceResp& a, CreateSpaceResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSpaceResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSpaceResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSpaceResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSpaceResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSpaceResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSpaceResp& from) {
    CreateSpaceResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSpaceResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CreateSpaceResp";
  }
  protected:
  explicit CreateSpaceResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kNewSpaceInfoFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.SpaceInfo newSpaceInfo = 10;
  bool has_newspaceinfo() const;
  private:
  bool _internal_has_newspaceinfo() const;
  public:
  void clear_newspaceinfo();
  const ::ServerData::SpaceInfo& newspaceinfo() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_newspaceinfo();
  ::ServerData::SpaceInfo* mutable_newspaceinfo();
  void set_allocated_newspaceinfo(::ServerData::SpaceInfo* newspaceinfo);
  private:
  const ::ServerData::SpaceInfo& _internal_newspaceinfo() const;
  ::ServerData::SpaceInfo* _internal_mutable_newspaceinfo();
  public:
  void unsafe_arena_set_allocated_newspaceinfo(
      ::ServerData::SpaceInfo* newspaceinfo);
  ::ServerData::SpaceInfo* unsafe_arena_release_newspaceinfo();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.CreateSpaceResp)
 private:
  class _Internal;
  void set_has_newspaceinfo();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::SpaceInfo* newspaceinfo_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropertyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropertyValue) */ {
 public:
  inline PropertyValue() : PropertyValue(nullptr) {}
  ~PropertyValue() override;
  explicit PROTOBUF_CONSTEXPR PropertyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyValue(const PropertyValue& from);
  PropertyValue(PropertyValue&& from) noexcept
    : PropertyValue() {
    *this = ::std::move(from);
  }

  inline PropertyValue& operator=(const PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyValue& operator=(PropertyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kBoolVal = 10,
    kStringVal = 11,
    kScalarVal = 12,
    kVectorVal = 13,
    kColorVal = 14,
    kTransformVal = 17,
    kLinkVal = 15,
    VALUE_NOT_SET = 0,
  };

  static inline const PropertyValue* internal_default_instance() {
    return reinterpret_cast<const PropertyValue*>(
               &_PropertyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PropertyValue& a, PropertyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyValue& from) {
    PropertyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropertyValue";
  }
  protected:
  explicit PropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolValFieldNumber = 10,
    kStringValFieldNumber = 11,
    kScalarValFieldNumber = 12,
    kVectorValFieldNumber = 13,
    kColorValFieldNumber = 14,
    kTransformValFieldNumber = 17,
    kLinkValFieldNumber = 15,
  };
  // bool boolVal = 10;
  bool has_boolval() const;
  private:
  bool _internal_has_boolval() const;
  public:
  void clear_boolval();
  bool boolval() const;
  void set_boolval(bool value);
  private:
  bool _internal_boolval() const;
  void _internal_set_boolval(bool value);
  public:

  // string stringVal = 11;
  bool has_stringval() const;
  private:
  bool _internal_has_stringval() const;
  public:
  void clear_stringval();
  const std::string& stringval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringval();
  PROTOBUF_NODISCARD std::string* release_stringval();
  void set_allocated_stringval(std::string* stringval);
  private:
  const std::string& _internal_stringval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringval(const std::string& value);
  std::string* _internal_mutable_stringval();
  public:

  // float scalarVal = 12;
  bool has_scalarval() const;
  private:
  bool _internal_has_scalarval() const;
  public:
  void clear_scalarval();
  float scalarval() const;
  void set_scalarval(float value);
  private:
  float _internal_scalarval() const;
  void _internal_set_scalarval(float value);
  public:

  // .Common.Float4 vectorVal = 13;
  bool has_vectorval() const;
  private:
  bool _internal_has_vectorval() const;
  public:
  void clear_vectorval();
  const ::Common::Float4& vectorval() const;
  PROTOBUF_NODISCARD ::Common::Float4* release_vectorval();
  ::Common::Float4* mutable_vectorval();
  void set_allocated_vectorval(::Common::Float4* vectorval);
  private:
  const ::Common::Float4& _internal_vectorval() const;
  ::Common::Float4* _internal_mutable_vectorval();
  public:
  void unsafe_arena_set_allocated_vectorval(
      ::Common::Float4* vectorval);
  ::Common::Float4* unsafe_arena_release_vectorval();

  // .Common.Color4 colorVal = 14;
  bool has_colorval() const;
  private:
  bool _internal_has_colorval() const;
  public:
  void clear_colorval();
  const ::Common::Color4& colorval() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_colorval();
  ::Common::Color4* mutable_colorval();
  void set_allocated_colorval(::Common::Color4* colorval);
  private:
  const ::Common::Color4& _internal_colorval() const;
  ::Common::Color4* _internal_mutable_colorval();
  public:
  void unsafe_arena_set_allocated_colorval(
      ::Common::Color4* colorval);
  ::Common::Color4* unsafe_arena_release_colorval();

  // .ServerData.TransformPropertyValue transformVal = 17;
  bool has_transformval() const;
  private:
  bool _internal_has_transformval() const;
  public:
  void clear_transformval();
  const ::ServerData::TransformPropertyValue& transformval() const;
  PROTOBUF_NODISCARD ::ServerData::TransformPropertyValue* release_transformval();
  ::ServerData::TransformPropertyValue* mutable_transformval();
  void set_allocated_transformval(::ServerData::TransformPropertyValue* transformval);
  private:
  const ::ServerData::TransformPropertyValue& _internal_transformval() const;
  ::ServerData::TransformPropertyValue* _internal_mutable_transformval();
  public:
  void unsafe_arena_set_allocated_transformval(
      ::ServerData::TransformPropertyValue* transformval);
  ::ServerData::TransformPropertyValue* unsafe_arena_release_transformval();

  // .Property.PropertyIdentifier linkVal = 15;
  bool has_linkval() const;
  private:
  bool _internal_has_linkval() const;
  public:
  void clear_linkval();
  const ::Property::PropertyIdentifier& linkval() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_linkval();
  ::Property::PropertyIdentifier* mutable_linkval();
  void set_allocated_linkval(::Property::PropertyIdentifier* linkval);
  private:
  const ::Property::PropertyIdentifier& _internal_linkval() const;
  ::Property::PropertyIdentifier* _internal_mutable_linkval();
  public:
  void unsafe_arena_set_allocated_linkval(
      ::Property::PropertyIdentifier* linkval);
  ::Property::PropertyIdentifier* unsafe_arena_release_linkval();

  void clear_Value();
  ValueCase Value_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.PropertyValue)
 private:
  class _Internal;
  void set_has_boolval();
  void set_has_stringval();
  void set_has_scalarval();
  void set_has_vectorval();
  void set_has_colorval();
  void set_has_transformval();
  void set_has_linkval();

  inline bool has_Value() const;
  inline void clear_has_Value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool boolval_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringval_;
      float scalarval_;
      ::Common::Float4* vectorval_;
      ::Common::Color4* colorval_;
      ::ServerData::TransformPropertyValue* transformval_;
      ::Property::PropertyIdentifier* linkval_;
    } Value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class DefinePropertyDefaultValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.DefinePropertyDefaultValue) */ {
 public:
  inline DefinePropertyDefaultValue() : DefinePropertyDefaultValue(nullptr) {}
  ~DefinePropertyDefaultValue() override;
  explicit PROTOBUF_CONSTEXPR DefinePropertyDefaultValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefinePropertyDefaultValue(const DefinePropertyDefaultValue& from);
  DefinePropertyDefaultValue(DefinePropertyDefaultValue&& from) noexcept
    : DefinePropertyDefaultValue() {
    *this = ::std::move(from);
  }

  inline DefinePropertyDefaultValue& operator=(const DefinePropertyDefaultValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefinePropertyDefaultValue& operator=(DefinePropertyDefaultValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefinePropertyDefaultValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefinePropertyDefaultValue* internal_default_instance() {
    return reinterpret_cast<const DefinePropertyDefaultValue*>(
               &_DefinePropertyDefaultValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DefinePropertyDefaultValue& a, DefinePropertyDefaultValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DefinePropertyDefaultValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefinePropertyDefaultValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefinePropertyDefaultValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefinePropertyDefaultValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefinePropertyDefaultValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefinePropertyDefaultValue& from) {
    DefinePropertyDefaultValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefinePropertyDefaultValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.DefinePropertyDefaultValue";
  }
  protected:
  explicit DefinePropertyDefaultValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 3,
  };
  // string PropertyId = 2;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 3;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.DefinePropertyDefaultValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostPropertyUpdate) */ {
 public:
  inline PostPropertyUpdate() : PostPropertyUpdate(nullptr) {}
  ~PostPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR PostPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostPropertyUpdate(const PostPropertyUpdate& from);
  PostPropertyUpdate(PostPropertyUpdate&& from) noexcept
    : PostPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline PostPropertyUpdate& operator=(const PostPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostPropertyUpdate& operator=(PostPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const PostPropertyUpdate*>(
               &_PostPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PostPropertyUpdate& a, PostPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PostPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostPropertyUpdate& from) {
    PostPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostPropertyUpdate";
  }
  protected:
  explicit PostPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PostPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class BeginTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.BeginTransientPropertyUpdate) */ {
 public:
  inline BeginTransientPropertyUpdate() : BeginTransientPropertyUpdate(nullptr) {}
  ~BeginTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR BeginTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginTransientPropertyUpdate(const BeginTransientPropertyUpdate& from);
  BeginTransientPropertyUpdate(BeginTransientPropertyUpdate&& from) noexcept
    : BeginTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline BeginTransientPropertyUpdate& operator=(const BeginTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginTransientPropertyUpdate& operator=(BeginTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const BeginTransientPropertyUpdate*>(
               &_BeginTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BeginTransientPropertyUpdate& a, BeginTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginTransientPropertyUpdate& from) {
    BeginTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.BeginTransientPropertyUpdate";
  }
  protected:
  explicit BeginTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.BeginTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ContinueTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ContinueTransientPropertyUpdate) */ {
 public:
  inline ContinueTransientPropertyUpdate() : ContinueTransientPropertyUpdate(nullptr) {}
  ~ContinueTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR ContinueTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContinueTransientPropertyUpdate(const ContinueTransientPropertyUpdate& from);
  ContinueTransientPropertyUpdate(ContinueTransientPropertyUpdate&& from) noexcept
    : ContinueTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline ContinueTransientPropertyUpdate& operator=(const ContinueTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueTransientPropertyUpdate& operator=(ContinueTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const ContinueTransientPropertyUpdate*>(
               &_ContinueTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ContinueTransientPropertyUpdate& a, ContinueTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContinueTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContinueTransientPropertyUpdate& from) {
    ContinueTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinueTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ContinueTransientPropertyUpdate";
  }
  protected:
  explicit ContinueTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ContinueTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FinalizeTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FinalizeTransientPropertyUpdate) */ {
 public:
  inline FinalizeTransientPropertyUpdate() : FinalizeTransientPropertyUpdate(nullptr) {}
  ~FinalizeTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR FinalizeTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinalizeTransientPropertyUpdate(const FinalizeTransientPropertyUpdate& from);
  FinalizeTransientPropertyUpdate(FinalizeTransientPropertyUpdate&& from) noexcept
    : FinalizeTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline FinalizeTransientPropertyUpdate& operator=(const FinalizeTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeTransientPropertyUpdate& operator=(FinalizeTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalizeTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinalizeTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const FinalizeTransientPropertyUpdate*>(
               &_FinalizeTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FinalizeTransientPropertyUpdate& a, FinalizeTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(FinalizeTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalizeTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinalizeTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinalizeTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinalizeTransientPropertyUpdate& from) {
    FinalizeTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FinalizeTransientPropertyUpdate";
  }
  protected:
  explicit FinalizeTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FinalizeTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CancelTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CancelTransientPropertyUpdate) */ {
 public:
  inline CancelTransientPropertyUpdate() : CancelTransientPropertyUpdate(nullptr) {}
  ~CancelTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR CancelTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelTransientPropertyUpdate(const CancelTransientPropertyUpdate& from);
  CancelTransientPropertyUpdate(CancelTransientPropertyUpdate&& from) noexcept
    : CancelTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline CancelTransientPropertyUpdate& operator=(const CancelTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelTransientPropertyUpdate& operator=(CancelTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const CancelTransientPropertyUpdate*>(
               &_CancelTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CancelTransientPropertyUpdate& a, CancelTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelTransientPropertyUpdate& from) {
    CancelTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CancelTransientPropertyUpdate";
  }
  protected:
  explicit CancelTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.CancelTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class TransformPropertyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.TransformPropertyValue) */ {
 public:
  inline TransformPropertyValue() : TransformPropertyValue(nullptr) {}
  ~TransformPropertyValue() override;
  explicit PROTOBUF_CONSTEXPR TransformPropertyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformPropertyValue(const TransformPropertyValue& from);
  TransformPropertyValue(TransformPropertyValue&& from) noexcept
    : TransformPropertyValue() {
    *this = ::std::move(from);
  }

  inline TransformPropertyValue& operator=(const TransformPropertyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformPropertyValue& operator=(TransformPropertyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformPropertyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformPropertyValue* internal_default_instance() {
    return reinterpret_cast<const TransformPropertyValue*>(
               &_TransformPropertyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TransformPropertyValue& a, TransformPropertyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformPropertyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformPropertyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformPropertyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformPropertyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformPropertyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformPropertyValue& from) {
    TransformPropertyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformPropertyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.TransformPropertyValue";
  }
  protected:
  explicit TransformPropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kRotFieldNumber = 2,
    kSclFieldNumber = 3,
  };
  // .Common.Float3 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Common::Float3& pos() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_pos();
  ::Common::Float3* mutable_pos();
  void set_allocated_pos(::Common::Float3* pos);
  private:
  const ::Common::Float3& _internal_pos() const;
  ::Common::Float3* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Common::Float3* pos);
  ::Common::Float3* unsafe_arena_release_pos();

  // .Common.Float3 rot = 2;
  bool has_rot() const;
  private:
  bool _internal_has_rot() const;
  public:
  void clear_rot();
  const ::Common::Float3& rot() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_rot();
  ::Common::Float3* mutable_rot();
  void set_allocated_rot(::Common::Float3* rot);
  private:
  const ::Common::Float3& _internal_rot() const;
  ::Common::Float3* _internal_mutable_rot();
  public:
  void unsafe_arena_set_allocated_rot(
      ::Common::Float3* rot);
  ::Common::Float3* unsafe_arena_release_rot();

  // .Common.Float3 scl = 3;
  bool has_scl() const;
  private:
  bool _internal_has_scl() const;
  public:
  void clear_scl();
  const ::Common::Float3& scl() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_scl();
  ::Common::Float3* mutable_scl();
  void set_allocated_scl(::Common::Float3* scl);
  private:
  const ::Common::Float3& _internal_scl() const;
  ::Common::Float3* _internal_mutable_scl();
  public:
  void unsafe_arena_set_allocated_scl(
      ::Common::Float3* scl);
  ::Common::Float3* unsafe_arena_release_scl();

  // @@protoc_insertion_point(class_scope:ServerData.TransformPropertyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float3* pos_;
    ::Common::Float3* rot_;
    ::Common::Float3* scl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioInputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioInputDevicesReq) */ {
 public:
  inline GetAudioInputDevicesReq() : GetAudioInputDevicesReq(nullptr) {}
  ~GetAudioInputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetAudioInputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioInputDevicesReq(const GetAudioInputDevicesReq& from);
  GetAudioInputDevicesReq(GetAudioInputDevicesReq&& from) noexcept
    : GetAudioInputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetAudioInputDevicesReq& operator=(const GetAudioInputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioInputDevicesReq& operator=(GetAudioInputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioInputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioInputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetAudioInputDevicesReq*>(
               &_GetAudioInputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetAudioInputDevicesReq& a, GetAudioInputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioInputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioInputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioInputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioInputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioInputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioInputDevicesReq& from) {
    GetAudioInputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioInputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioInputDevicesReq";
  }
  protected:
  explicit GetAudioInputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioInputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioOutputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioOutputDevicesReq) */ {
 public:
  inline GetAudioOutputDevicesReq() : GetAudioOutputDevicesReq(nullptr) {}
  ~GetAudioOutputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetAudioOutputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioOutputDevicesReq(const GetAudioOutputDevicesReq& from);
  GetAudioOutputDevicesReq(GetAudioOutputDevicesReq&& from) noexcept
    : GetAudioOutputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetAudioOutputDevicesReq& operator=(const GetAudioOutputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioOutputDevicesReq& operator=(GetAudioOutputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioOutputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioOutputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetAudioOutputDevicesReq*>(
               &_GetAudioOutputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetAudioOutputDevicesReq& a, GetAudioOutputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioOutputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioOutputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioOutputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioOutputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioOutputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioOutputDevicesReq& from) {
    GetAudioOutputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioOutputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioOutputDevicesReq";
  }
  protected:
  explicit GetAudioOutputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioOutputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetVideoInputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetVideoInputDevicesReq) */ {
 public:
  inline GetVideoInputDevicesReq() : GetVideoInputDevicesReq(nullptr) {}
  ~GetVideoInputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetVideoInputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoInputDevicesReq(const GetVideoInputDevicesReq& from);
  GetVideoInputDevicesReq(GetVideoInputDevicesReq&& from) noexcept
    : GetVideoInputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetVideoInputDevicesReq& operator=(const GetVideoInputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoInputDevicesReq& operator=(GetVideoInputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoInputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVideoInputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetVideoInputDevicesReq*>(
               &_GetVideoInputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetVideoInputDevicesReq& a, GetVideoInputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoInputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoInputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoInputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoInputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVideoInputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVideoInputDevicesReq& from) {
    GetVideoInputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVideoInputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetVideoInputDevicesReq";
  }
  protected:
  explicit GetVideoInputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetVideoInputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioInputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioInputDevicesResp) */ {
 public:
  inline GetAudioInputDevicesResp() : GetAudioInputDevicesResp(nullptr) {}
  ~GetAudioInputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetAudioInputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioInputDevicesResp(const GetAudioInputDevicesResp& from);
  GetAudioInputDevicesResp(GetAudioInputDevicesResp&& from) noexcept
    : GetAudioInputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetAudioInputDevicesResp& operator=(const GetAudioInputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioInputDevicesResp& operator=(GetAudioInputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioInputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kDevices = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const GetAudioInputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetAudioInputDevicesResp*>(
               &_GetAudioInputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetAudioInputDevicesResp& a, GetAudioInputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioInputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioInputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioInputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioInputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioInputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioInputDevicesResp& from) {
    GetAudioInputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioInputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioInputDevicesResp";
  }
  protected:
  explicit GetAudioInputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kDevicesFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.RtcAudioInputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcAudioInputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioInputDeviceList* release_devices();
  ::ServerData::RtcAudioInputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcAudioInputDeviceList* devices);
  private:
  const ::ServerData::RtcAudioInputDeviceList& _internal_devices() const;
  ::ServerData::RtcAudioInputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcAudioInputDeviceList* devices);
  ::ServerData::RtcAudioInputDeviceList* unsafe_arena_release_devices();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.GetAudioInputDevicesResp)
 private:
  class _Internal;
  void set_has_devices();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::RtcAudioInputDeviceList* devices_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioOutputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioOutputDevicesResp) */ {
 public:
  inline GetAudioOutputDevicesResp() : GetAudioOutputDevicesResp(nullptr) {}
  ~GetAudioOutputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetAudioOutputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioOutputDevicesResp(const GetAudioOutputDevicesResp& from);
  GetAudioOutputDevicesResp(GetAudioOutputDevicesResp&& from) noexcept
    : GetAudioOutputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetAudioOutputDevicesResp& operator=(const GetAudioOutputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioOutputDevicesResp& operator=(GetAudioOutputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioOutputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kDevices = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const GetAudioOutputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetAudioOutputDevicesResp*>(
               &_GetAudioOutputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetAudioOutputDevicesResp& a, GetAudioOutputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioOutputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioOutputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioOutputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioOutputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioOutputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioOutputDevicesResp& from) {
    GetAudioOutputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioOutputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioOutputDevicesResp";
  }
  protected:
  explicit GetAudioOutputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kDevicesFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.RtcAudioOutputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcAudioOutputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioOutputDeviceList* release_devices();
  ::ServerData::RtcAudioOutputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcAudioOutputDeviceList* devices);
  private:
  const ::ServerData::RtcAudioOutputDeviceList& _internal_devices() const;
  ::ServerData::RtcAudioOutputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcAudioOutputDeviceList* devices);
  ::ServerData::RtcAudioOutputDeviceList* unsafe_arena_release_devices();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.GetAudioOutputDevicesResp)
 private:
  class _Internal;
  void set_has_devices();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::RtcAudioOutputDeviceList* devices_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetVideoInputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetVideoInputDevicesResp) */ {
 public:
  inline GetVideoInputDevicesResp() : GetVideoInputDevicesResp(nullptr) {}
  ~GetVideoInputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetVideoInputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoInputDevicesResp(const GetVideoInputDevicesResp& from);
  GetVideoInputDevicesResp(GetVideoInputDevicesResp&& from) noexcept
    : GetVideoInputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetVideoInputDevicesResp& operator=(const GetVideoInputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoInputDevicesResp& operator=(GetVideoInputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoInputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kDevices = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const GetVideoInputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetVideoInputDevicesResp*>(
               &_GetVideoInputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetVideoInputDevicesResp& a, GetVideoInputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoInputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoInputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoInputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoInputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVideoInputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVideoInputDevicesResp& from) {
    GetVideoInputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVideoInputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetVideoInputDevicesResp";
  }
  protected:
  explicit GetVideoInputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kDevicesFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.RtcVideoInputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcVideoInputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcVideoInputDeviceList* release_devices();
  ::ServerData::RtcVideoInputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcVideoInputDeviceList* devices);
  private:
  const ::ServerData::RtcVideoInputDeviceList& _internal_devices() const;
  ::ServerData::RtcVideoInputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcVideoInputDeviceList* devices);
  ::ServerData::RtcVideoInputDeviceList* unsafe_arena_release_devices();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.GetVideoInputDevicesResp)
 private:
  class _Internal;
  void set_has_devices();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::RtcVideoInputDeviceList* devices_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetAudioInputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetAudioInputDeviceReq) */ {
 public:
  inline SetAudioInputDeviceReq() : SetAudioInputDeviceReq(nullptr) {}
  ~SetAudioInputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetAudioInputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioInputDeviceReq(const SetAudioInputDeviceReq& from);
  SetAudioInputDeviceReq(SetAudioInputDeviceReq&& from) noexcept
    : SetAudioInputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetAudioInputDeviceReq& operator=(const SetAudioInputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioInputDeviceReq& operator=(SetAudioInputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioInputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioInputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetAudioInputDeviceReq*>(
               &_SetAudioInputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SetAudioInputDeviceReq& a, SetAudioInputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioInputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioInputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioInputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioInputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAudioInputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAudioInputDeviceReq& from) {
    SetAudioInputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAudioInputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetAudioInputDeviceReq";
  }
  protected:
  explicit SetAudioInputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioInputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcAudioInputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioInputDevice* release_device();
  ::ServerData::RtcAudioInputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcAudioInputDevice* device);
  private:
  const ::ServerData::RtcAudioInputDevice& _internal_device() const;
  ::ServerData::RtcAudioInputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcAudioInputDevice* device);
  ::ServerData::RtcAudioInputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetAudioInputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioInputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetAudioOutputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetAudioOutputDeviceReq) */ {
 public:
  inline SetAudioOutputDeviceReq() : SetAudioOutputDeviceReq(nullptr) {}
  ~SetAudioOutputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetAudioOutputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioOutputDeviceReq(const SetAudioOutputDeviceReq& from);
  SetAudioOutputDeviceReq(SetAudioOutputDeviceReq&& from) noexcept
    : SetAudioOutputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetAudioOutputDeviceReq& operator=(const SetAudioOutputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioOutputDeviceReq& operator=(SetAudioOutputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioOutputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioOutputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetAudioOutputDeviceReq*>(
               &_SetAudioOutputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SetAudioOutputDeviceReq& a, SetAudioOutputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioOutputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioOutputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioOutputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioOutputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAudioOutputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAudioOutputDeviceReq& from) {
    SetAudioOutputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAudioOutputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetAudioOutputDeviceReq";
  }
  protected:
  explicit SetAudioOutputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioOutputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcAudioOutputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioOutputDevice* release_device();
  ::ServerData::RtcAudioOutputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcAudioOutputDevice* device);
  private:
  const ::ServerData::RtcAudioOutputDevice& _internal_device() const;
  ::ServerData::RtcAudioOutputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcAudioOutputDevice* device);
  ::ServerData::RtcAudioOutputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetAudioOutputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioOutputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetVideoInputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetVideoInputDeviceReq) */ {
 public:
  inline SetVideoInputDeviceReq() : SetVideoInputDeviceReq(nullptr) {}
  ~SetVideoInputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetVideoInputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoInputDeviceReq(const SetVideoInputDeviceReq& from);
  SetVideoInputDeviceReq(SetVideoInputDeviceReq&& from) noexcept
    : SetVideoInputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetVideoInputDeviceReq& operator=(const SetVideoInputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoInputDeviceReq& operator=(SetVideoInputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoInputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoInputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetVideoInputDeviceReq*>(
               &_SetVideoInputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SetVideoInputDeviceReq& a, SetVideoInputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoInputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoInputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoInputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoInputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVideoInputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVideoInputDeviceReq& from) {
    SetVideoInputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVideoInputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetVideoInputDeviceReq";
  }
  protected:
  explicit SetVideoInputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcVideoInputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcVideoInputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcVideoInputDevice* release_device();
  ::ServerData::RtcVideoInputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcVideoInputDevice* device);
  private:
  const ::ServerData::RtcVideoInputDevice& _internal_device() const;
  ::ServerData::RtcVideoInputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcVideoInputDevice* device);
  ::ServerData::RtcVideoInputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetVideoInputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcVideoInputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostCreateObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostCreateObject) */ {
 public:
  inline PostCreateObject() : PostCreateObject(nullptr) {}
  ~PostCreateObject() override;
  explicit PROTOBUF_CONSTEXPR PostCreateObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostCreateObject(const PostCreateObject& from);
  PostCreateObject(PostCreateObject&& from) noexcept
    : PostCreateObject() {
    *this = ::std::move(from);
  }

  inline PostCreateObject& operator=(const PostCreateObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostCreateObject& operator=(PostCreateObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostCreateObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostCreateObject* internal_default_instance() {
    return reinterpret_cast<const PostCreateObject*>(
               &_PostCreateObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(PostCreateObject& a, PostCreateObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PostCreateObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostCreateObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostCreateObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostCreateObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostCreateObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostCreateObject& from) {
    PostCreateObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostCreateObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostCreateObject";
  }
  protected:
  explicit PostCreateObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewInstanceIdFieldNumber = 2,
    kUniqueObjectIdentFieldNumber = 10,
    kSpaceConnFieldNumber = 1,
  };
  // string newInstanceId = 2;
  void clear_newinstanceid();
  const std::string& newinstanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newinstanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newinstanceid();
  PROTOBUF_NODISCARD std::string* release_newinstanceid();
  void set_allocated_newinstanceid(std::string* newinstanceid);
  private:
  const std::string& _internal_newinstanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newinstanceid(const std::string& value);
  std::string* _internal_mutable_newinstanceid();
  public:

  // string uniqueObjectIdent = 10;
  void clear_uniqueobjectident();
  const std::string& uniqueobjectident() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueobjectident(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueobjectident();
  PROTOBUF_NODISCARD std::string* release_uniqueobjectident();
  void set_allocated_uniqueobjectident(std::string* uniqueobjectident);
  private:
  const std::string& _internal_uniqueobjectident() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueobjectident(const std::string& value);
  std::string* _internal_mutable_uniqueobjectident();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PostCreateObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newinstanceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueobjectident_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostRemoveObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostRemoveObject) */ {
 public:
  inline PostRemoveObject() : PostRemoveObject(nullptr) {}
  ~PostRemoveObject() override;
  explicit PROTOBUF_CONSTEXPR PostRemoveObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostRemoveObject(const PostRemoveObject& from);
  PostRemoveObject(PostRemoveObject&& from) noexcept
    : PostRemoveObject() {
    *this = ::std::move(from);
  }

  inline PostRemoveObject& operator=(const PostRemoveObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostRemoveObject& operator=(PostRemoveObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostRemoveObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostRemoveObject* internal_default_instance() {
    return reinterpret_cast<const PostRemoveObject*>(
               &_PostRemoveObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(PostRemoveObject& a, PostRemoveObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PostRemoveObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostRemoveObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostRemoveObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostRemoveObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostRemoveObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostRemoveObject& from) {
    PostRemoveObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostRemoveObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostRemoveObject";
  }
  protected:
  explicit PostRemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string containerId = 2;
  void clear_containerid();
  const std::string& containerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_containerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_containerid();
  PROTOBUF_NODISCARD std::string* release_containerid();
  void set_allocated_containerid(std::string* containerid);
  private:
  const std::string& _internal_containerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_containerid(const std::string& value);
  std::string* _internal_mutable_containerid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PostRemoveObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr containerid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdReq) */ {
 public:
  inline FetchFileByIdReq() : FetchFileByIdReq(nullptr) {}
  ~FetchFileByIdReq() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdReq(const FetchFileByIdReq& from);
  FetchFileByIdReq(FetchFileByIdReq&& from) noexcept
    : FetchFileByIdReq() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdReq& operator=(const FetchFileByIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdReq& operator=(FetchFileByIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdReq* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdReq*>(
               &_FetchFileByIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FetchFileByIdReq& a, FetchFileByIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdReq& from) {
    FetchFileByIdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdReq";
  }
  protected:
  explicit FetchFileByIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdProgressResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdProgressResp) */ {
 public:
  inline FetchFileByIdProgressResp() : FetchFileByIdProgressResp(nullptr) {}
  ~FetchFileByIdProgressResp() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdProgressResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdProgressResp(const FetchFileByIdProgressResp& from);
  FetchFileByIdProgressResp(FetchFileByIdProgressResp&& from) noexcept
    : FetchFileByIdProgressResp() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdProgressResp& operator=(const FetchFileByIdProgressResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdProgressResp& operator=(FetchFileByIdProgressResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdProgressResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdProgressResp* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdProgressResp*>(
               &_FetchFileByIdProgressResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FetchFileByIdProgressResp& a, FetchFileByIdProgressResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdProgressResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdProgressResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdProgressResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdProgressResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdProgressResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdProgressResp& from) {
    FetchFileByIdProgressResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdProgressResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdProgressResp";
  }
  protected:
  explicit FetchFileByIdProgressResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kProgressStepFieldNumber = 11,
    kProgressFieldNumber = 10,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string progressStep = 11;
  void clear_progressstep();
  const std::string& progressstep() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_progressstep(ArgT0&& arg0, ArgT... args);
  std::string* mutable_progressstep();
  PROTOBUF_NODISCARD std::string* release_progressstep();
  void set_allocated_progressstep(std::string* progressstep);
  private:
  const std::string& _internal_progressstep() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_progressstep(const std::string& value);
  std::string* _internal_mutable_progressstep();
  public:

  // float progress = 10;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdProgressResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr progressstep_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdCompletedResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdCompletedResp) */ {
 public:
  inline FetchFileByIdCompletedResp() : FetchFileByIdCompletedResp(nullptr) {}
  ~FetchFileByIdCompletedResp() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdCompletedResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdCompletedResp(const FetchFileByIdCompletedResp& from);
  FetchFileByIdCompletedResp(FetchFileByIdCompletedResp&& from) noexcept
    : FetchFileByIdCompletedResp() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdCompletedResp& operator=(const FetchFileByIdCompletedResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdCompletedResp& operator=(FetchFileByIdCompletedResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdCompletedResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdCompletedResp* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdCompletedResp*>(
               &_FetchFileByIdCompletedResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(FetchFileByIdCompletedResp& a, FetchFileByIdCompletedResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdCompletedResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdCompletedResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdCompletedResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdCompletedResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdCompletedResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdCompletedResp& from) {
    FetchFileByIdCompletedResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdCompletedResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdCompletedResp";
  }
  protected:
  explicit FetchFileByIdCompletedResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kFilePathFieldNumber = 10,
    kFinalFileNameWithExtensionFieldNumber = 11,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string filePath = 10;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // string finalFileNameWithExtension = 11;
  void clear_finalfilenamewithextension();
  const std::string& finalfilenamewithextension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finalfilenamewithextension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finalfilenamewithextension();
  PROTOBUF_NODISCARD std::string* release_finalfilenamewithextension();
  void set_allocated_finalfilenamewithextension(std::string* finalfilenamewithextension);
  private:
  const std::string& _internal_finalfilenamewithextension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finalfilenamewithextension(const std::string& value);
  std::string* _internal_mutable_finalfilenamewithextension();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdCompletedResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finalfilenamewithextension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUploadedContentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUploadedContentReq) */ {
 public:
  inline FetchAllUploadedContentReq() : FetchAllUploadedContentReq(nullptr) {}
  ~FetchAllUploadedContentReq() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUploadedContentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUploadedContentReq(const FetchAllUploadedContentReq& from);
  FetchAllUploadedContentReq(FetchAllUploadedContentReq&& from) noexcept
    : FetchAllUploadedContentReq() {
    *this = ::std::move(from);
  }

  inline FetchAllUploadedContentReq& operator=(const FetchAllUploadedContentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUploadedContentReq& operator=(FetchAllUploadedContentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUploadedContentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUploadedContentReq* internal_default_instance() {
    return reinterpret_cast<const FetchAllUploadedContentReq*>(
               &_FetchAllUploadedContentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(FetchAllUploadedContentReq& a, FetchAllUploadedContentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUploadedContentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUploadedContentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUploadedContentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUploadedContentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUploadedContentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUploadedContentReq& from) {
    FetchAllUploadedContentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUploadedContentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUploadedContentReq";
  }
  protected:
  explicit FetchAllUploadedContentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUploadedContentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UploadLocalFileResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UploadLocalFileResp) */ {
 public:
  inline UploadLocalFileResp() : UploadLocalFileResp(nullptr) {}
  ~UploadLocalFileResp() override;
  explicit PROTOBUF_CONSTEXPR UploadLocalFileResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadLocalFileResp(const UploadLocalFileResp& from);
  UploadLocalFileResp(UploadLocalFileResp&& from) noexcept
    : UploadLocalFileResp() {
    *this = ::std::move(from);
  }

  inline UploadLocalFileResp& operator=(const UploadLocalFileResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadLocalFileResp& operator=(UploadLocalFileResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadLocalFileResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadLocalFileResp* internal_default_instance() {
    return reinterpret_cast<const UploadLocalFileResp*>(
               &_UploadLocalFileResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(UploadLocalFileResp& a, UploadLocalFileResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadLocalFileResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadLocalFileResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadLocalFileResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadLocalFileResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadLocalFileResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadLocalFileResp& from) {
    UploadLocalFileResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadLocalFileResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UploadLocalFileResp";
  }
  protected:
  explicit UploadLocalFileResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUploadedContentFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusRemoteContent uploadedContent = 10;
  bool has_uploadedcontent() const;
  private:
  bool _internal_has_uploadedcontent() const;
  public:
  void clear_uploadedcontent();
  const ::ServerData::CavrnusRemoteContent& uploadedcontent() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusRemoteContent* release_uploadedcontent();
  ::ServerData::CavrnusRemoteContent* mutable_uploadedcontent();
  void set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent);
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_uploadedcontent() const;
  ::ServerData::CavrnusRemoteContent* _internal_mutable_uploadedcontent();
  public:
  void unsafe_arena_set_allocated_uploadedcontent(
      ::ServerData::CavrnusRemoteContent* uploadedcontent);
  ::ServerData::CavrnusRemoteContent* unsafe_arena_release_uploadedcontent();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UploadLocalFileResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusRemoteContent* uploadedcontent_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UploadLocalFileReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UploadLocalFileReq) */ {
 public:
  inline UploadLocalFileReq() : UploadLocalFileReq(nullptr) {}
  ~UploadLocalFileReq() override;
  explicit PROTOBUF_CONSTEXPR UploadLocalFileReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadLocalFileReq(const UploadLocalFileReq& from);
  UploadLocalFileReq(UploadLocalFileReq&& from) noexcept
    : UploadLocalFileReq() {
    *this = ::std::move(from);
  }

  inline UploadLocalFileReq& operator=(const UploadLocalFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadLocalFileReq& operator=(UploadLocalFileReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadLocalFileReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadLocalFileReq* internal_default_instance() {
    return reinterpret_cast<const UploadLocalFileReq*>(
               &_UploadLocalFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(UploadLocalFileReq& a, UploadLocalFileReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadLocalFileReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadLocalFileReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadLocalFileReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadLocalFileReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadLocalFileReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadLocalFileReq& from) {
    UploadLocalFileReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadLocalFileReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UploadLocalFileReq";
  }
  protected:
  explicit UploadLocalFileReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagKeysFieldNumber = 11,
    kTagValuesFieldNumber = 12,
    kFilePathFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated string tagKeys = 11;
  int tagkeys_size() const;
  private:
  int _internal_tagkeys_size() const;
  public:
  void clear_tagkeys();
  const std::string& tagkeys(int index) const;
  std::string* mutable_tagkeys(int index);
  void set_tagkeys(int index, const std::string& value);
  void set_tagkeys(int index, std::string&& value);
  void set_tagkeys(int index, const char* value);
  void set_tagkeys(int index, const char* value, size_t size);
  std::string* add_tagkeys();
  void add_tagkeys(const std::string& value);
  void add_tagkeys(std::string&& value);
  void add_tagkeys(const char* value);
  void add_tagkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagkeys();
  private:
  const std::string& _internal_tagkeys(int index) const;
  std::string* _internal_add_tagkeys();
  public:

  // repeated string tagValues = 12;
  int tagvalues_size() const;
  private:
  int _internal_tagvalues_size() const;
  public:
  void clear_tagvalues();
  const std::string& tagvalues(int index) const;
  std::string* mutable_tagvalues(int index);
  void set_tagvalues(int index, const std::string& value);
  void set_tagvalues(int index, std::string&& value);
  void set_tagvalues(int index, const char* value);
  void set_tagvalues(int index, const char* value, size_t size);
  std::string* add_tagvalues();
  void add_tagvalues(const std::string& value);
  void add_tagvalues(std::string&& value);
  void add_tagvalues(const char* value);
  void add_tagvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagvalues();
  private:
  const std::string& _internal_tagvalues(int index) const;
  std::string* _internal_add_tagvalues();
  public:

  // string filePath = 10;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UploadLocalFileReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUploadedContentResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUploadedContentResp) */ {
 public:
  inline FetchAllUploadedContentResp() : FetchAllUploadedContentResp(nullptr) {}
  ~FetchAllUploadedContentResp() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUploadedContentResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUploadedContentResp(const FetchAllUploadedContentResp& from);
  FetchAllUploadedContentResp(FetchAllUploadedContentResp&& from) noexcept
    : FetchAllUploadedContentResp() {
    *this = ::std::move(from);
  }

  inline FetchAllUploadedContentResp& operator=(const FetchAllUploadedContentResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUploadedContentResp& operator=(FetchAllUploadedContentResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUploadedContentResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUploadedContentResp* internal_default_instance() {
    return reinterpret_cast<const FetchAllUploadedContentResp*>(
               &_FetchAllUploadedContentResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(FetchAllUploadedContentResp& a, FetchAllUploadedContentResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUploadedContentResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUploadedContentResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUploadedContentResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUploadedContentResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUploadedContentResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUploadedContentResp& from) {
    FetchAllUploadedContentResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUploadedContentResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUploadedContentResp";
  }
  protected:
  explicit FetchAllUploadedContentResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableContentFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.CavrnusRemoteContent availableContent = 10;
  int availablecontent_size() const;
  private:
  int _internal_availablecontent_size() const;
  public:
  void clear_availablecontent();
  ::ServerData::CavrnusRemoteContent* mutable_availablecontent(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >*
      mutable_availablecontent();
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_availablecontent(int index) const;
  ::ServerData::CavrnusRemoteContent* _internal_add_availablecontent();
  public:
  const ::ServerData::CavrnusRemoteContent& availablecontent(int index) const;
  ::ServerData::CavrnusRemoteContent* add_availablecontent();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >&
      availablecontent() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUploadedContentResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent > availablecontent_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropMetadataStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropMetadataStatus) */ {
 public:
  inline PropMetadataStatus() : PropMetadataStatus(nullptr) {}
  ~PropMetadataStatus() override;
  explicit PROTOBUF_CONSTEXPR PropMetadataStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropMetadataStatus(const PropMetadataStatus& from);
  PropMetadataStatus(PropMetadataStatus&& from) noexcept
    : PropMetadataStatus() {
    *this = ::std::move(from);
  }

  inline PropMetadataStatus& operator=(const PropMetadataStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropMetadataStatus& operator=(PropMetadataStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropMetadataStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropMetadataStatus* internal_default_instance() {
    return reinterpret_cast<const PropMetadataStatus*>(
               &_PropMetadataStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(PropMetadataStatus& a, PropMetadataStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PropMetadataStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropMetadataStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropMetadataStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropMetadataStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropMetadataStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropMetadataStatus& from) {
    PropMetadataStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropMetadataStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropMetadataStatus";
  }
  protected:
  explicit PropMetadataStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kIsReadonlyFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // bool isReadonly = 10;
  void clear_isreadonly();
  bool isreadonly() const;
  void set_isreadonly(bool value);
  private:
  bool _internal_isreadonly() const;
  void _internal_set_isreadonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PropMetadataStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    bool isreadonly_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropertyValueStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropertyValueStatus) */ {
 public:
  inline PropertyValueStatus() : PropertyValueStatus(nullptr) {}
  ~PropertyValueStatus() override;
  explicit PROTOBUF_CONSTEXPR PropertyValueStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyValueStatus(const PropertyValueStatus& from);
  PropertyValueStatus(PropertyValueStatus&& from) noexcept
    : PropertyValueStatus() {
    *this = ::std::move(from);
  }

  inline PropertyValueStatus& operator=(const PropertyValueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyValueStatus& operator=(PropertyValueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyValueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyValueStatus* internal_default_instance() {
    return reinterpret_cast<const PropertyValueStatus*>(
               &_PropertyValueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(PropertyValueStatus& a, PropertyValueStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyValueStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyValueStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyValueStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyValueStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyValueStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyValueStatus& from) {
    PropertyValueStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyValueStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropertyValueStatus";
  }
  protected:
  explicit PropertyValueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kPropertyValueFieldNumber = 10,
    kPriorityFieldNumber = 11,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 priority = 11;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PropertyValueStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class LocalPropertyHandledResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.LocalPropertyHandledResp) */ {
 public:
  inline LocalPropertyHandledResp() : LocalPropertyHandledResp(nullptr) {}
  ~LocalPropertyHandledResp() override;
  explicit PROTOBUF_CONSTEXPR LocalPropertyHandledResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalPropertyHandledResp(const LocalPropertyHandledResp& from);
  LocalPropertyHandledResp(LocalPropertyHandledResp&& from) noexcept
    : LocalPropertyHandledResp() {
    *this = ::std::move(from);
  }

  inline LocalPropertyHandledResp& operator=(const LocalPropertyHandledResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalPropertyHandledResp& operator=(LocalPropertyHandledResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalPropertyHandledResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalPropertyHandledResp* internal_default_instance() {
    return reinterpret_cast<const LocalPropertyHandledResp*>(
               &_LocalPropertyHandledResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(LocalPropertyHandledResp& a, LocalPropertyHandledResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalPropertyHandledResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalPropertyHandledResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalPropertyHandledResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalPropertyHandledResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalPropertyHandledResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalPropertyHandledResp& from) {
    LocalPropertyHandledResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalPropertyHandledResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.LocalPropertyHandledResp";
  }
  protected:
  explicit LocalPropertyHandledResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kLocalPropChangeIdFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // int32 localPropChangeId = 10;
  void clear_localpropchangeid();
  int32_t localpropchangeid() const;
  void set_localpropchangeid(int32_t value);
  private:
  int32_t _internal_localpropchangeid() const;
  void _internal_set_localpropchangeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.LocalPropertyHandledResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    int32_t localpropchangeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserAdded) */ {
 public:
  inline UserAdded() : UserAdded(nullptr) {}
  ~UserAdded() override;
  explicit PROTOBUF_CONSTEXPR UserAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAdded(const UserAdded& from);
  UserAdded(UserAdded&& from) noexcept
    : UserAdded() {
    *this = ::std::move(from);
  }

  inline UserAdded& operator=(const UserAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAdded& operator=(UserAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAdded* internal_default_instance() {
    return reinterpret_cast<const UserAdded*>(
               &_UserAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(UserAdded& a, UserAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAdded& from) {
    UserAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserAdded";
  }
  protected:
  explicit UserAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.CavrnusUser user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ServerData::CavrnusUser& user() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusUser* release_user();
  ::ServerData::CavrnusUser* mutable_user();
  void set_allocated_user(::ServerData::CavrnusUser* user);
  private:
  const ::ServerData::CavrnusUser& _internal_user() const;
  ::ServerData::CavrnusUser* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ServerData::CavrnusUser* user);
  ::ServerData::CavrnusUser* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:ServerData.UserAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::CavrnusUser* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserRemoved) */ {
 public:
  inline UserRemoved() : UserRemoved(nullptr) {}
  ~UserRemoved() override;
  explicit PROTOBUF_CONSTEXPR UserRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRemoved(const UserRemoved& from);
  UserRemoved(UserRemoved&& from) noexcept
    : UserRemoved() {
    *this = ::std::move(from);
  }

  inline UserRemoved& operator=(const UserRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRemoved& operator=(UserRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRemoved* internal_default_instance() {
    return reinterpret_cast<const UserRemoved*>(
               &_UserRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(UserRemoved& a, UserRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRemoved& from) {
    UserRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserRemoved";
  }
  protected:
  explicit UserRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.UserRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserVideoFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserVideoFrame) */ {
 public:
  inline UserVideoFrame() : UserVideoFrame(nullptr) {}
  ~UserVideoFrame() override;
  explicit PROTOBUF_CONSTEXPR UserVideoFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserVideoFrame(const UserVideoFrame& from);
  UserVideoFrame(UserVideoFrame&& from) noexcept
    : UserVideoFrame() {
    *this = ::std::move(from);
  }

  inline UserVideoFrame& operator=(const UserVideoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserVideoFrame& operator=(UserVideoFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserVideoFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserVideoFrame* internal_default_instance() {
    return reinterpret_cast<const UserVideoFrame*>(
               &_UserVideoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(UserVideoFrame& a, UserVideoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(UserVideoFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserVideoFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserVideoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserVideoFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserVideoFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserVideoFrame& from) {
    UserVideoFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserVideoFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserVideoFrame";
  }
  protected:
  explicit UserVideoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kStreamFieldNumber = 20,
    kSpaceConnFieldNumber = 1,
    kResXFieldNumber = 10,
    kResYFieldNumber = 11,
  };
  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes stream = 20;
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 resX = 10;
  void clear_resx();
  int32_t resx() const;
  void set_resx(int32_t value);
  private:
  int32_t _internal_resx() const;
  void _internal_set_resx(int32_t value);
  public:

  // int32 resY = 11;
  void clear_resy();
  int32_t resy() const;
  void set_resy(int32_t value);
  private:
  int32_t _internal_resy() const;
  void _internal_set_resy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UserVideoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t resx_;
    int32_t resy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SpaceInfo) */ {
 public:
  inline SpaceInfo() : SpaceInfo(nullptr) {}
  ~SpaceInfo() override;
  explicit PROTOBUF_CONSTEXPR SpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpaceInfo(const SpaceInfo& from);
  SpaceInfo(SpaceInfo&& from) noexcept
    : SpaceInfo() {
    *this = ::std::move(from);
  }

  inline SpaceInfo& operator=(const SpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceInfo& operator=(SpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpaceInfo* internal_default_instance() {
    return reinterpret_cast<const SpaceInfo*>(
               &_SpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(SpaceInfo& a, SpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpaceInfo& from) {
    SpaceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SpaceInfo";
  }
  protected:
  explicit SpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 1,
    kSpaceNameFieldNumber = 2,
    kSpaceThumbnailUrlFieldNumber = 3,
    kLastAccessFieldNumber = 5,
    kArchivedFieldNumber = 4,
  };
  // string spaceId = 1;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // string spaceName = 2;
  void clear_spacename();
  const std::string& spacename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spacename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spacename();
  PROTOBUF_NODISCARD std::string* release_spacename();
  void set_allocated_spacename(std::string* spacename);
  private:
  const std::string& _internal_spacename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spacename(const std::string& value);
  std::string* _internal_mutable_spacename();
  public:

  // string spaceThumbnailUrl = 3;
  void clear_spacethumbnailurl();
  const std::string& spacethumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spacethumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spacethumbnailurl();
  PROTOBUF_NODISCARD std::string* release_spacethumbnailurl();
  void set_allocated_spacethumbnailurl(std::string* spacethumbnailurl);
  private:
  const std::string& _internal_spacethumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spacethumbnailurl(const std::string& value);
  std::string* _internal_mutable_spacethumbnailurl();
  public:

  // .google.protobuf.Timestamp lastAccess = 5;
  bool has_lastaccess() const;
  private:
  bool _internal_has_lastaccess() const;
  public:
  void clear_lastaccess();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& lastaccess() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_lastaccess();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_lastaccess();
  void set_allocated_lastaccess(::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_lastaccess() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_lastaccess();
  public:
  void unsafe_arena_set_allocated_lastaccess(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_lastaccess();

  // bool archived = 4;
  void clear_archived();
  bool archived() const;
  void set_archived(bool value);
  private:
  bool _internal_archived() const;
  void _internal_set_archived(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spacename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spacethumbnailurl_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess_;
    bool archived_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ObjectAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ObjectAdded) */ {
 public:
  inline ObjectAdded() : ObjectAdded(nullptr) {}
  ~ObjectAdded() override;
  explicit PROTOBUF_CONSTEXPR ObjectAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectAdded(const ObjectAdded& from);
  ObjectAdded(ObjectAdded&& from) noexcept
    : ObjectAdded() {
    *this = ::std::move(from);
  }

  inline ObjectAdded& operator=(const ObjectAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectAdded& operator=(ObjectAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectAdded* internal_default_instance() {
    return reinterpret_cast<const ObjectAdded*>(
               &_ObjectAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ObjectAdded& a, ObjectAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectAdded& from) {
    ObjectAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ObjectAdded";
  }
  protected:
  explicit ObjectAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesContainerFieldNumber = 3,
    kObjectCreatedFieldNumber = 4,
    kSpaceConnFieldNumber = 1,
    kCreatedTimeFieldNumber = 5,
  };
  // string propertiesContainer = 3;
  void clear_propertiescontainer();
  const std::string& propertiescontainer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertiescontainer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertiescontainer();
  PROTOBUF_NODISCARD std::string* release_propertiescontainer();
  void set_allocated_propertiescontainer(std::string* propertiescontainer);
  private:
  const std::string& _internal_propertiescontainer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertiescontainer(const std::string& value);
  std::string* _internal_mutable_propertiescontainer();
  public:

  // string objectCreated = 4;
  void clear_objectcreated();
  const std::string& objectcreated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_objectcreated(ArgT0&& arg0, ArgT... args);
  std::string* mutable_objectcreated();
  PROTOBUF_NODISCARD std::string* release_objectcreated();
  void set_allocated_objectcreated(std::string* objectcreated);
  private:
  const std::string& _internal_objectcreated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_objectcreated(const std::string& value);
  std::string* _internal_mutable_objectcreated();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .google.protobuf.Timestamp createdTime = 5;
  bool has_createdtime() const;
  private:
  bool _internal_has_createdtime() const;
  public:
  void clear_createdtime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdtime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdtime();
  void set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdtime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdtime();
  public:
  void unsafe_arena_set_allocated_createdtime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdtime();

  // @@protoc_insertion_point(class_scope:ServerData.ObjectAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertiescontainer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectcreated_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ObjectRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ObjectRemoved) */ {
 public:
  inline ObjectRemoved() : ObjectRemoved(nullptr) {}
  ~ObjectRemoved() override;
  explicit PROTOBUF_CONSTEXPR ObjectRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectRemoved(const ObjectRemoved& from);
  ObjectRemoved(ObjectRemoved&& from) noexcept
    : ObjectRemoved() {
    *this = ::std::move(from);
  }

  inline ObjectRemoved& operator=(const ObjectRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectRemoved& operator=(ObjectRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectRemoved* internal_default_instance() {
    return reinterpret_cast<const ObjectRemoved*>(
               &_ObjectRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ObjectRemoved& a, ObjectRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectRemoved& from) {
    ObjectRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ObjectRemoved";
  }
  protected:
  explicit ObjectRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesContainerFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
  };
  // string propertiesContainer = 3;
  void clear_propertiescontainer();
  const std::string& propertiescontainer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertiescontainer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertiescontainer();
  PROTOBUF_NODISCARD std::string* release_propertiescontainer();
  void set_allocated_propertiescontainer(std::string* propertiescontainer);
  private:
  const std::string& _internal_propertiescontainer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertiescontainer(const std::string& value);
  std::string* _internal_mutable_propertiescontainer();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.ObjectRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertiescontainer_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserMuted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserMuted) */ {
 public:
  inline UpdateLocalUserMuted() : UpdateLocalUserMuted(nullptr) {}
  ~UpdateLocalUserMuted() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserMuted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserMuted(const UpdateLocalUserMuted& from);
  UpdateLocalUserMuted(UpdateLocalUserMuted&& from) noexcept
    : UpdateLocalUserMuted() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserMuted& operator=(const UpdateLocalUserMuted& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserMuted& operator=(UpdateLocalUserMuted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserMuted& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserMuted* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserMuted*>(
               &_UpdateLocalUserMuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(UpdateLocalUserMuted& a, UpdateLocalUserMuted& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserMuted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserMuted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserMuted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserMuted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserMuted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserMuted& from) {
    UpdateLocalUserMuted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserMuted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserMuted";
  }
  protected:
  explicit UpdateLocalUserMuted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kMutedFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool muted = 2;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserMuted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool muted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserCoPresence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserCoPresence) */ {
 public:
  inline UpdateLocalUserCoPresence() : UpdateLocalUserCoPresence(nullptr) {}
  ~UpdateLocalUserCoPresence() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserCoPresence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserCoPresence(const UpdateLocalUserCoPresence& from);
  UpdateLocalUserCoPresence(UpdateLocalUserCoPresence&& from) noexcept
    : UpdateLocalUserCoPresence() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserCoPresence& operator=(const UpdateLocalUserCoPresence& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserCoPresence& operator=(UpdateLocalUserCoPresence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserCoPresence& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserCoPresence* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserCoPresence*>(
               &_UpdateLocalUserCoPresence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(UpdateLocalUserCoPresence& a, UpdateLocalUserCoPresence& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserCoPresence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserCoPresence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserCoPresence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserCoPresence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserCoPresence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserCoPresence& from) {
    UpdateLocalUserCoPresence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserCoPresence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserCoPresence";
  }
  protected:
  explicit UpdateLocalUserCoPresence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kLocalUserRootTransformFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.TransformPropertyValue localUserRootTransform = 10;
  bool has_localuserroottransform() const;
  private:
  bool _internal_has_localuserroottransform() const;
  public:
  void clear_localuserroottransform();
  const ::ServerData::TransformPropertyValue& localuserroottransform() const;
  PROTOBUF_NODISCARD ::ServerData::TransformPropertyValue* release_localuserroottransform();
  ::ServerData::TransformPropertyValue* mutable_localuserroottransform();
  void set_allocated_localuserroottransform(::ServerData::TransformPropertyValue* localuserroottransform);
  private:
  const ::ServerData::TransformPropertyValue& _internal_localuserroottransform() const;
  ::ServerData::TransformPropertyValue* _internal_mutable_localuserroottransform();
  public:
  void unsafe_arena_set_allocated_localuserroottransform(
      ::ServerData::TransformPropertyValue* localuserroottransform);
  ::ServerData::TransformPropertyValue* unsafe_arena_release_localuserroottransform();

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserCoPresence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::TransformPropertyValue* localuserroottransform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserStreamState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserStreamState) */ {
 public:
  inline UpdateLocalUserStreamState() : UpdateLocalUserStreamState(nullptr) {}
  ~UpdateLocalUserStreamState() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserStreamState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserStreamState(const UpdateLocalUserStreamState& from);
  UpdateLocalUserStreamState(UpdateLocalUserStreamState&& from) noexcept
    : UpdateLocalUserStreamState() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserStreamState& operator=(const UpdateLocalUserStreamState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserStreamState& operator=(UpdateLocalUserStreamState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserStreamState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserStreamState* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserStreamState*>(
               &_UpdateLocalUserStreamState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UpdateLocalUserStreamState& a, UpdateLocalUserStreamState& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserStreamState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserStreamState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserStreamState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserStreamState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserStreamState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserStreamState& from) {
    UpdateLocalUserStreamState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserStreamState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserStreamState";
  }
  protected:
  explicit UpdateLocalUserStreamState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kStreamingFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool streaming = 2;
  void clear_streaming();
  bool streaming() const;
  void set_streaming(bool value);
  private:
  bool _internal_streaming() const;
  void _internal_set_streaming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserStreamState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool streaming_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PermissionStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PermissionStatusReq) */ {
 public:
  inline PermissionStatusReq() : PermissionStatusReq(nullptr) {}
  ~PermissionStatusReq() override;
  explicit PROTOBUF_CONSTEXPR PermissionStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionStatusReq(const PermissionStatusReq& from);
  PermissionStatusReq(PermissionStatusReq&& from) noexcept
    : PermissionStatusReq() {
    *this = ::std::move(from);
  }

  inline PermissionStatusReq& operator=(const PermissionStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionStatusReq& operator=(PermissionStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionStatusReq* internal_default_instance() {
    return reinterpret_cast<const PermissionStatusReq*>(
               &_PermissionStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(PermissionStatusReq& a, PermissionStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionStatusReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionStatusReq& from) {
    PermissionStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionStatusReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PermissionStatusReq";
  }
  protected:
  explicit PermissionStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string permission = 2;
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PermissionStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PermissionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PermissionStatus) */ {
 public:
  inline PermissionStatus() : PermissionStatus(nullptr) {}
  ~PermissionStatus() override;
  explicit PROTOBUF_CONSTEXPR PermissionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionStatus(const PermissionStatus& from);
  PermissionStatus(PermissionStatus&& from) noexcept
    : PermissionStatus() {
    *this = ::std::move(from);
  }

  inline PermissionStatus& operator=(const PermissionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionStatus& operator=(PermissionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionStatus* internal_default_instance() {
    return reinterpret_cast<const PermissionStatus*>(
               &_PermissionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(PermissionStatus& a, PermissionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionStatus& from) {
    PermissionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PermissionStatus";
  }
  protected:
  explicit PermissionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kValueFieldNumber = 3,
  };
  // string permission = 2;
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool value = 3;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PermissionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AllJoinableSpacesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AllJoinableSpacesReq) */ {
 public:
  inline AllJoinableSpacesReq() : AllJoinableSpacesReq(nullptr) {}
  ~AllJoinableSpacesReq() override;
  explicit PROTOBUF_CONSTEXPR AllJoinableSpacesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllJoinableSpacesReq(const AllJoinableSpacesReq& from);
  AllJoinableSpacesReq(AllJoinableSpacesReq&& from) noexcept
    : AllJoinableSpacesReq() {
    *this = ::std::move(from);
  }

  inline AllJoinableSpacesReq& operator=(const AllJoinableSpacesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllJoinableSpacesReq& operator=(AllJoinableSpacesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllJoinableSpacesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllJoinableSpacesReq* internal_default_instance() {
    return reinterpret_cast<const AllJoinableSpacesReq*>(
               &_AllJoinableSpacesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(AllJoinableSpacesReq& a, AllJoinableSpacesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AllJoinableSpacesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllJoinableSpacesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllJoinableSpacesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllJoinableSpacesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllJoinableSpacesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllJoinableSpacesReq& from) {
    AllJoinableSpacesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllJoinableSpacesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AllJoinableSpacesReq";
  }
  protected:
  explicit AllJoinableSpacesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AllJoinableSpacesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AllJoinableSpacesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AllJoinableSpacesResp) */ {
 public:
  inline AllJoinableSpacesResp() : AllJoinableSpacesResp(nullptr) {}
  ~AllJoinableSpacesResp() override;
  explicit PROTOBUF_CONSTEXPR AllJoinableSpacesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllJoinableSpacesResp(const AllJoinableSpacesResp& from);
  AllJoinableSpacesResp(AllJoinableSpacesResp&& from) noexcept
    : AllJoinableSpacesResp() {
    *this = ::std::move(from);
  }

  inline AllJoinableSpacesResp& operator=(const AllJoinableSpacesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllJoinableSpacesResp& operator=(AllJoinableSpacesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllJoinableSpacesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllJoinableSpacesResp* internal_default_instance() {
    return reinterpret_cast<const AllJoinableSpacesResp*>(
               &_AllJoinableSpacesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(AllJoinableSpacesResp& a, AllJoinableSpacesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AllJoinableSpacesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllJoinableSpacesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllJoinableSpacesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllJoinableSpacesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllJoinableSpacesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllJoinableSpacesResp& from) {
    AllJoinableSpacesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllJoinableSpacesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AllJoinableSpacesResp";
  }
  protected:
  explicit AllJoinableSpacesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableSpacesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.SpaceInfo availableSpaces = 10;
  int availablespaces_size() const;
  private:
  int _internal_availablespaces_size() const;
  public:
  void clear_availablespaces();
  ::ServerData::SpaceInfo* mutable_availablespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >*
      mutable_availablespaces();
  private:
  const ::ServerData::SpaceInfo& _internal_availablespaces(int index) const;
  ::ServerData::SpaceInfo* _internal_add_availablespaces();
  public:
  const ::ServerData::SpaceInfo& availablespaces(int index) const;
  ::ServerData::SpaceInfo* add_availablespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >&
      availablespaces() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AllJoinableSpacesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo > availablespaces_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatAdded) */ {
 public:
  inline ChatAdded() : ChatAdded(nullptr) {}
  ~ChatAdded() override;
  explicit PROTOBUF_CONSTEXPR ChatAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatAdded(const ChatAdded& from);
  ChatAdded(ChatAdded&& from) noexcept
    : ChatAdded() {
    *this = ::std::move(from);
  }

  inline ChatAdded& operator=(const ChatAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatAdded& operator=(ChatAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatAdded* internal_default_instance() {
    return reinterpret_cast<const ChatAdded*>(
               &_ChatAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ChatAdded& a, ChatAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatAdded& from) {
    ChatAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatAdded";
  }
  protected:
  explicit ChatAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kChatDataFieldNumber = 10,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.ChatBase ChatData = 10;
  bool has_chatdata() const;
  private:
  bool _internal_has_chatdata() const;
  public:
  void clear_chatdata();
  const ::ServerData::ChatBase& chatdata() const;
  PROTOBUF_NODISCARD ::ServerData::ChatBase* release_chatdata();
  ::ServerData::ChatBase* mutable_chatdata();
  void set_allocated_chatdata(::ServerData::ChatBase* chatdata);
  private:
  const ::ServerData::ChatBase& _internal_chatdata() const;
  ::ServerData::ChatBase* _internal_mutable_chatdata();
  public:
  void unsafe_arena_set_allocated_chatdata(
      ::ServerData::ChatBase* chatdata);
  ::ServerData::ChatBase* unsafe_arena_release_chatdata();

  // @@protoc_insertion_point(class_scope:ServerData.ChatAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::ChatBase* chatdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatUpdated) */ {
 public:
  inline ChatUpdated() : ChatUpdated(nullptr) {}
  ~ChatUpdated() override;
  explicit PROTOBUF_CONSTEXPR ChatUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatUpdated(const ChatUpdated& from);
  ChatUpdated(ChatUpdated&& from) noexcept
    : ChatUpdated() {
    *this = ::std::move(from);
  }

  inline ChatUpdated& operator=(const ChatUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatUpdated& operator=(ChatUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatUpdated* internal_default_instance() {
    return reinterpret_cast<const ChatUpdated*>(
               &_ChatUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(ChatUpdated& a, ChatUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatUpdated& from) {
    ChatUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatUpdated";
  }
  protected:
  explicit ChatUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kChatDataFieldNumber = 10,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.ChatBase ChatData = 10;
  bool has_chatdata() const;
  private:
  bool _internal_has_chatdata() const;
  public:
  void clear_chatdata();
  const ::ServerData::ChatBase& chatdata() const;
  PROTOBUF_NODISCARD ::ServerData::ChatBase* release_chatdata();
  ::ServerData::ChatBase* mutable_chatdata();
  void set_allocated_chatdata(::ServerData::ChatBase* chatdata);
  private:
  const ::ServerData::ChatBase& _internal_chatdata() const;
  ::ServerData::ChatBase* _internal_mutable_chatdata();
  public:
  void unsafe_arena_set_allocated_chatdata(
      ::ServerData::ChatBase* chatdata);
  ::ServerData::ChatBase* unsafe_arena_release_chatdata();

  // @@protoc_insertion_point(class_scope:ServerData.ChatUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::ChatBase* chatdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatRemoved) */ {
 public:
  inline ChatRemoved() : ChatRemoved(nullptr) {}
  ~ChatRemoved() override;
  explicit PROTOBUF_CONSTEXPR ChatRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRemoved(const ChatRemoved& from);
  ChatRemoved(ChatRemoved&& from) noexcept
    : ChatRemoved() {
    *this = ::std::move(from);
  }

  inline ChatRemoved& operator=(const ChatRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRemoved& operator=(ChatRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRemoved* internal_default_instance() {
    return reinterpret_cast<const ChatRemoved*>(
               &_ChatRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ChatRemoved& a, ChatRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatRemoved& from) {
    ChatRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatRemoved";
  }
  protected:
  explicit ChatRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.ChatRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostChat) */ {
 public:
  inline PostChat() : PostChat(nullptr) {}
  ~PostChat() override;
  explicit PROTOBUF_CONSTEXPR PostChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostChat(const PostChat& from);
  PostChat(PostChat&& from) noexcept
    : PostChat() {
    *this = ::std::move(from);
  }

  inline PostChat& operator=(const PostChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostChat& operator=(PostChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostChat* internal_default_instance() {
    return reinterpret_cast<const PostChat*>(
               &_PostChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(PostChat& a, PostChat& b) {
    a.Swap(&b);
  }
  inline void Swap(PostChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostChat& from) {
    PostChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostChat";
  }
  protected:
  explicit PostChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatTextFieldNumber = 10,
    kSpaceConnFieldNumber = 1,
  };
  // string ChatText = 10;
  void clear_chattext();
  const std::string& chattext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattext();
  PROTOBUF_NODISCARD std::string* release_chattext();
  void set_allocated_chattext(std::string* chattext);
  private:
  const std::string& _internal_chattext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattext(const std::string& value);
  std::string* _internal_mutable_chattext();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PostChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattext_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatBase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatBase) */ {
 public:
  inline ChatBase() : ChatBase(nullptr) {}
  ~ChatBase() override;
  explicit PROTOBUF_CONSTEXPR ChatBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatBase(const ChatBase& from);
  ChatBase(ChatBase&& from) noexcept
    : ChatBase() {
    *this = ::std::move(from);
  }

  inline ChatBase& operator=(const ChatBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatBase& operator=(ChatBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatBase& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatBase* internal_default_instance() {
    return reinterpret_cast<const ChatBase*>(
               &_ChatBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ChatBase& a, ChatBase& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatBase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatBase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatBase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatBase& from) {
    ChatBase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatBase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatBase";
  }
  protected:
  explicit ChatBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatBase_ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum;
  static constexpr ChatMessageSourceTypeEnum Chat =
    ChatBase_ChatMessageSourceTypeEnum_Chat;
  static constexpr ChatMessageSourceTypeEnum Transcription =
    ChatBase_ChatMessageSourceTypeEnum_Transcription;
  static inline bool ChatMessageSourceTypeEnum_IsValid(int value) {
    return ChatBase_ChatMessageSourceTypeEnum_IsValid(value);
  }
  static constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MIN =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MIN;
  static constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MAX =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX;
  static constexpr int ChatMessageSourceTypeEnum_ARRAYSIZE =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChatMessageSourceTypeEnum_descriptor() {
    return ChatBase_ChatMessageSourceTypeEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& ChatMessageSourceTypeEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChatMessageSourceTypeEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChatMessageSourceTypeEnum_Name.");
    return ChatBase_ChatMessageSourceTypeEnum_Name(enum_t_value);
  }
  static inline bool ChatMessageSourceTypeEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChatMessageSourceTypeEnum* value) {
    return ChatBase_ChatMessageSourceTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kCreatorNameFieldNumber = 11,
    kCreatorPicUrlFieldNumber = 12,
    kCreatedTimeFieldNumber = 3,
    kChatTypeFieldNumber = 1,
    kCompleteFieldNumber = 4,
    kWasTranslatedFieldNumber = 5,
    kCreatorIsLocalFieldNumber = 10,
  };
  // string Text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string CreatorName = 11;
  void clear_creatorname();
  const std::string& creatorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorname();
  PROTOBUF_NODISCARD std::string* release_creatorname();
  void set_allocated_creatorname(std::string* creatorname);
  private:
  const std::string& _internal_creatorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorname(const std::string& value);
  std::string* _internal_mutable_creatorname();
  public:

  // string CreatorPicUrl = 12;
  void clear_creatorpicurl();
  const std::string& creatorpicurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorpicurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorpicurl();
  PROTOBUF_NODISCARD std::string* release_creatorpicurl();
  void set_allocated_creatorpicurl(std::string* creatorpicurl);
  private:
  const std::string& _internal_creatorpicurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorpicurl(const std::string& value);
  std::string* _internal_mutable_creatorpicurl();
  public:

  // .google.protobuf.Timestamp CreatedTime = 3;
  bool has_createdtime() const;
  private:
  bool _internal_has_createdtime() const;
  public:
  void clear_createdtime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdtime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdtime();
  void set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdtime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdtime();
  public:
  void unsafe_arena_set_allocated_createdtime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdtime();

  // .ServerData.ChatBase.ChatMessageSourceTypeEnum ChatType = 1;
  void clear_chattype();
  ::ServerData::ChatBase_ChatMessageSourceTypeEnum chattype() const;
  void set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value);
  private:
  ::ServerData::ChatBase_ChatMessageSourceTypeEnum _internal_chattype() const;
  void _internal_set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value);
  public:

  // bool Complete = 4;
  void clear_complete();
  bool complete() const;
  void set_complete(bool value);
  private:
  bool _internal_complete() const;
  void _internal_set_complete(bool value);
  public:

  // bool WasTranslated = 5;
  void clear_wastranslated();
  bool wastranslated() const;
  void set_wastranslated(bool value);
  private:
  bool _internal_wastranslated() const;
  void _internal_set_wastranslated(bool value);
  public:

  // bool CreatorIsLocal = 10;
  void clear_creatorislocal();
  bool creatorislocal() const;
  void set_creatorislocal(bool value);
  private:
  bool _internal_creatorislocal() const;
  void _internal_set_creatorislocal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ChatBase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorpicurl_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime_;
    int chattype_;
    bool complete_;
    bool wastranslated_;
    bool creatorislocal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RelayClientMessageBatch

// repeated .ServerData.RelayClientMessage Messages = 1;
inline int RelayClientMessageBatch::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int RelayClientMessageBatch::messages_size() const {
  return _internal_messages_size();
}
inline void RelayClientMessageBatch::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessageBatch.Messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >*
RelayClientMessageBatch::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayClientMessageBatch.Messages)
  return &_impl_.messages_;
}
inline const ::ServerData::RelayClientMessage& RelayClientMessageBatch::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::ServerData::RelayClientMessage& RelayClientMessageBatch::messages(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessageBatch.Messages)
  return _internal_messages(index);
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::add_messages() {
  ::ServerData::RelayClientMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:ServerData.RelayClientMessageBatch.Messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >&
RelayClientMessageBatch::messages() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayClientMessageBatch.Messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// RelayClientMessage

// .ServerData.KeepAlive KeepAlive = 1;
inline bool RelayClientMessage::_internal_has_keepalive() const {
  return Msg_case() == kKeepAlive;
}
inline bool RelayClientMessage::has_keepalive() const {
  return _internal_has_keepalive();
}
inline void RelayClientMessage::set_has_keepalive() {
  _impl_._oneof_case_[0] = kKeepAlive;
}
inline void RelayClientMessage::clear_keepalive() {
  if (_internal_has_keepalive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.keepalive_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::KeepAlive* RelayClientMessage::release_keepalive() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.KeepAlive)
  if (_internal_has_keepalive()) {
    clear_has_Msg();
    ::ServerData::KeepAlive* temp = _impl_.Msg_.keepalive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.keepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::KeepAlive& RelayClientMessage::_internal_keepalive() const {
  return _internal_has_keepalive()
      ? *_impl_.Msg_.keepalive_
      : reinterpret_cast< ::ServerData::KeepAlive&>(::ServerData::_KeepAlive_default_instance_);
}
inline const ::ServerData::KeepAlive& RelayClientMessage::keepalive() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.KeepAlive)
  return _internal_keepalive();
}
inline ::ServerData::KeepAlive* RelayClientMessage::unsafe_arena_release_keepalive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.KeepAlive)
  if (_internal_has_keepalive()) {
    clear_has_Msg();
    ::ServerData::KeepAlive* temp = _impl_.Msg_.keepalive_;
    _impl_.Msg_.keepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_keepalive(::ServerData::KeepAlive* keepalive) {
  clear_Msg();
  if (keepalive) {
    set_has_keepalive();
    _impl_.Msg_.keepalive_ = keepalive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.KeepAlive)
}
inline ::ServerData::KeepAlive* RelayClientMessage::_internal_mutable_keepalive() {
  if (!_internal_has_keepalive()) {
    clear_Msg();
    set_has_keepalive();
    _impl_.Msg_.keepalive_ = CreateMaybeMessage< ::ServerData::KeepAlive >(GetArenaForAllocation());
  }
  return _impl_.Msg_.keepalive_;
}
inline ::ServerData::KeepAlive* RelayClientMessage::mutable_keepalive() {
  ::ServerData::KeepAlive* _msg = _internal_mutable_keepalive();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.KeepAlive)
  return _msg;
}

// .ServerData.UpdateTime UpdateTime = 2;
inline bool RelayClientMessage::_internal_has_updatetime() const {
  return Msg_case() == kUpdateTime;
}
inline bool RelayClientMessage::has_updatetime() const {
  return _internal_has_updatetime();
}
inline void RelayClientMessage::set_has_updatetime() {
  _impl_._oneof_case_[0] = kUpdateTime;
}
inline void RelayClientMessage::clear_updatetime() {
  if (_internal_has_updatetime()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatetime_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateTime* RelayClientMessage::release_updatetime() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateTime)
  if (_internal_has_updatetime()) {
    clear_has_Msg();
    ::ServerData::UpdateTime* temp = _impl_.Msg_.updatetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateTime& RelayClientMessage::_internal_updatetime() const {
  return _internal_has_updatetime()
      ? *_impl_.Msg_.updatetime_
      : reinterpret_cast< ::ServerData::UpdateTime&>(::ServerData::_UpdateTime_default_instance_);
}
inline const ::ServerData::UpdateTime& RelayClientMessage::updatetime() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateTime)
  return _internal_updatetime();
}
inline ::ServerData::UpdateTime* RelayClientMessage::unsafe_arena_release_updatetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateTime)
  if (_internal_has_updatetime()) {
    clear_has_Msg();
    ::ServerData::UpdateTime* temp = _impl_.Msg_.updatetime_;
    _impl_.Msg_.updatetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatetime(::ServerData::UpdateTime* updatetime) {
  clear_Msg();
  if (updatetime) {
    set_has_updatetime();
    _impl_.Msg_.updatetime_ = updatetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateTime)
}
inline ::ServerData::UpdateTime* RelayClientMessage::_internal_mutable_updatetime() {
  if (!_internal_has_updatetime()) {
    clear_Msg();
    set_has_updatetime();
    _impl_.Msg_.updatetime_ = CreateMaybeMessage< ::ServerData::UpdateTime >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatetime_;
}
inline ::ServerData::UpdateTime* RelayClientMessage::mutable_updatetime() {
  ::ServerData::UpdateTime* _msg = _internal_mutable_updatetime();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateTime)
  return _msg;
}

// .ServerData.AuthenticateReq AuthenticateReq = 10;
inline bool RelayClientMessage::_internal_has_authenticatereq() const {
  return Msg_case() == kAuthenticateReq;
}
inline bool RelayClientMessage::has_authenticatereq() const {
  return _internal_has_authenticatereq();
}
inline void RelayClientMessage::set_has_authenticatereq() {
  _impl_._oneof_case_[0] = kAuthenticateReq;
}
inline void RelayClientMessage::clear_authenticatereq() {
  if (_internal_has_authenticatereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::release_authenticatereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateReq)
  if (_internal_has_authenticatereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateReq* temp = _impl_.Msg_.authenticatereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateReq& RelayClientMessage::_internal_authenticatereq() const {
  return _internal_has_authenticatereq()
      ? *_impl_.Msg_.authenticatereq_
      : reinterpret_cast< ::ServerData::AuthenticateReq&>(::ServerData::_AuthenticateReq_default_instance_);
}
inline const ::ServerData::AuthenticateReq& RelayClientMessage::authenticatereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateReq)
  return _internal_authenticatereq();
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::unsafe_arena_release_authenticatereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateReq)
  if (_internal_has_authenticatereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateReq* temp = _impl_.Msg_.authenticatereq_;
    _impl_.Msg_.authenticatereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticatereq(::ServerData::AuthenticateReq* authenticatereq) {
  clear_Msg();
  if (authenticatereq) {
    set_has_authenticatereq();
    _impl_.Msg_.authenticatereq_ = authenticatereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateReq)
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::_internal_mutable_authenticatereq() {
  if (!_internal_has_authenticatereq()) {
    clear_Msg();
    set_has_authenticatereq();
    _impl_.Msg_.authenticatereq_ = CreateMaybeMessage< ::ServerData::AuthenticateReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatereq_;
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::mutable_authenticatereq() {
  ::ServerData::AuthenticateReq* _msg = _internal_mutable_authenticatereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateReq)
  return _msg;
}

// .ServerData.AuthenticateGuestReq AuthenticateGuestReq = 11;
inline bool RelayClientMessage::_internal_has_authenticateguestreq() const {
  return Msg_case() == kAuthenticateGuestReq;
}
inline bool RelayClientMessage::has_authenticateguestreq() const {
  return _internal_has_authenticateguestreq();
}
inline void RelayClientMessage::set_has_authenticateguestreq() {
  _impl_._oneof_case_[0] = kAuthenticateGuestReq;
}
inline void RelayClientMessage::clear_authenticateguestreq() {
  if (_internal_has_authenticateguestreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateguestreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::release_authenticateguestreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateGuestReq)
  if (_internal_has_authenticateguestreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestReq* temp = _impl_.Msg_.authenticateguestreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateguestreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateGuestReq& RelayClientMessage::_internal_authenticateguestreq() const {
  return _internal_has_authenticateguestreq()
      ? *_impl_.Msg_.authenticateguestreq_
      : reinterpret_cast< ::ServerData::AuthenticateGuestReq&>(::ServerData::_AuthenticateGuestReq_default_instance_);
}
inline const ::ServerData::AuthenticateGuestReq& RelayClientMessage::authenticateguestreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateGuestReq)
  return _internal_authenticateguestreq();
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::unsafe_arena_release_authenticateguestreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateGuestReq)
  if (_internal_has_authenticateguestreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestReq* temp = _impl_.Msg_.authenticateguestreq_;
    _impl_.Msg_.authenticateguestreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticateguestreq(::ServerData::AuthenticateGuestReq* authenticateguestreq) {
  clear_Msg();
  if (authenticateguestreq) {
    set_has_authenticateguestreq();
    _impl_.Msg_.authenticateguestreq_ = authenticateguestreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateGuestReq)
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::_internal_mutable_authenticateguestreq() {
  if (!_internal_has_authenticateguestreq()) {
    clear_Msg();
    set_has_authenticateguestreq();
    _impl_.Msg_.authenticateguestreq_ = CreateMaybeMessage< ::ServerData::AuthenticateGuestReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateguestreq_;
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::mutable_authenticateguestreq() {
  ::ServerData::AuthenticateGuestReq* _msg = _internal_mutable_authenticateguestreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateGuestReq)
  return _msg;
}

// .ServerData.ExitAllSpacesAndLogoutReq ExitAllSpacesAndLogoutReq = 12;
inline bool RelayClientMessage::_internal_has_exitallspacesandlogoutreq() const {
  return Msg_case() == kExitAllSpacesAndLogoutReq;
}
inline bool RelayClientMessage::has_exitallspacesandlogoutreq() const {
  return _internal_has_exitallspacesandlogoutreq();
}
inline void RelayClientMessage::set_has_exitallspacesandlogoutreq() {
  _impl_._oneof_case_[0] = kExitAllSpacesAndLogoutReq;
}
inline void RelayClientMessage::clear_exitallspacesandlogoutreq() {
  if (_internal_has_exitallspacesandlogoutreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.exitallspacesandlogoutreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::release_exitallspacesandlogoutreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  if (_internal_has_exitallspacesandlogoutreq()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutReq* temp = _impl_.Msg_.exitallspacesandlogoutreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.exitallspacesandlogoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ExitAllSpacesAndLogoutReq& RelayClientMessage::_internal_exitallspacesandlogoutreq() const {
  return _internal_has_exitallspacesandlogoutreq()
      ? *_impl_.Msg_.exitallspacesandlogoutreq_
      : reinterpret_cast< ::ServerData::ExitAllSpacesAndLogoutReq&>(::ServerData::_ExitAllSpacesAndLogoutReq_default_instance_);
}
inline const ::ServerData::ExitAllSpacesAndLogoutReq& RelayClientMessage::exitallspacesandlogoutreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  return _internal_exitallspacesandlogoutreq();
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::unsafe_arena_release_exitallspacesandlogoutreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  if (_internal_has_exitallspacesandlogoutreq()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutReq* temp = _impl_.Msg_.exitallspacesandlogoutreq_;
    _impl_.Msg_.exitallspacesandlogoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_exitallspacesandlogoutreq(::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq) {
  clear_Msg();
  if (exitallspacesandlogoutreq) {
    set_has_exitallspacesandlogoutreq();
    _impl_.Msg_.exitallspacesandlogoutreq_ = exitallspacesandlogoutreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::_internal_mutable_exitallspacesandlogoutreq() {
  if (!_internal_has_exitallspacesandlogoutreq()) {
    clear_Msg();
    set_has_exitallspacesandlogoutreq();
    _impl_.Msg_.exitallspacesandlogoutreq_ = CreateMaybeMessage< ::ServerData::ExitAllSpacesAndLogoutReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.exitallspacesandlogoutreq_;
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::mutable_exitallspacesandlogoutreq() {
  ::ServerData::ExitAllSpacesAndLogoutReq* _msg = _internal_mutable_exitallspacesandlogoutreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  return _msg;
}

// .ServerData.JoinSpaceFromIdReq JoinSpaceFromIdReq = 20;
inline bool RelayClientMessage::_internal_has_joinspacefromidreq() const {
  return Msg_case() == kJoinSpaceFromIdReq;
}
inline bool RelayClientMessage::has_joinspacefromidreq() const {
  return _internal_has_joinspacefromidreq();
}
inline void RelayClientMessage::set_has_joinspacefromidreq() {
  _impl_._oneof_case_[0] = kJoinSpaceFromIdReq;
}
inline void RelayClientMessage::clear_joinspacefromidreq() {
  if (_internal_has_joinspacefromidreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.joinspacefromidreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::release_joinspacefromidreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  if (_internal_has_joinspacefromidreq()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdReq* temp = _impl_.Msg_.joinspacefromidreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.joinspacefromidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::JoinSpaceFromIdReq& RelayClientMessage::_internal_joinspacefromidreq() const {
  return _internal_has_joinspacefromidreq()
      ? *_impl_.Msg_.joinspacefromidreq_
      : reinterpret_cast< ::ServerData::JoinSpaceFromIdReq&>(::ServerData::_JoinSpaceFromIdReq_default_instance_);
}
inline const ::ServerData::JoinSpaceFromIdReq& RelayClientMessage::joinspacefromidreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  return _internal_joinspacefromidreq();
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::unsafe_arena_release_joinspacefromidreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  if (_internal_has_joinspacefromidreq()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdReq* temp = _impl_.Msg_.joinspacefromidreq_;
    _impl_.Msg_.joinspacefromidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_joinspacefromidreq(::ServerData::JoinSpaceFromIdReq* joinspacefromidreq) {
  clear_Msg();
  if (joinspacefromidreq) {
    set_has_joinspacefromidreq();
    _impl_.Msg_.joinspacefromidreq_ = joinspacefromidreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::_internal_mutable_joinspacefromidreq() {
  if (!_internal_has_joinspacefromidreq()) {
    clear_Msg();
    set_has_joinspacefromidreq();
    _impl_.Msg_.joinspacefromidreq_ = CreateMaybeMessage< ::ServerData::JoinSpaceFromIdReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.joinspacefromidreq_;
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::mutable_joinspacefromidreq() {
  ::ServerData::JoinSpaceFromIdReq* _msg = _internal_mutable_joinspacefromidreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  return _msg;
}

// .ServerData.ShutdownSpaceConnectionReq ShutdownSpaceConnectionReq = 21;
inline bool RelayClientMessage::_internal_has_shutdownspaceconnectionreq() const {
  return Msg_case() == kShutdownSpaceConnectionReq;
}
inline bool RelayClientMessage::has_shutdownspaceconnectionreq() const {
  return _internal_has_shutdownspaceconnectionreq();
}
inline void RelayClientMessage::set_has_shutdownspaceconnectionreq() {
  _impl_._oneof_case_[0] = kShutdownSpaceConnectionReq;
}
inline void RelayClientMessage::clear_shutdownspaceconnectionreq() {
  if (_internal_has_shutdownspaceconnectionreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.shutdownspaceconnectionreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::release_shutdownspaceconnectionreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  if (_internal_has_shutdownspaceconnectionreq()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionReq* temp = _impl_.Msg_.shutdownspaceconnectionreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.shutdownspaceconnectionreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ShutdownSpaceConnectionReq& RelayClientMessage::_internal_shutdownspaceconnectionreq() const {
  return _internal_has_shutdownspaceconnectionreq()
      ? *_impl_.Msg_.shutdownspaceconnectionreq_
      : reinterpret_cast< ::ServerData::ShutdownSpaceConnectionReq&>(::ServerData::_ShutdownSpaceConnectionReq_default_instance_);
}
inline const ::ServerData::ShutdownSpaceConnectionReq& RelayClientMessage::shutdownspaceconnectionreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  return _internal_shutdownspaceconnectionreq();
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::unsafe_arena_release_shutdownspaceconnectionreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  if (_internal_has_shutdownspaceconnectionreq()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionReq* temp = _impl_.Msg_.shutdownspaceconnectionreq_;
    _impl_.Msg_.shutdownspaceconnectionreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_shutdownspaceconnectionreq(::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq) {
  clear_Msg();
  if (shutdownspaceconnectionreq) {
    set_has_shutdownspaceconnectionreq();
    _impl_.Msg_.shutdownspaceconnectionreq_ = shutdownspaceconnectionreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::_internal_mutable_shutdownspaceconnectionreq() {
  if (!_internal_has_shutdownspaceconnectionreq()) {
    clear_Msg();
    set_has_shutdownspaceconnectionreq();
    _impl_.Msg_.shutdownspaceconnectionreq_ = CreateMaybeMessage< ::ServerData::ShutdownSpaceConnectionReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.shutdownspaceconnectionreq_;
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::mutable_shutdownspaceconnectionreq() {
  ::ServerData::ShutdownSpaceConnectionReq* _msg = _internal_mutable_shutdownspaceconnectionreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  return _msg;
}

// .ServerData.CreateSpaceReq CreateSpaceReq = 22;
inline bool RelayClientMessage::_internal_has_createspacereq() const {
  return Msg_case() == kCreateSpaceReq;
}
inline bool RelayClientMessage::has_createspacereq() const {
  return _internal_has_createspacereq();
}
inline void RelayClientMessage::set_has_createspacereq() {
  _impl_._oneof_case_[0] = kCreateSpaceReq;
}
inline void RelayClientMessage::clear_createspacereq() {
  if (_internal_has_createspacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.createspacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::release_createspacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.CreateSpaceReq)
  if (_internal_has_createspacereq()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceReq* temp = _impl_.Msg_.createspacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.createspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CreateSpaceReq& RelayClientMessage::_internal_createspacereq() const {
  return _internal_has_createspacereq()
      ? *_impl_.Msg_.createspacereq_
      : reinterpret_cast< ::ServerData::CreateSpaceReq&>(::ServerData::_CreateSpaceReq_default_instance_);
}
inline const ::ServerData::CreateSpaceReq& RelayClientMessage::createspacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.CreateSpaceReq)
  return _internal_createspacereq();
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::unsafe_arena_release_createspacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.CreateSpaceReq)
  if (_internal_has_createspacereq()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceReq* temp = _impl_.Msg_.createspacereq_;
    _impl_.Msg_.createspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_createspacereq(::ServerData::CreateSpaceReq* createspacereq) {
  clear_Msg();
  if (createspacereq) {
    set_has_createspacereq();
    _impl_.Msg_.createspacereq_ = createspacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.CreateSpaceReq)
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::_internal_mutable_createspacereq() {
  if (!_internal_has_createspacereq()) {
    clear_Msg();
    set_has_createspacereq();
    _impl_.Msg_.createspacereq_ = CreateMaybeMessage< ::ServerData::CreateSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.createspacereq_;
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::mutable_createspacereq() {
  ::ServerData::CreateSpaceReq* _msg = _internal_mutable_createspacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.CreateSpaceReq)
  return _msg;
}

// .ServerData.GetAudioInputDevicesReq GetAudioInputDevicesReq = 30;
inline bool RelayClientMessage::_internal_has_getaudioinputdevicesreq() const {
  return Msg_case() == kGetAudioInputDevicesReq;
}
inline bool RelayClientMessage::has_getaudioinputdevicesreq() const {
  return _internal_has_getaudioinputdevicesreq();
}
inline void RelayClientMessage::set_has_getaudioinputdevicesreq() {
  _impl_._oneof_case_[0] = kGetAudioInputDevicesReq;
}
inline void RelayClientMessage::clear_getaudioinputdevicesreq() {
  if (_internal_has_getaudioinputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudioinputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::release_getaudioinputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  if (_internal_has_getaudioinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesReq* temp = _impl_.Msg_.getaudioinputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudioinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioInputDevicesReq& RelayClientMessage::_internal_getaudioinputdevicesreq() const {
  return _internal_has_getaudioinputdevicesreq()
      ? *_impl_.Msg_.getaudioinputdevicesreq_
      : reinterpret_cast< ::ServerData::GetAudioInputDevicesReq&>(::ServerData::_GetAudioInputDevicesReq_default_instance_);
}
inline const ::ServerData::GetAudioInputDevicesReq& RelayClientMessage::getaudioinputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  return _internal_getaudioinputdevicesreq();
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::unsafe_arena_release_getaudioinputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  if (_internal_has_getaudioinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesReq* temp = _impl_.Msg_.getaudioinputdevicesreq_;
    _impl_.Msg_.getaudioinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getaudioinputdevicesreq(::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq) {
  clear_Msg();
  if (getaudioinputdevicesreq) {
    set_has_getaudioinputdevicesreq();
    _impl_.Msg_.getaudioinputdevicesreq_ = getaudioinputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::_internal_mutable_getaudioinputdevicesreq() {
  if (!_internal_has_getaudioinputdevicesreq()) {
    clear_Msg();
    set_has_getaudioinputdevicesreq();
    _impl_.Msg_.getaudioinputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetAudioInputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudioinputdevicesreq_;
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::mutable_getaudioinputdevicesreq() {
  ::ServerData::GetAudioInputDevicesReq* _msg = _internal_mutable_getaudioinputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  return _msg;
}

// .ServerData.GetAudioOutputDevicesReq GetAudioOutputDevicesReq = 31;
inline bool RelayClientMessage::_internal_has_getaudiooutputdevicesreq() const {
  return Msg_case() == kGetAudioOutputDevicesReq;
}
inline bool RelayClientMessage::has_getaudiooutputdevicesreq() const {
  return _internal_has_getaudiooutputdevicesreq();
}
inline void RelayClientMessage::set_has_getaudiooutputdevicesreq() {
  _impl_._oneof_case_[0] = kGetAudioOutputDevicesReq;
}
inline void RelayClientMessage::clear_getaudiooutputdevicesreq() {
  if (_internal_has_getaudiooutputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudiooutputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::release_getaudiooutputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  if (_internal_has_getaudiooutputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesReq* temp = _impl_.Msg_.getaudiooutputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudiooutputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioOutputDevicesReq& RelayClientMessage::_internal_getaudiooutputdevicesreq() const {
  return _internal_has_getaudiooutputdevicesreq()
      ? *_impl_.Msg_.getaudiooutputdevicesreq_
      : reinterpret_cast< ::ServerData::GetAudioOutputDevicesReq&>(::ServerData::_GetAudioOutputDevicesReq_default_instance_);
}
inline const ::ServerData::GetAudioOutputDevicesReq& RelayClientMessage::getaudiooutputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  return _internal_getaudiooutputdevicesreq();
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::unsafe_arena_release_getaudiooutputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  if (_internal_has_getaudiooutputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesReq* temp = _impl_.Msg_.getaudiooutputdevicesreq_;
    _impl_.Msg_.getaudiooutputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getaudiooutputdevicesreq(::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq) {
  clear_Msg();
  if (getaudiooutputdevicesreq) {
    set_has_getaudiooutputdevicesreq();
    _impl_.Msg_.getaudiooutputdevicesreq_ = getaudiooutputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::_internal_mutable_getaudiooutputdevicesreq() {
  if (!_internal_has_getaudiooutputdevicesreq()) {
    clear_Msg();
    set_has_getaudiooutputdevicesreq();
    _impl_.Msg_.getaudiooutputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetAudioOutputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudiooutputdevicesreq_;
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::mutable_getaudiooutputdevicesreq() {
  ::ServerData::GetAudioOutputDevicesReq* _msg = _internal_mutable_getaudiooutputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  return _msg;
}

// .ServerData.GetVideoInputDevicesReq GetVideoInputDevicesReq = 32;
inline bool RelayClientMessage::_internal_has_getvideoinputdevicesreq() const {
  return Msg_case() == kGetVideoInputDevicesReq;
}
inline bool RelayClientMessage::has_getvideoinputdevicesreq() const {
  return _internal_has_getvideoinputdevicesreq();
}
inline void RelayClientMessage::set_has_getvideoinputdevicesreq() {
  _impl_._oneof_case_[0] = kGetVideoInputDevicesReq;
}
inline void RelayClientMessage::clear_getvideoinputdevicesreq() {
  if (_internal_has_getvideoinputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getvideoinputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::release_getvideoinputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  if (_internal_has_getvideoinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesReq* temp = _impl_.Msg_.getvideoinputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getvideoinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetVideoInputDevicesReq& RelayClientMessage::_internal_getvideoinputdevicesreq() const {
  return _internal_has_getvideoinputdevicesreq()
      ? *_impl_.Msg_.getvideoinputdevicesreq_
      : reinterpret_cast< ::ServerData::GetVideoInputDevicesReq&>(::ServerData::_GetVideoInputDevicesReq_default_instance_);
}
inline const ::ServerData::GetVideoInputDevicesReq& RelayClientMessage::getvideoinputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  return _internal_getvideoinputdevicesreq();
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::unsafe_arena_release_getvideoinputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  if (_internal_has_getvideoinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesReq* temp = _impl_.Msg_.getvideoinputdevicesreq_;
    _impl_.Msg_.getvideoinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getvideoinputdevicesreq(::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq) {
  clear_Msg();
  if (getvideoinputdevicesreq) {
    set_has_getvideoinputdevicesreq();
    _impl_.Msg_.getvideoinputdevicesreq_ = getvideoinputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::_internal_mutable_getvideoinputdevicesreq() {
  if (!_internal_has_getvideoinputdevicesreq()) {
    clear_Msg();
    set_has_getvideoinputdevicesreq();
    _impl_.Msg_.getvideoinputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetVideoInputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getvideoinputdevicesreq_;
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::mutable_getvideoinputdevicesreq() {
  ::ServerData::GetVideoInputDevicesReq* _msg = _internal_mutable_getvideoinputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  return _msg;
}

// .ServerData.SetAudioInputDeviceReq SetAudioInputDeviceReq = 33;
inline bool RelayClientMessage::_internal_has_setaudioinputdevicereq() const {
  return Msg_case() == kSetAudioInputDeviceReq;
}
inline bool RelayClientMessage::has_setaudioinputdevicereq() const {
  return _internal_has_setaudioinputdevicereq();
}
inline void RelayClientMessage::set_has_setaudioinputdevicereq() {
  _impl_._oneof_case_[0] = kSetAudioInputDeviceReq;
}
inline void RelayClientMessage::clear_setaudioinputdevicereq() {
  if (_internal_has_setaudioinputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setaudioinputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::release_setaudioinputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  if (_internal_has_setaudioinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioInputDeviceReq* temp = _impl_.Msg_.setaudioinputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setaudioinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetAudioInputDeviceReq& RelayClientMessage::_internal_setaudioinputdevicereq() const {
  return _internal_has_setaudioinputdevicereq()
      ? *_impl_.Msg_.setaudioinputdevicereq_
      : reinterpret_cast< ::ServerData::SetAudioInputDeviceReq&>(::ServerData::_SetAudioInputDeviceReq_default_instance_);
}
inline const ::ServerData::SetAudioInputDeviceReq& RelayClientMessage::setaudioinputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  return _internal_setaudioinputdevicereq();
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::unsafe_arena_release_setaudioinputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  if (_internal_has_setaudioinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioInputDeviceReq* temp = _impl_.Msg_.setaudioinputdevicereq_;
    _impl_.Msg_.setaudioinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setaudioinputdevicereq(::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq) {
  clear_Msg();
  if (setaudioinputdevicereq) {
    set_has_setaudioinputdevicereq();
    _impl_.Msg_.setaudioinputdevicereq_ = setaudioinputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::_internal_mutable_setaudioinputdevicereq() {
  if (!_internal_has_setaudioinputdevicereq()) {
    clear_Msg();
    set_has_setaudioinputdevicereq();
    _impl_.Msg_.setaudioinputdevicereq_ = CreateMaybeMessage< ::ServerData::SetAudioInputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setaudioinputdevicereq_;
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::mutable_setaudioinputdevicereq() {
  ::ServerData::SetAudioInputDeviceReq* _msg = _internal_mutable_setaudioinputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  return _msg;
}

// .ServerData.SetAudioOutputDeviceReq SetAudioOutputDeviceReq = 34;
inline bool RelayClientMessage::_internal_has_setaudiooutputdevicereq() const {
  return Msg_case() == kSetAudioOutputDeviceReq;
}
inline bool RelayClientMessage::has_setaudiooutputdevicereq() const {
  return _internal_has_setaudiooutputdevicereq();
}
inline void RelayClientMessage::set_has_setaudiooutputdevicereq() {
  _impl_._oneof_case_[0] = kSetAudioOutputDeviceReq;
}
inline void RelayClientMessage::clear_setaudiooutputdevicereq() {
  if (_internal_has_setaudiooutputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setaudiooutputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::release_setaudiooutputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  if (_internal_has_setaudiooutputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioOutputDeviceReq* temp = _impl_.Msg_.setaudiooutputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setaudiooutputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetAudioOutputDeviceReq& RelayClientMessage::_internal_setaudiooutputdevicereq() const {
  return _internal_has_setaudiooutputdevicereq()
      ? *_impl_.Msg_.setaudiooutputdevicereq_
      : reinterpret_cast< ::ServerData::SetAudioOutputDeviceReq&>(::ServerData::_SetAudioOutputDeviceReq_default_instance_);
}
inline const ::ServerData::SetAudioOutputDeviceReq& RelayClientMessage::setaudiooutputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  return _internal_setaudiooutputdevicereq();
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::unsafe_arena_release_setaudiooutputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  if (_internal_has_setaudiooutputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioOutputDeviceReq* temp = _impl_.Msg_.setaudiooutputdevicereq_;
    _impl_.Msg_.setaudiooutputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setaudiooutputdevicereq(::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq) {
  clear_Msg();
  if (setaudiooutputdevicereq) {
    set_has_setaudiooutputdevicereq();
    _impl_.Msg_.setaudiooutputdevicereq_ = setaudiooutputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::_internal_mutable_setaudiooutputdevicereq() {
  if (!_internal_has_setaudiooutputdevicereq()) {
    clear_Msg();
    set_has_setaudiooutputdevicereq();
    _impl_.Msg_.setaudiooutputdevicereq_ = CreateMaybeMessage< ::ServerData::SetAudioOutputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setaudiooutputdevicereq_;
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::mutable_setaudiooutputdevicereq() {
  ::ServerData::SetAudioOutputDeviceReq* _msg = _internal_mutable_setaudiooutputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  return _msg;
}

// .ServerData.SetVideoInputDeviceReq SetVideoInputDeviceReq = 35;
inline bool RelayClientMessage::_internal_has_setvideoinputdevicereq() const {
  return Msg_case() == kSetVideoInputDeviceReq;
}
inline bool RelayClientMessage::has_setvideoinputdevicereq() const {
  return _internal_has_setvideoinputdevicereq();
}
inline void RelayClientMessage::set_has_setvideoinputdevicereq() {
  _impl_._oneof_case_[0] = kSetVideoInputDeviceReq;
}
inline void RelayClientMessage::clear_setvideoinputdevicereq() {
  if (_internal_has_setvideoinputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setvideoinputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::release_setvideoinputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  if (_internal_has_setvideoinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetVideoInputDeviceReq* temp = _impl_.Msg_.setvideoinputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setvideoinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetVideoInputDeviceReq& RelayClientMessage::_internal_setvideoinputdevicereq() const {
  return _internal_has_setvideoinputdevicereq()
      ? *_impl_.Msg_.setvideoinputdevicereq_
      : reinterpret_cast< ::ServerData::SetVideoInputDeviceReq&>(::ServerData::_SetVideoInputDeviceReq_default_instance_);
}
inline const ::ServerData::SetVideoInputDeviceReq& RelayClientMessage::setvideoinputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  return _internal_setvideoinputdevicereq();
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::unsafe_arena_release_setvideoinputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  if (_internal_has_setvideoinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetVideoInputDeviceReq* temp = _impl_.Msg_.setvideoinputdevicereq_;
    _impl_.Msg_.setvideoinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setvideoinputdevicereq(::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq) {
  clear_Msg();
  if (setvideoinputdevicereq) {
    set_has_setvideoinputdevicereq();
    _impl_.Msg_.setvideoinputdevicereq_ = setvideoinputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::_internal_mutable_setvideoinputdevicereq() {
  if (!_internal_has_setvideoinputdevicereq()) {
    clear_Msg();
    set_has_setvideoinputdevicereq();
    _impl_.Msg_.setvideoinputdevicereq_ = CreateMaybeMessage< ::ServerData::SetVideoInputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setvideoinputdevicereq_;
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::mutable_setvideoinputdevicereq() {
  ::ServerData::SetVideoInputDeviceReq* _msg = _internal_mutable_setvideoinputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  return _msg;
}

// .ServerData.DefinePropertyDefaultValue DefinePropertyDefaultValue = 50;
inline bool RelayClientMessage::_internal_has_definepropertydefaultvalue() const {
  return Msg_case() == kDefinePropertyDefaultValue;
}
inline bool RelayClientMessage::has_definepropertydefaultvalue() const {
  return _internal_has_definepropertydefaultvalue();
}
inline void RelayClientMessage::set_has_definepropertydefaultvalue() {
  _impl_._oneof_case_[0] = kDefinePropertyDefaultValue;
}
inline void RelayClientMessage::clear_definepropertydefaultvalue() {
  if (_internal_has_definepropertydefaultvalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.definepropertydefaultvalue_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::release_definepropertydefaultvalue() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  if (_internal_has_definepropertydefaultvalue()) {
    clear_has_Msg();
    ::ServerData::DefinePropertyDefaultValue* temp = _impl_.Msg_.definepropertydefaultvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.definepropertydefaultvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::DefinePropertyDefaultValue& RelayClientMessage::_internal_definepropertydefaultvalue() const {
  return _internal_has_definepropertydefaultvalue()
      ? *_impl_.Msg_.definepropertydefaultvalue_
      : reinterpret_cast< ::ServerData::DefinePropertyDefaultValue&>(::ServerData::_DefinePropertyDefaultValue_default_instance_);
}
inline const ::ServerData::DefinePropertyDefaultValue& RelayClientMessage::definepropertydefaultvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  return _internal_definepropertydefaultvalue();
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::unsafe_arena_release_definepropertydefaultvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  if (_internal_has_definepropertydefaultvalue()) {
    clear_has_Msg();
    ::ServerData::DefinePropertyDefaultValue* temp = _impl_.Msg_.definepropertydefaultvalue_;
    _impl_.Msg_.definepropertydefaultvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_definepropertydefaultvalue(::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue) {
  clear_Msg();
  if (definepropertydefaultvalue) {
    set_has_definepropertydefaultvalue();
    _impl_.Msg_.definepropertydefaultvalue_ = definepropertydefaultvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::_internal_mutable_definepropertydefaultvalue() {
  if (!_internal_has_definepropertydefaultvalue()) {
    clear_Msg();
    set_has_definepropertydefaultvalue();
    _impl_.Msg_.definepropertydefaultvalue_ = CreateMaybeMessage< ::ServerData::DefinePropertyDefaultValue >(GetArenaForAllocation());
  }
  return _impl_.Msg_.definepropertydefaultvalue_;
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::mutable_definepropertydefaultvalue() {
  ::ServerData::DefinePropertyDefaultValue* _msg = _internal_mutable_definepropertydefaultvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  return _msg;
}

// .ServerData.PostPropertyUpdate PostPropertyUpdate = 53;
inline bool RelayClientMessage::_internal_has_postpropertyupdate() const {
  return Msg_case() == kPostPropertyUpdate;
}
inline bool RelayClientMessage::has_postpropertyupdate() const {
  return _internal_has_postpropertyupdate();
}
inline void RelayClientMessage::set_has_postpropertyupdate() {
  _impl_._oneof_case_[0] = kPostPropertyUpdate;
}
inline void RelayClientMessage::clear_postpropertyupdate() {
  if (_internal_has_postpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::release_postpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostPropertyUpdate)
  if (_internal_has_postpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::PostPropertyUpdate* temp = _impl_.Msg_.postpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostPropertyUpdate& RelayClientMessage::_internal_postpropertyupdate() const {
  return _internal_has_postpropertyupdate()
      ? *_impl_.Msg_.postpropertyupdate_
      : reinterpret_cast< ::ServerData::PostPropertyUpdate&>(::ServerData::_PostPropertyUpdate_default_instance_);
}
inline const ::ServerData::PostPropertyUpdate& RelayClientMessage::postpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostPropertyUpdate)
  return _internal_postpropertyupdate();
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::unsafe_arena_release_postpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostPropertyUpdate)
  if (_internal_has_postpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::PostPropertyUpdate* temp = _impl_.Msg_.postpropertyupdate_;
    _impl_.Msg_.postpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postpropertyupdate(::ServerData::PostPropertyUpdate* postpropertyupdate) {
  clear_Msg();
  if (postpropertyupdate) {
    set_has_postpropertyupdate();
    _impl_.Msg_.postpropertyupdate_ = postpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostPropertyUpdate)
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::_internal_mutable_postpropertyupdate() {
  if (!_internal_has_postpropertyupdate()) {
    clear_Msg();
    set_has_postpropertyupdate();
    _impl_.Msg_.postpropertyupdate_ = CreateMaybeMessage< ::ServerData::PostPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postpropertyupdate_;
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::mutable_postpropertyupdate() {
  ::ServerData::PostPropertyUpdate* _msg = _internal_mutable_postpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostPropertyUpdate)
  return _msg;
}

// .ServerData.BeginTransientPropertyUpdate BeginTransientPropertyUpdate = 54;
inline bool RelayClientMessage::_internal_has_begintransientpropertyupdate() const {
  return Msg_case() == kBeginTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_begintransientpropertyupdate() const {
  return _internal_has_begintransientpropertyupdate();
}
inline void RelayClientMessage::set_has_begintransientpropertyupdate() {
  _impl_._oneof_case_[0] = kBeginTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_begintransientpropertyupdate() {
  if (_internal_has_begintransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.begintransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::release_begintransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  if (_internal_has_begintransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::BeginTransientPropertyUpdate* temp = _impl_.Msg_.begintransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.begintransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::BeginTransientPropertyUpdate& RelayClientMessage::_internal_begintransientpropertyupdate() const {
  return _internal_has_begintransientpropertyupdate()
      ? *_impl_.Msg_.begintransientpropertyupdate_
      : reinterpret_cast< ::ServerData::BeginTransientPropertyUpdate&>(::ServerData::_BeginTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::BeginTransientPropertyUpdate& RelayClientMessage::begintransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  return _internal_begintransientpropertyupdate();
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_begintransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  if (_internal_has_begintransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::BeginTransientPropertyUpdate* temp = _impl_.Msg_.begintransientpropertyupdate_;
    _impl_.Msg_.begintransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_begintransientpropertyupdate(::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate) {
  clear_Msg();
  if (begintransientpropertyupdate) {
    set_has_begintransientpropertyupdate();
    _impl_.Msg_.begintransientpropertyupdate_ = begintransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::_internal_mutable_begintransientpropertyupdate() {
  if (!_internal_has_begintransientpropertyupdate()) {
    clear_Msg();
    set_has_begintransientpropertyupdate();
    _impl_.Msg_.begintransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::BeginTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.begintransientpropertyupdate_;
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::mutable_begintransientpropertyupdate() {
  ::ServerData::BeginTransientPropertyUpdate* _msg = _internal_mutable_begintransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  return _msg;
}

// .ServerData.ContinueTransientPropertyUpdate ContinueTransientPropertyUpdate = 55;
inline bool RelayClientMessage::_internal_has_continuetransientpropertyupdate() const {
  return Msg_case() == kContinueTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_continuetransientpropertyupdate() const {
  return _internal_has_continuetransientpropertyupdate();
}
inline void RelayClientMessage::set_has_continuetransientpropertyupdate() {
  _impl_._oneof_case_[0] = kContinueTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_continuetransientpropertyupdate() {
  if (_internal_has_continuetransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.continuetransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::release_continuetransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  if (_internal_has_continuetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::ContinueTransientPropertyUpdate* temp = _impl_.Msg_.continuetransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.continuetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ContinueTransientPropertyUpdate& RelayClientMessage::_internal_continuetransientpropertyupdate() const {
  return _internal_has_continuetransientpropertyupdate()
      ? *_impl_.Msg_.continuetransientpropertyupdate_
      : reinterpret_cast< ::ServerData::ContinueTransientPropertyUpdate&>(::ServerData::_ContinueTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::ContinueTransientPropertyUpdate& RelayClientMessage::continuetransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  return _internal_continuetransientpropertyupdate();
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_continuetransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  if (_internal_has_continuetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::ContinueTransientPropertyUpdate* temp = _impl_.Msg_.continuetransientpropertyupdate_;
    _impl_.Msg_.continuetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_continuetransientpropertyupdate(::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate) {
  clear_Msg();
  if (continuetransientpropertyupdate) {
    set_has_continuetransientpropertyupdate();
    _impl_.Msg_.continuetransientpropertyupdate_ = continuetransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::_internal_mutable_continuetransientpropertyupdate() {
  if (!_internal_has_continuetransientpropertyupdate()) {
    clear_Msg();
    set_has_continuetransientpropertyupdate();
    _impl_.Msg_.continuetransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::ContinueTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.continuetransientpropertyupdate_;
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::mutable_continuetransientpropertyupdate() {
  ::ServerData::ContinueTransientPropertyUpdate* _msg = _internal_mutable_continuetransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  return _msg;
}

// .ServerData.FinalizeTransientPropertyUpdate FinalizeTransientPropertyUpdate = 56;
inline bool RelayClientMessage::_internal_has_finalizetransientpropertyupdate() const {
  return Msg_case() == kFinalizeTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_finalizetransientpropertyupdate() const {
  return _internal_has_finalizetransientpropertyupdate();
}
inline void RelayClientMessage::set_has_finalizetransientpropertyupdate() {
  _impl_._oneof_case_[0] = kFinalizeTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_finalizetransientpropertyupdate() {
  if (_internal_has_finalizetransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.finalizetransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::release_finalizetransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  if (_internal_has_finalizetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::FinalizeTransientPropertyUpdate* temp = _impl_.Msg_.finalizetransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.finalizetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FinalizeTransientPropertyUpdate& RelayClientMessage::_internal_finalizetransientpropertyupdate() const {
  return _internal_has_finalizetransientpropertyupdate()
      ? *_impl_.Msg_.finalizetransientpropertyupdate_
      : reinterpret_cast< ::ServerData::FinalizeTransientPropertyUpdate&>(::ServerData::_FinalizeTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::FinalizeTransientPropertyUpdate& RelayClientMessage::finalizetransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  return _internal_finalizetransientpropertyupdate();
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_finalizetransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  if (_internal_has_finalizetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::FinalizeTransientPropertyUpdate* temp = _impl_.Msg_.finalizetransientpropertyupdate_;
    _impl_.Msg_.finalizetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_finalizetransientpropertyupdate(::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate) {
  clear_Msg();
  if (finalizetransientpropertyupdate) {
    set_has_finalizetransientpropertyupdate();
    _impl_.Msg_.finalizetransientpropertyupdate_ = finalizetransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::_internal_mutable_finalizetransientpropertyupdate() {
  if (!_internal_has_finalizetransientpropertyupdate()) {
    clear_Msg();
    set_has_finalizetransientpropertyupdate();
    _impl_.Msg_.finalizetransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::FinalizeTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.finalizetransientpropertyupdate_;
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::mutable_finalizetransientpropertyupdate() {
  ::ServerData::FinalizeTransientPropertyUpdate* _msg = _internal_mutable_finalizetransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  return _msg;
}

// .ServerData.CancelTransientPropertyUpdate CancelTransientPropertyUpdate = 57;
inline bool RelayClientMessage::_internal_has_canceltransientpropertyupdate() const {
  return Msg_case() == kCancelTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_canceltransientpropertyupdate() const {
  return _internal_has_canceltransientpropertyupdate();
}
inline void RelayClientMessage::set_has_canceltransientpropertyupdate() {
  _impl_._oneof_case_[0] = kCancelTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_canceltransientpropertyupdate() {
  if (_internal_has_canceltransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.canceltransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::release_canceltransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  if (_internal_has_canceltransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::CancelTransientPropertyUpdate* temp = _impl_.Msg_.canceltransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.canceltransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CancelTransientPropertyUpdate& RelayClientMessage::_internal_canceltransientpropertyupdate() const {
  return _internal_has_canceltransientpropertyupdate()
      ? *_impl_.Msg_.canceltransientpropertyupdate_
      : reinterpret_cast< ::ServerData::CancelTransientPropertyUpdate&>(::ServerData::_CancelTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::CancelTransientPropertyUpdate& RelayClientMessage::canceltransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  return _internal_canceltransientpropertyupdate();
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_canceltransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  if (_internal_has_canceltransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::CancelTransientPropertyUpdate* temp = _impl_.Msg_.canceltransientpropertyupdate_;
    _impl_.Msg_.canceltransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_canceltransientpropertyupdate(::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate) {
  clear_Msg();
  if (canceltransientpropertyupdate) {
    set_has_canceltransientpropertyupdate();
    _impl_.Msg_.canceltransientpropertyupdate_ = canceltransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::_internal_mutable_canceltransientpropertyupdate() {
  if (!_internal_has_canceltransientpropertyupdate()) {
    clear_Msg();
    set_has_canceltransientpropertyupdate();
    _impl_.Msg_.canceltransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::CancelTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.canceltransientpropertyupdate_;
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::mutable_canceltransientpropertyupdate() {
  ::ServerData::CancelTransientPropertyUpdate* _msg = _internal_mutable_canceltransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  return _msg;
}

// .ServerData.UpdateLocalUserMuted UpdateLocalUserMuted = 60;
inline bool RelayClientMessage::_internal_has_updatelocalusermuted() const {
  return Msg_case() == kUpdateLocalUserMuted;
}
inline bool RelayClientMessage::has_updatelocalusermuted() const {
  return _internal_has_updatelocalusermuted();
}
inline void RelayClientMessage::set_has_updatelocalusermuted() {
  _impl_._oneof_case_[0] = kUpdateLocalUserMuted;
}
inline void RelayClientMessage::clear_updatelocalusermuted() {
  if (_internal_has_updatelocalusermuted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocalusermuted_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::release_updatelocalusermuted() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  if (_internal_has_updatelocalusermuted()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserMuted* temp = _impl_.Msg_.updatelocalusermuted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocalusermuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserMuted& RelayClientMessage::_internal_updatelocalusermuted() const {
  return _internal_has_updatelocalusermuted()
      ? *_impl_.Msg_.updatelocalusermuted_
      : reinterpret_cast< ::ServerData::UpdateLocalUserMuted&>(::ServerData::_UpdateLocalUserMuted_default_instance_);
}
inline const ::ServerData::UpdateLocalUserMuted& RelayClientMessage::updatelocalusermuted() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  return _internal_updatelocalusermuted();
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::unsafe_arena_release_updatelocalusermuted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  if (_internal_has_updatelocalusermuted()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserMuted* temp = _impl_.Msg_.updatelocalusermuted_;
    _impl_.Msg_.updatelocalusermuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocalusermuted(::ServerData::UpdateLocalUserMuted* updatelocalusermuted) {
  clear_Msg();
  if (updatelocalusermuted) {
    set_has_updatelocalusermuted();
    _impl_.Msg_.updatelocalusermuted_ = updatelocalusermuted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserMuted)
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::_internal_mutable_updatelocalusermuted() {
  if (!_internal_has_updatelocalusermuted()) {
    clear_Msg();
    set_has_updatelocalusermuted();
    _impl_.Msg_.updatelocalusermuted_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserMuted >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocalusermuted_;
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::mutable_updatelocalusermuted() {
  ::ServerData::UpdateLocalUserMuted* _msg = _internal_mutable_updatelocalusermuted();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  return _msg;
}

// .ServerData.UpdateLocalUserCoPresence UpdateLocalUserCoPresence = 61;
inline bool RelayClientMessage::_internal_has_updatelocalusercopresence() const {
  return Msg_case() == kUpdateLocalUserCoPresence;
}
inline bool RelayClientMessage::has_updatelocalusercopresence() const {
  return _internal_has_updatelocalusercopresence();
}
inline void RelayClientMessage::set_has_updatelocalusercopresence() {
  _impl_._oneof_case_[0] = kUpdateLocalUserCoPresence;
}
inline void RelayClientMessage::clear_updatelocalusercopresence() {
  if (_internal_has_updatelocalusercopresence()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocalusercopresence_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::release_updatelocalusercopresence() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  if (_internal_has_updatelocalusercopresence()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserCoPresence* temp = _impl_.Msg_.updatelocalusercopresence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocalusercopresence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserCoPresence& RelayClientMessage::_internal_updatelocalusercopresence() const {
  return _internal_has_updatelocalusercopresence()
      ? *_impl_.Msg_.updatelocalusercopresence_
      : reinterpret_cast< ::ServerData::UpdateLocalUserCoPresence&>(::ServerData::_UpdateLocalUserCoPresence_default_instance_);
}
inline const ::ServerData::UpdateLocalUserCoPresence& RelayClientMessage::updatelocalusercopresence() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  return _internal_updatelocalusercopresence();
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::unsafe_arena_release_updatelocalusercopresence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  if (_internal_has_updatelocalusercopresence()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserCoPresence* temp = _impl_.Msg_.updatelocalusercopresence_;
    _impl_.Msg_.updatelocalusercopresence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocalusercopresence(::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence) {
  clear_Msg();
  if (updatelocalusercopresence) {
    set_has_updatelocalusercopresence();
    _impl_.Msg_.updatelocalusercopresence_ = updatelocalusercopresence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::_internal_mutable_updatelocalusercopresence() {
  if (!_internal_has_updatelocalusercopresence()) {
    clear_Msg();
    set_has_updatelocalusercopresence();
    _impl_.Msg_.updatelocalusercopresence_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserCoPresence >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocalusercopresence_;
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::mutable_updatelocalusercopresence() {
  ::ServerData::UpdateLocalUserCoPresence* _msg = _internal_mutable_updatelocalusercopresence();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  return _msg;
}

// .ServerData.UpdateLocalUserStreamState UpdateLocalUserStreamState = 62;
inline bool RelayClientMessage::_internal_has_updatelocaluserstreamstate() const {
  return Msg_case() == kUpdateLocalUserStreamState;
}
inline bool RelayClientMessage::has_updatelocaluserstreamstate() const {
  return _internal_has_updatelocaluserstreamstate();
}
inline void RelayClientMessage::set_has_updatelocaluserstreamstate() {
  _impl_._oneof_case_[0] = kUpdateLocalUserStreamState;
}
inline void RelayClientMessage::clear_updatelocaluserstreamstate() {
  if (_internal_has_updatelocaluserstreamstate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocaluserstreamstate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::release_updatelocaluserstreamstate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  if (_internal_has_updatelocaluserstreamstate()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserStreamState* temp = _impl_.Msg_.updatelocaluserstreamstate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocaluserstreamstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserStreamState& RelayClientMessage::_internal_updatelocaluserstreamstate() const {
  return _internal_has_updatelocaluserstreamstate()
      ? *_impl_.Msg_.updatelocaluserstreamstate_
      : reinterpret_cast< ::ServerData::UpdateLocalUserStreamState&>(::ServerData::_UpdateLocalUserStreamState_default_instance_);
}
inline const ::ServerData::UpdateLocalUserStreamState& RelayClientMessage::updatelocaluserstreamstate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  return _internal_updatelocaluserstreamstate();
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::unsafe_arena_release_updatelocaluserstreamstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  if (_internal_has_updatelocaluserstreamstate()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserStreamState* temp = _impl_.Msg_.updatelocaluserstreamstate_;
    _impl_.Msg_.updatelocaluserstreamstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocaluserstreamstate(::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate) {
  clear_Msg();
  if (updatelocaluserstreamstate) {
    set_has_updatelocaluserstreamstate();
    _impl_.Msg_.updatelocaluserstreamstate_ = updatelocaluserstreamstate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::_internal_mutable_updatelocaluserstreamstate() {
  if (!_internal_has_updatelocaluserstreamstate()) {
    clear_Msg();
    set_has_updatelocaluserstreamstate();
    _impl_.Msg_.updatelocaluserstreamstate_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserStreamState >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocaluserstreamstate_;
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::mutable_updatelocaluserstreamstate() {
  ::ServerData::UpdateLocalUserStreamState* _msg = _internal_mutable_updatelocaluserstreamstate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  return _msg;
}

// .ServerData.PostCreateObject PostCreateObject = 70;
inline bool RelayClientMessage::_internal_has_postcreateobject() const {
  return Msg_case() == kPostCreateObject;
}
inline bool RelayClientMessage::has_postcreateobject() const {
  return _internal_has_postcreateobject();
}
inline void RelayClientMessage::set_has_postcreateobject() {
  _impl_._oneof_case_[0] = kPostCreateObject;
}
inline void RelayClientMessage::clear_postcreateobject() {
  if (_internal_has_postcreateobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postcreateobject_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostCreateObject* RelayClientMessage::release_postcreateobject() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostCreateObject)
  if (_internal_has_postcreateobject()) {
    clear_has_Msg();
    ::ServerData::PostCreateObject* temp = _impl_.Msg_.postcreateobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postcreateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostCreateObject& RelayClientMessage::_internal_postcreateobject() const {
  return _internal_has_postcreateobject()
      ? *_impl_.Msg_.postcreateobject_
      : reinterpret_cast< ::ServerData::PostCreateObject&>(::ServerData::_PostCreateObject_default_instance_);
}
inline const ::ServerData::PostCreateObject& RelayClientMessage::postcreateobject() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostCreateObject)
  return _internal_postcreateobject();
}
inline ::ServerData::PostCreateObject* RelayClientMessage::unsafe_arena_release_postcreateobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostCreateObject)
  if (_internal_has_postcreateobject()) {
    clear_has_Msg();
    ::ServerData::PostCreateObject* temp = _impl_.Msg_.postcreateobject_;
    _impl_.Msg_.postcreateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postcreateobject(::ServerData::PostCreateObject* postcreateobject) {
  clear_Msg();
  if (postcreateobject) {
    set_has_postcreateobject();
    _impl_.Msg_.postcreateobject_ = postcreateobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostCreateObject)
}
inline ::ServerData::PostCreateObject* RelayClientMessage::_internal_mutable_postcreateobject() {
  if (!_internal_has_postcreateobject()) {
    clear_Msg();
    set_has_postcreateobject();
    _impl_.Msg_.postcreateobject_ = CreateMaybeMessage< ::ServerData::PostCreateObject >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postcreateobject_;
}
inline ::ServerData::PostCreateObject* RelayClientMessage::mutable_postcreateobject() {
  ::ServerData::PostCreateObject* _msg = _internal_mutable_postcreateobject();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostCreateObject)
  return _msg;
}

// .ServerData.PostRemoveObject PostRemoveObject = 71;
inline bool RelayClientMessage::_internal_has_postremoveobject() const {
  return Msg_case() == kPostRemoveObject;
}
inline bool RelayClientMessage::has_postremoveobject() const {
  return _internal_has_postremoveobject();
}
inline void RelayClientMessage::set_has_postremoveobject() {
  _impl_._oneof_case_[0] = kPostRemoveObject;
}
inline void RelayClientMessage::clear_postremoveobject() {
  if (_internal_has_postremoveobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postremoveobject_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::release_postremoveobject() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostRemoveObject)
  if (_internal_has_postremoveobject()) {
    clear_has_Msg();
    ::ServerData::PostRemoveObject* temp = _impl_.Msg_.postremoveobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postremoveobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostRemoveObject& RelayClientMessage::_internal_postremoveobject() const {
  return _internal_has_postremoveobject()
      ? *_impl_.Msg_.postremoveobject_
      : reinterpret_cast< ::ServerData::PostRemoveObject&>(::ServerData::_PostRemoveObject_default_instance_);
}
inline const ::ServerData::PostRemoveObject& RelayClientMessage::postremoveobject() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostRemoveObject)
  return _internal_postremoveobject();
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::unsafe_arena_release_postremoveobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostRemoveObject)
  if (_internal_has_postremoveobject()) {
    clear_has_Msg();
    ::ServerData::PostRemoveObject* temp = _impl_.Msg_.postremoveobject_;
    _impl_.Msg_.postremoveobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postremoveobject(::ServerData::PostRemoveObject* postremoveobject) {
  clear_Msg();
  if (postremoveobject) {
    set_has_postremoveobject();
    _impl_.Msg_.postremoveobject_ = postremoveobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostRemoveObject)
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::_internal_mutable_postremoveobject() {
  if (!_internal_has_postremoveobject()) {
    clear_Msg();
    set_has_postremoveobject();
    _impl_.Msg_.postremoveobject_ = CreateMaybeMessage< ::ServerData::PostRemoveObject >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postremoveobject_;
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::mutable_postremoveobject() {
  ::ServerData::PostRemoveObject* _msg = _internal_mutable_postremoveobject();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostRemoveObject)
  return _msg;
}

// .ServerData.PermissionStatusReq PermissionStatusReq = 90;
inline bool RelayClientMessage::_internal_has_permissionstatusreq() const {
  return Msg_case() == kPermissionStatusReq;
}
inline bool RelayClientMessage::has_permissionstatusreq() const {
  return _internal_has_permissionstatusreq();
}
inline void RelayClientMessage::set_has_permissionstatusreq() {
  _impl_._oneof_case_[0] = kPermissionStatusReq;
}
inline void RelayClientMessage::clear_permissionstatusreq() {
  if (_internal_has_permissionstatusreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.permissionstatusreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::release_permissionstatusreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PermissionStatusReq)
  if (_internal_has_permissionstatusreq()) {
    clear_has_Msg();
    ::ServerData::PermissionStatusReq* temp = _impl_.Msg_.permissionstatusreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.permissionstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PermissionStatusReq& RelayClientMessage::_internal_permissionstatusreq() const {
  return _internal_has_permissionstatusreq()
      ? *_impl_.Msg_.permissionstatusreq_
      : reinterpret_cast< ::ServerData::PermissionStatusReq&>(::ServerData::_PermissionStatusReq_default_instance_);
}
inline const ::ServerData::PermissionStatusReq& RelayClientMessage::permissionstatusreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PermissionStatusReq)
  return _internal_permissionstatusreq();
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::unsafe_arena_release_permissionstatusreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PermissionStatusReq)
  if (_internal_has_permissionstatusreq()) {
    clear_has_Msg();
    ::ServerData::PermissionStatusReq* temp = _impl_.Msg_.permissionstatusreq_;
    _impl_.Msg_.permissionstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_permissionstatusreq(::ServerData::PermissionStatusReq* permissionstatusreq) {
  clear_Msg();
  if (permissionstatusreq) {
    set_has_permissionstatusreq();
    _impl_.Msg_.permissionstatusreq_ = permissionstatusreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PermissionStatusReq)
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::_internal_mutable_permissionstatusreq() {
  if (!_internal_has_permissionstatusreq()) {
    clear_Msg();
    set_has_permissionstatusreq();
    _impl_.Msg_.permissionstatusreq_ = CreateMaybeMessage< ::ServerData::PermissionStatusReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.permissionstatusreq_;
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::mutable_permissionstatusreq() {
  ::ServerData::PermissionStatusReq* _msg = _internal_mutable_permissionstatusreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PermissionStatusReq)
  return _msg;
}

// .ServerData.AllJoinableSpacesReq AllJoinableSpacesReq = 100;
inline bool RelayClientMessage::_internal_has_alljoinablespacesreq() const {
  return Msg_case() == kAllJoinableSpacesReq;
}
inline bool RelayClientMessage::has_alljoinablespacesreq() const {
  return _internal_has_alljoinablespacesreq();
}
inline void RelayClientMessage::set_has_alljoinablespacesreq() {
  _impl_._oneof_case_[0] = kAllJoinableSpacesReq;
}
inline void RelayClientMessage::clear_alljoinablespacesreq() {
  if (_internal_has_alljoinablespacesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.alljoinablespacesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::release_alljoinablespacesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  if (_internal_has_alljoinablespacesreq()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesReq* temp = _impl_.Msg_.alljoinablespacesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.alljoinablespacesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AllJoinableSpacesReq& RelayClientMessage::_internal_alljoinablespacesreq() const {
  return _internal_has_alljoinablespacesreq()
      ? *_impl_.Msg_.alljoinablespacesreq_
      : reinterpret_cast< ::ServerData::AllJoinableSpacesReq&>(::ServerData::_AllJoinableSpacesReq_default_instance_);
}
inline const ::ServerData::AllJoinableSpacesReq& RelayClientMessage::alljoinablespacesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  return _internal_alljoinablespacesreq();
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::unsafe_arena_release_alljoinablespacesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  if (_internal_has_alljoinablespacesreq()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesReq* temp = _impl_.Msg_.alljoinablespacesreq_;
    _impl_.Msg_.alljoinablespacesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_alljoinablespacesreq(::ServerData::AllJoinableSpacesReq* alljoinablespacesreq) {
  clear_Msg();
  if (alljoinablespacesreq) {
    set_has_alljoinablespacesreq();
    _impl_.Msg_.alljoinablespacesreq_ = alljoinablespacesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AllJoinableSpacesReq)
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::_internal_mutable_alljoinablespacesreq() {
  if (!_internal_has_alljoinablespacesreq()) {
    clear_Msg();
    set_has_alljoinablespacesreq();
    _impl_.Msg_.alljoinablespacesreq_ = CreateMaybeMessage< ::ServerData::AllJoinableSpacesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.alljoinablespacesreq_;
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::mutable_alljoinablespacesreq() {
  ::ServerData::AllJoinableSpacesReq* _msg = _internal_mutable_alljoinablespacesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  return _msg;
}

// .ServerData.FetchFileByIdReq FetchFileByIdReq = 110;
inline bool RelayClientMessage::_internal_has_fetchfilebyidreq() const {
  return Msg_case() == kFetchFileByIdReq;
}
inline bool RelayClientMessage::has_fetchfilebyidreq() const {
  return _internal_has_fetchfilebyidreq();
}
inline void RelayClientMessage::set_has_fetchfilebyidreq() {
  _impl_._oneof_case_[0] = kFetchFileByIdReq;
}
inline void RelayClientMessage::clear_fetchfilebyidreq() {
  if (_internal_has_fetchfilebyidreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::release_fetchfilebyidreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchFileByIdReq)
  if (_internal_has_fetchfilebyidreq()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdReq* temp = _impl_.Msg_.fetchfilebyidreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdReq& RelayClientMessage::_internal_fetchfilebyidreq() const {
  return _internal_has_fetchfilebyidreq()
      ? *_impl_.Msg_.fetchfilebyidreq_
      : reinterpret_cast< ::ServerData::FetchFileByIdReq&>(::ServerData::_FetchFileByIdReq_default_instance_);
}
inline const ::ServerData::FetchFileByIdReq& RelayClientMessage::fetchfilebyidreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchFileByIdReq)
  return _internal_fetchfilebyidreq();
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::unsafe_arena_release_fetchfilebyidreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchFileByIdReq)
  if (_internal_has_fetchfilebyidreq()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdReq* temp = _impl_.Msg_.fetchfilebyidreq_;
    _impl_.Msg_.fetchfilebyidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchfilebyidreq(::ServerData::FetchFileByIdReq* fetchfilebyidreq) {
  clear_Msg();
  if (fetchfilebyidreq) {
    set_has_fetchfilebyidreq();
    _impl_.Msg_.fetchfilebyidreq_ = fetchfilebyidreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchFileByIdReq)
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::_internal_mutable_fetchfilebyidreq() {
  if (!_internal_has_fetchfilebyidreq()) {
    clear_Msg();
    set_has_fetchfilebyidreq();
    _impl_.Msg_.fetchfilebyidreq_ = CreateMaybeMessage< ::ServerData::FetchFileByIdReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidreq_;
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::mutable_fetchfilebyidreq() {
  ::ServerData::FetchFileByIdReq* _msg = _internal_mutable_fetchfilebyidreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchFileByIdReq)
  return _msg;
}

// .ServerData.FetchAllUploadedContentReq FetchAllUploadedContentReq = 111;
inline bool RelayClientMessage::_internal_has_fetchalluploadedcontentreq() const {
  return Msg_case() == kFetchAllUploadedContentReq;
}
inline bool RelayClientMessage::has_fetchalluploadedcontentreq() const {
  return _internal_has_fetchalluploadedcontentreq();
}
inline void RelayClientMessage::set_has_fetchalluploadedcontentreq() {
  _impl_._oneof_case_[0] = kFetchAllUploadedContentReq;
}
inline void RelayClientMessage::clear_fetchalluploadedcontentreq() {
  if (_internal_has_fetchalluploadedcontentreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluploadedcontentreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::release_fetchalluploadedcontentreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  if (_internal_has_fetchalluploadedcontentreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentReq* temp = _impl_.Msg_.fetchalluploadedcontentreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluploadedcontentreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUploadedContentReq& RelayClientMessage::_internal_fetchalluploadedcontentreq() const {
  return _internal_has_fetchalluploadedcontentreq()
      ? *_impl_.Msg_.fetchalluploadedcontentreq_
      : reinterpret_cast< ::ServerData::FetchAllUploadedContentReq&>(::ServerData::_FetchAllUploadedContentReq_default_instance_);
}
inline const ::ServerData::FetchAllUploadedContentReq& RelayClientMessage::fetchalluploadedcontentreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  return _internal_fetchalluploadedcontentreq();
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::unsafe_arena_release_fetchalluploadedcontentreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  if (_internal_has_fetchalluploadedcontentreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentReq* temp = _impl_.Msg_.fetchalluploadedcontentreq_;
    _impl_.Msg_.fetchalluploadedcontentreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchalluploadedcontentreq(::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq) {
  clear_Msg();
  if (fetchalluploadedcontentreq) {
    set_has_fetchalluploadedcontentreq();
    _impl_.Msg_.fetchalluploadedcontentreq_ = fetchalluploadedcontentreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::_internal_mutable_fetchalluploadedcontentreq() {
  if (!_internal_has_fetchalluploadedcontentreq()) {
    clear_Msg();
    set_has_fetchalluploadedcontentreq();
    _impl_.Msg_.fetchalluploadedcontentreq_ = CreateMaybeMessage< ::ServerData::FetchAllUploadedContentReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluploadedcontentreq_;
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::mutable_fetchalluploadedcontentreq() {
  ::ServerData::FetchAllUploadedContentReq* _msg = _internal_mutable_fetchalluploadedcontentreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  return _msg;
}

// .ServerData.UploadLocalFileReq UploadLocalFileReq = 112;
inline bool RelayClientMessage::_internal_has_uploadlocalfilereq() const {
  return Msg_case() == kUploadLocalFileReq;
}
inline bool RelayClientMessage::has_uploadlocalfilereq() const {
  return _internal_has_uploadlocalfilereq();
}
inline void RelayClientMessage::set_has_uploadlocalfilereq() {
  _impl_._oneof_case_[0] = kUploadLocalFileReq;
}
inline void RelayClientMessage::clear_uploadlocalfilereq() {
  if (_internal_has_uploadlocalfilereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uploadlocalfilereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::release_uploadlocalfilereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UploadLocalFileReq)
  if (_internal_has_uploadlocalfilereq()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileReq* temp = _impl_.Msg_.uploadlocalfilereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uploadlocalfilereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UploadLocalFileReq& RelayClientMessage::_internal_uploadlocalfilereq() const {
  return _internal_has_uploadlocalfilereq()
      ? *_impl_.Msg_.uploadlocalfilereq_
      : reinterpret_cast< ::ServerData::UploadLocalFileReq&>(::ServerData::_UploadLocalFileReq_default_instance_);
}
inline const ::ServerData::UploadLocalFileReq& RelayClientMessage::uploadlocalfilereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UploadLocalFileReq)
  return _internal_uploadlocalfilereq();
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::unsafe_arena_release_uploadlocalfilereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UploadLocalFileReq)
  if (_internal_has_uploadlocalfilereq()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileReq* temp = _impl_.Msg_.uploadlocalfilereq_;
    _impl_.Msg_.uploadlocalfilereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_uploadlocalfilereq(::ServerData::UploadLocalFileReq* uploadlocalfilereq) {
  clear_Msg();
  if (uploadlocalfilereq) {
    set_has_uploadlocalfilereq();
    _impl_.Msg_.uploadlocalfilereq_ = uploadlocalfilereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UploadLocalFileReq)
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::_internal_mutable_uploadlocalfilereq() {
  if (!_internal_has_uploadlocalfilereq()) {
    clear_Msg();
    set_has_uploadlocalfilereq();
    _impl_.Msg_.uploadlocalfilereq_ = CreateMaybeMessage< ::ServerData::UploadLocalFileReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uploadlocalfilereq_;
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::mutable_uploadlocalfilereq() {
  ::ServerData::UploadLocalFileReq* _msg = _internal_mutable_uploadlocalfilereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UploadLocalFileReq)
  return _msg;
}

// .ServerData.PostChat PostChat = 120;
inline bool RelayClientMessage::_internal_has_postchat() const {
  return Msg_case() == kPostChat;
}
inline bool RelayClientMessage::has_postchat() const {
  return _internal_has_postchat();
}
inline void RelayClientMessage::set_has_postchat() {
  _impl_._oneof_case_[0] = kPostChat;
}
inline void RelayClientMessage::clear_postchat() {
  if (_internal_has_postchat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postchat_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostChat* RelayClientMessage::release_postchat() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostChat)
  if (_internal_has_postchat()) {
    clear_has_Msg();
    ::ServerData::PostChat* temp = _impl_.Msg_.postchat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostChat& RelayClientMessage::_internal_postchat() const {
  return _internal_has_postchat()
      ? *_impl_.Msg_.postchat_
      : reinterpret_cast< ::ServerData::PostChat&>(::ServerData::_PostChat_default_instance_);
}
inline const ::ServerData::PostChat& RelayClientMessage::postchat() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostChat)
  return _internal_postchat();
}
inline ::ServerData::PostChat* RelayClientMessage::unsafe_arena_release_postchat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostChat)
  if (_internal_has_postchat()) {
    clear_has_Msg();
    ::ServerData::PostChat* temp = _impl_.Msg_.postchat_;
    _impl_.Msg_.postchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postchat(::ServerData::PostChat* postchat) {
  clear_Msg();
  if (postchat) {
    set_has_postchat();
    _impl_.Msg_.postchat_ = postchat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostChat)
}
inline ::ServerData::PostChat* RelayClientMessage::_internal_mutable_postchat() {
  if (!_internal_has_postchat()) {
    clear_Msg();
    set_has_postchat();
    _impl_.Msg_.postchat_ = CreateMaybeMessage< ::ServerData::PostChat >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postchat_;
}
inline ::ServerData::PostChat* RelayClientMessage::mutable_postchat() {
  ::ServerData::PostChat* _msg = _internal_mutable_postchat();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostChat)
  return _msg;
}

inline bool RelayClientMessage::has_Msg() const {
  return Msg_case() != MSG_NOT_SET;
}
inline void RelayClientMessage::clear_has_Msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline RelayClientMessage::MsgCase RelayClientMessage::Msg_case() const {
  return RelayClientMessage::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RelayRemoteMessageBatch

// repeated .ServerData.RelayRemoteMessage Messages = 1;
inline int RelayRemoteMessageBatch::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int RelayRemoteMessageBatch::messages_size() const {
  return _internal_messages_size();
}
inline void RelayRemoteMessageBatch::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessageBatch.Messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >*
RelayRemoteMessageBatch::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayRemoteMessageBatch.Messages)
  return &_impl_.messages_;
}
inline const ::ServerData::RelayRemoteMessage& RelayRemoteMessageBatch::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::ServerData::RelayRemoteMessage& RelayRemoteMessageBatch::messages(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessageBatch.Messages)
  return _internal_messages(index);
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::add_messages() {
  ::ServerData::RelayRemoteMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:ServerData.RelayRemoteMessageBatch.Messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >&
RelayRemoteMessageBatch::messages() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayRemoteMessageBatch.Messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// RelayRemoteMessage

// .ServerData.StatusMessage Message = 1;
inline bool RelayRemoteMessage::_internal_has_message() const {
  return Msg_case() == kMessage;
}
inline bool RelayRemoteMessage::has_message() const {
  return _internal_has_message();
}
inline void RelayRemoteMessage::set_has_message() {
  _impl_._oneof_case_[0] = kMessage;
}
inline void RelayRemoteMessage::clear_message() {
  if (_internal_has_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.message_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::release_message() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.Message)
  if (_internal_has_message()) {
    clear_has_Msg();
    ::ServerData::StatusMessage* temp = _impl_.Msg_.message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::StatusMessage& RelayRemoteMessage::_internal_message() const {
  return _internal_has_message()
      ? *_impl_.Msg_.message_
      : reinterpret_cast< ::ServerData::StatusMessage&>(::ServerData::_StatusMessage_default_instance_);
}
inline const ::ServerData::StatusMessage& RelayRemoteMessage::message() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.Message)
  return _internal_message();
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.Message)
  if (_internal_has_message()) {
    clear_has_Msg();
    ::ServerData::StatusMessage* temp = _impl_.Msg_.message_;
    _impl_.Msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_message(::ServerData::StatusMessage* message) {
  clear_Msg();
  if (message) {
    set_has_message();
    _impl_.Msg_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.Message)
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_Msg();
    set_has_message();
    _impl_.Msg_.message_ = CreateMaybeMessage< ::ServerData::StatusMessage >(GetArenaForAllocation());
  }
  return _impl_.Msg_.message_;
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::mutable_message() {
  ::ServerData::StatusMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.Message)
  return _msg;
}

// .ServerData.AuthenticateResp AuthenticateResp = 2;
inline bool RelayRemoteMessage::_internal_has_authenticateresp() const {
  return Msg_case() == kAuthenticateResp;
}
inline bool RelayRemoteMessage::has_authenticateresp() const {
  return _internal_has_authenticateresp();
}
inline void RelayRemoteMessage::set_has_authenticateresp() {
  _impl_._oneof_case_[0] = kAuthenticateResp;
}
inline void RelayRemoteMessage::clear_authenticateresp() {
  if (_internal_has_authenticateresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::release_authenticateresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AuthenticateResp)
  if (_internal_has_authenticateresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateResp* temp = _impl_.Msg_.authenticateresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateResp& RelayRemoteMessage::_internal_authenticateresp() const {
  return _internal_has_authenticateresp()
      ? *_impl_.Msg_.authenticateresp_
      : reinterpret_cast< ::ServerData::AuthenticateResp&>(::ServerData::_AuthenticateResp_default_instance_);
}
inline const ::ServerData::AuthenticateResp& RelayRemoteMessage::authenticateresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AuthenticateResp)
  return _internal_authenticateresp();
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::unsafe_arena_release_authenticateresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AuthenticateResp)
  if (_internal_has_authenticateresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateResp* temp = _impl_.Msg_.authenticateresp_;
    _impl_.Msg_.authenticateresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_authenticateresp(::ServerData::AuthenticateResp* authenticateresp) {
  clear_Msg();
  if (authenticateresp) {
    set_has_authenticateresp();
    _impl_.Msg_.authenticateresp_ = authenticateresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AuthenticateResp)
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::_internal_mutable_authenticateresp() {
  if (!_internal_has_authenticateresp()) {
    clear_Msg();
    set_has_authenticateresp();
    _impl_.Msg_.authenticateresp_ = CreateMaybeMessage< ::ServerData::AuthenticateResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateresp_;
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::mutable_authenticateresp() {
  ::ServerData::AuthenticateResp* _msg = _internal_mutable_authenticateresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AuthenticateResp)
  return _msg;
}

// .ServerData.AuthenticateGuestResp AuthenticateGuestResp = 3;
inline bool RelayRemoteMessage::_internal_has_authenticateguestresp() const {
  return Msg_case() == kAuthenticateGuestResp;
}
inline bool RelayRemoteMessage::has_authenticateguestresp() const {
  return _internal_has_authenticateguestresp();
}
inline void RelayRemoteMessage::set_has_authenticateguestresp() {
  _impl_._oneof_case_[0] = kAuthenticateGuestResp;
}
inline void RelayRemoteMessage::clear_authenticateguestresp() {
  if (_internal_has_authenticateguestresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateguestresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateGuestResp* RelayRemoteMessage::release_authenticateguestresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AuthenticateGuestResp)
  if (_internal_has_authenticateguestresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestResp* temp = _impl_.Msg_.authenticateguestresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateguestresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateGuestResp& RelayRemoteMessage::_internal_authenticateguestresp() const {
  return _internal_has_authenticateguestresp()
      ? *_impl_.Msg_.authenticateguestresp_
      : reinterpret_cast< ::ServerData::AuthenticateGuestResp&>(::ServerData::_AuthenticateGuestResp_default_instance_);
}
inline const ::ServerData::AuthenticateGuestResp& RelayRemoteMessage::authenticateguestresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AuthenticateGuestResp)
  return _internal_authenticateguestresp();
}
inline ::ServerData::AuthenticateGuestResp* RelayRemoteMessage::unsafe_arena_release_authenticateguestresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AuthenticateGuestResp)
  if (_internal_has_authenticateguestresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestResp* temp = _impl_.Msg_.authenticateguestresp_;
    _impl_.Msg_.authenticateguestresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_authenticateguestresp(::ServerData::AuthenticateGuestResp* authenticateguestresp) {
  clear_Msg();
  if (authenticateguestresp) {
    set_has_authenticateguestresp();
    _impl_.Msg_.authenticateguestresp_ = authenticateguestresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AuthenticateGuestResp)
}
inline ::ServerData::AuthenticateGuestResp* RelayRemoteMessage::_internal_mutable_authenticateguestresp() {
  if (!_internal_has_authenticateguestresp()) {
    clear_Msg();
    set_has_authenticateguestresp();
    _impl_.Msg_.authenticateguestresp_ = CreateMaybeMessage< ::ServerData::AuthenticateGuestResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateguestresp_;
}
inline ::ServerData::AuthenticateGuestResp* RelayRemoteMessage::mutable_authenticateguestresp() {
  ::ServerData::AuthenticateGuestResp* _msg = _internal_mutable_authenticateguestresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AuthenticateGuestResp)
  return _msg;
}

// .ServerData.ExitAllSpacesAndLogoutResp ExitAllSpacesAndLogoutResp = 4;
inline bool RelayRemoteMessage::_internal_has_exitallspacesandlogoutresp() const {
  return Msg_case() == kExitAllSpacesAndLogoutResp;
}
inline bool RelayRemoteMessage::has_exitallspacesandlogoutresp() const {
  return _internal_has_exitallspacesandlogoutresp();
}
inline void RelayRemoteMessage::set_has_exitallspacesandlogoutresp() {
  _impl_._oneof_case_[0] = kExitAllSpacesAndLogoutResp;
}
inline void RelayRemoteMessage::clear_exitallspacesandlogoutresp() {
  if (_internal_has_exitallspacesandlogoutresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.exitallspacesandlogoutresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::release_exitallspacesandlogoutresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  if (_internal_has_exitallspacesandlogoutresp()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutResp* temp = _impl_.Msg_.exitallspacesandlogoutresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.exitallspacesandlogoutresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ExitAllSpacesAndLogoutResp& RelayRemoteMessage::_internal_exitallspacesandlogoutresp() const {
  return _internal_has_exitallspacesandlogoutresp()
      ? *_impl_.Msg_.exitallspacesandlogoutresp_
      : reinterpret_cast< ::ServerData::ExitAllSpacesAndLogoutResp&>(::ServerData::_ExitAllSpacesAndLogoutResp_default_instance_);
}
inline const ::ServerData::ExitAllSpacesAndLogoutResp& RelayRemoteMessage::exitallspacesandlogoutresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  return _internal_exitallspacesandlogoutresp();
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::unsafe_arena_release_exitallspacesandlogoutresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  if (_internal_has_exitallspacesandlogoutresp()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutResp* temp = _impl_.Msg_.exitallspacesandlogoutresp_;
    _impl_.Msg_.exitallspacesandlogoutresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_exitallspacesandlogoutresp(::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp) {
  clear_Msg();
  if (exitallspacesandlogoutresp) {
    set_has_exitallspacesandlogoutresp();
    _impl_.Msg_.exitallspacesandlogoutresp_ = exitallspacesandlogoutresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::_internal_mutable_exitallspacesandlogoutresp() {
  if (!_internal_has_exitallspacesandlogoutresp()) {
    clear_Msg();
    set_has_exitallspacesandlogoutresp();
    _impl_.Msg_.exitallspacesandlogoutresp_ = CreateMaybeMessage< ::ServerData::ExitAllSpacesAndLogoutResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.exitallspacesandlogoutresp_;
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::mutable_exitallspacesandlogoutresp() {
  ::ServerData::ExitAllSpacesAndLogoutResp* _msg = _internal_mutable_exitallspacesandlogoutresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  return _msg;
}

// .ServerData.JoinSpaceFromIdResp JoinSpaceFromIdResp = 10;
inline bool RelayRemoteMessage::_internal_has_joinspacefromidresp() const {
  return Msg_case() == kJoinSpaceFromIdResp;
}
inline bool RelayRemoteMessage::has_joinspacefromidresp() const {
  return _internal_has_joinspacefromidresp();
}
inline void RelayRemoteMessage::set_has_joinspacefromidresp() {
  _impl_._oneof_case_[0] = kJoinSpaceFromIdResp;
}
inline void RelayRemoteMessage::clear_joinspacefromidresp() {
  if (_internal_has_joinspacefromidresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.joinspacefromidresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::release_joinspacefromidresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  if (_internal_has_joinspacefromidresp()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdResp* temp = _impl_.Msg_.joinspacefromidresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.joinspacefromidresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::JoinSpaceFromIdResp& RelayRemoteMessage::_internal_joinspacefromidresp() const {
  return _internal_has_joinspacefromidresp()
      ? *_impl_.Msg_.joinspacefromidresp_
      : reinterpret_cast< ::ServerData::JoinSpaceFromIdResp&>(::ServerData::_JoinSpaceFromIdResp_default_instance_);
}
inline const ::ServerData::JoinSpaceFromIdResp& RelayRemoteMessage::joinspacefromidresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  return _internal_joinspacefromidresp();
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::unsafe_arena_release_joinspacefromidresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  if (_internal_has_joinspacefromidresp()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdResp* temp = _impl_.Msg_.joinspacefromidresp_;
    _impl_.Msg_.joinspacefromidresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_joinspacefromidresp(::ServerData::JoinSpaceFromIdResp* joinspacefromidresp) {
  clear_Msg();
  if (joinspacefromidresp) {
    set_has_joinspacefromidresp();
    _impl_.Msg_.joinspacefromidresp_ = joinspacefromidresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::_internal_mutable_joinspacefromidresp() {
  if (!_internal_has_joinspacefromidresp()) {
    clear_Msg();
    set_has_joinspacefromidresp();
    _impl_.Msg_.joinspacefromidresp_ = CreateMaybeMessage< ::ServerData::JoinSpaceFromIdResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.joinspacefromidresp_;
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::mutable_joinspacefromidresp() {
  ::ServerData::JoinSpaceFromIdResp* _msg = _internal_mutable_joinspacefromidresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  return _msg;
}

// .ServerData.ShutdownSpaceConnectionResp ShutdownSpaceConnectionResp = 11;
inline bool RelayRemoteMessage::_internal_has_shutdownspaceconnectionresp() const {
  return Msg_case() == kShutdownSpaceConnectionResp;
}
inline bool RelayRemoteMessage::has_shutdownspaceconnectionresp() const {
  return _internal_has_shutdownspaceconnectionresp();
}
inline void RelayRemoteMessage::set_has_shutdownspaceconnectionresp() {
  _impl_._oneof_case_[0] = kShutdownSpaceConnectionResp;
}
inline void RelayRemoteMessage::clear_shutdownspaceconnectionresp() {
  if (_internal_has_shutdownspaceconnectionresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.shutdownspaceconnectionresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::release_shutdownspaceconnectionresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  if (_internal_has_shutdownspaceconnectionresp()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionResp* temp = _impl_.Msg_.shutdownspaceconnectionresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.shutdownspaceconnectionresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ShutdownSpaceConnectionResp& RelayRemoteMessage::_internal_shutdownspaceconnectionresp() const {
  return _internal_has_shutdownspaceconnectionresp()
      ? *_impl_.Msg_.shutdownspaceconnectionresp_
      : reinterpret_cast< ::ServerData::ShutdownSpaceConnectionResp&>(::ServerData::_ShutdownSpaceConnectionResp_default_instance_);
}
inline const ::ServerData::ShutdownSpaceConnectionResp& RelayRemoteMessage::shutdownspaceconnectionresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  return _internal_shutdownspaceconnectionresp();
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::unsafe_arena_release_shutdownspaceconnectionresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  if (_internal_has_shutdownspaceconnectionresp()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionResp* temp = _impl_.Msg_.shutdownspaceconnectionresp_;
    _impl_.Msg_.shutdownspaceconnectionresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_shutdownspaceconnectionresp(::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp) {
  clear_Msg();
  if (shutdownspaceconnectionresp) {
    set_has_shutdownspaceconnectionresp();
    _impl_.Msg_.shutdownspaceconnectionresp_ = shutdownspaceconnectionresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::_internal_mutable_shutdownspaceconnectionresp() {
  if (!_internal_has_shutdownspaceconnectionresp()) {
    clear_Msg();
    set_has_shutdownspaceconnectionresp();
    _impl_.Msg_.shutdownspaceconnectionresp_ = CreateMaybeMessage< ::ServerData::ShutdownSpaceConnectionResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.shutdownspaceconnectionresp_;
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::mutable_shutdownspaceconnectionresp() {
  ::ServerData::ShutdownSpaceConnectionResp* _msg = _internal_mutable_shutdownspaceconnectionresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  return _msg;
}

// .ServerData.CreateSpaceResp CreateSpaceResp = 12;
inline bool RelayRemoteMessage::_internal_has_createspaceresp() const {
  return Msg_case() == kCreateSpaceResp;
}
inline bool RelayRemoteMessage::has_createspaceresp() const {
  return _internal_has_createspaceresp();
}
inline void RelayRemoteMessage::set_has_createspaceresp() {
  _impl_._oneof_case_[0] = kCreateSpaceResp;
}
inline void RelayRemoteMessage::clear_createspaceresp() {
  if (_internal_has_createspaceresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.createspaceresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::release_createspaceresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.CreateSpaceResp)
  if (_internal_has_createspaceresp()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceResp* temp = _impl_.Msg_.createspaceresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.createspaceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CreateSpaceResp& RelayRemoteMessage::_internal_createspaceresp() const {
  return _internal_has_createspaceresp()
      ? *_impl_.Msg_.createspaceresp_
      : reinterpret_cast< ::ServerData::CreateSpaceResp&>(::ServerData::_CreateSpaceResp_default_instance_);
}
inline const ::ServerData::CreateSpaceResp& RelayRemoteMessage::createspaceresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.CreateSpaceResp)
  return _internal_createspaceresp();
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::unsafe_arena_release_createspaceresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.CreateSpaceResp)
  if (_internal_has_createspaceresp()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceResp* temp = _impl_.Msg_.createspaceresp_;
    _impl_.Msg_.createspaceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_createspaceresp(::ServerData::CreateSpaceResp* createspaceresp) {
  clear_Msg();
  if (createspaceresp) {
    set_has_createspaceresp();
    _impl_.Msg_.createspaceresp_ = createspaceresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.CreateSpaceResp)
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::_internal_mutable_createspaceresp() {
  if (!_internal_has_createspaceresp()) {
    clear_Msg();
    set_has_createspaceresp();
    _impl_.Msg_.createspaceresp_ = CreateMaybeMessage< ::ServerData::CreateSpaceResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.createspaceresp_;
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::mutable_createspaceresp() {
  ::ServerData::CreateSpaceResp* _msg = _internal_mutable_createspaceresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.CreateSpaceResp)
  return _msg;
}

// .ServerData.GetAudioInputDevicesResp GetAudioInputDevicesResp = 20;
inline bool RelayRemoteMessage::_internal_has_getaudioinputdevicesresp() const {
  return Msg_case() == kGetAudioInputDevicesResp;
}
inline bool RelayRemoteMessage::has_getaudioinputdevicesresp() const {
  return _internal_has_getaudioinputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getaudioinputdevicesresp() {
  _impl_._oneof_case_[0] = kGetAudioInputDevicesResp;
}
inline void RelayRemoteMessage::clear_getaudioinputdevicesresp() {
  if (_internal_has_getaudioinputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudioinputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::release_getaudioinputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  if (_internal_has_getaudioinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesResp* temp = _impl_.Msg_.getaudioinputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudioinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioInputDevicesResp& RelayRemoteMessage::_internal_getaudioinputdevicesresp() const {
  return _internal_has_getaudioinputdevicesresp()
      ? *_impl_.Msg_.getaudioinputdevicesresp_
      : reinterpret_cast< ::ServerData::GetAudioInputDevicesResp&>(::ServerData::_GetAudioInputDevicesResp_default_instance_);
}
inline const ::ServerData::GetAudioInputDevicesResp& RelayRemoteMessage::getaudioinputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  return _internal_getaudioinputdevicesresp();
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getaudioinputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  if (_internal_has_getaudioinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesResp* temp = _impl_.Msg_.getaudioinputdevicesresp_;
    _impl_.Msg_.getaudioinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getaudioinputdevicesresp(::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp) {
  clear_Msg();
  if (getaudioinputdevicesresp) {
    set_has_getaudioinputdevicesresp();
    _impl_.Msg_.getaudioinputdevicesresp_ = getaudioinputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::_internal_mutable_getaudioinputdevicesresp() {
  if (!_internal_has_getaudioinputdevicesresp()) {
    clear_Msg();
    set_has_getaudioinputdevicesresp();
    _impl_.Msg_.getaudioinputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetAudioInputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudioinputdevicesresp_;
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::mutable_getaudioinputdevicesresp() {
  ::ServerData::GetAudioInputDevicesResp* _msg = _internal_mutable_getaudioinputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  return _msg;
}

// .ServerData.GetAudioOutputDevicesResp GetAudioOutputDevicesResp = 21;
inline bool RelayRemoteMessage::_internal_has_getaudiooutputdevicesresp() const {
  return Msg_case() == kGetAudioOutputDevicesResp;
}
inline bool RelayRemoteMessage::has_getaudiooutputdevicesresp() const {
  return _internal_has_getaudiooutputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getaudiooutputdevicesresp() {
  _impl_._oneof_case_[0] = kGetAudioOutputDevicesResp;
}
inline void RelayRemoteMessage::clear_getaudiooutputdevicesresp() {
  if (_internal_has_getaudiooutputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudiooutputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::release_getaudiooutputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  if (_internal_has_getaudiooutputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesResp* temp = _impl_.Msg_.getaudiooutputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudiooutputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioOutputDevicesResp& RelayRemoteMessage::_internal_getaudiooutputdevicesresp() const {
  return _internal_has_getaudiooutputdevicesresp()
      ? *_impl_.Msg_.getaudiooutputdevicesresp_
      : reinterpret_cast< ::ServerData::GetAudioOutputDevicesResp&>(::ServerData::_GetAudioOutputDevicesResp_default_instance_);
}
inline const ::ServerData::GetAudioOutputDevicesResp& RelayRemoteMessage::getaudiooutputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  return _internal_getaudiooutputdevicesresp();
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getaudiooutputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  if (_internal_has_getaudiooutputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesResp* temp = _impl_.Msg_.getaudiooutputdevicesresp_;
    _impl_.Msg_.getaudiooutputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getaudiooutputdevicesresp(::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp) {
  clear_Msg();
  if (getaudiooutputdevicesresp) {
    set_has_getaudiooutputdevicesresp();
    _impl_.Msg_.getaudiooutputdevicesresp_ = getaudiooutputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::_internal_mutable_getaudiooutputdevicesresp() {
  if (!_internal_has_getaudiooutputdevicesresp()) {
    clear_Msg();
    set_has_getaudiooutputdevicesresp();
    _impl_.Msg_.getaudiooutputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetAudioOutputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudiooutputdevicesresp_;
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::mutable_getaudiooutputdevicesresp() {
  ::ServerData::GetAudioOutputDevicesResp* _msg = _internal_mutable_getaudiooutputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  return _msg;
}

// .ServerData.GetVideoInputDevicesResp GetVideoInputDevicesResp = 22;
inline bool RelayRemoteMessage::_internal_has_getvideoinputdevicesresp() const {
  return Msg_case() == kGetVideoInputDevicesResp;
}
inline bool RelayRemoteMessage::has_getvideoinputdevicesresp() const {
  return _internal_has_getvideoinputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getvideoinputdevicesresp() {
  _impl_._oneof_case_[0] = kGetVideoInputDevicesResp;
}
inline void RelayRemoteMessage::clear_getvideoinputdevicesresp() {
  if (_internal_has_getvideoinputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getvideoinputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::release_getvideoinputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  if (_internal_has_getvideoinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesResp* temp = _impl_.Msg_.getvideoinputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getvideoinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetVideoInputDevicesResp& RelayRemoteMessage::_internal_getvideoinputdevicesresp() const {
  return _internal_has_getvideoinputdevicesresp()
      ? *_impl_.Msg_.getvideoinputdevicesresp_
      : reinterpret_cast< ::ServerData::GetVideoInputDevicesResp&>(::ServerData::_GetVideoInputDevicesResp_default_instance_);
}
inline const ::ServerData::GetVideoInputDevicesResp& RelayRemoteMessage::getvideoinputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  return _internal_getvideoinputdevicesresp();
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getvideoinputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  if (_internal_has_getvideoinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesResp* temp = _impl_.Msg_.getvideoinputdevicesresp_;
    _impl_.Msg_.getvideoinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getvideoinputdevicesresp(::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp) {
  clear_Msg();
  if (getvideoinputdevicesresp) {
    set_has_getvideoinputdevicesresp();
    _impl_.Msg_.getvideoinputdevicesresp_ = getvideoinputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::_internal_mutable_getvideoinputdevicesresp() {
  if (!_internal_has_getvideoinputdevicesresp()) {
    clear_Msg();
    set_has_getvideoinputdevicesresp();
    _impl_.Msg_.getvideoinputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetVideoInputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getvideoinputdevicesresp_;
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::mutable_getvideoinputdevicesresp() {
  ::ServerData::GetVideoInputDevicesResp* _msg = _internal_mutable_getvideoinputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  return _msg;
}

// .ServerData.PropertyValueStatus PropertyValueStatus = 50;
inline bool RelayRemoteMessage::_internal_has_propertyvaluestatus() const {
  return Msg_case() == kPropertyValueStatus;
}
inline bool RelayRemoteMessage::has_propertyvaluestatus() const {
  return _internal_has_propertyvaluestatus();
}
inline void RelayRemoteMessage::set_has_propertyvaluestatus() {
  _impl_._oneof_case_[0] = kPropertyValueStatus;
}
inline void RelayRemoteMessage::clear_propertyvaluestatus() {
  if (_internal_has_propertyvaluestatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.propertyvaluestatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::release_propertyvaluestatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PropertyValueStatus)
  if (_internal_has_propertyvaluestatus()) {
    clear_has_Msg();
    ::ServerData::PropertyValueStatus* temp = _impl_.Msg_.propertyvaluestatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.propertyvaluestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PropertyValueStatus& RelayRemoteMessage::_internal_propertyvaluestatus() const {
  return _internal_has_propertyvaluestatus()
      ? *_impl_.Msg_.propertyvaluestatus_
      : reinterpret_cast< ::ServerData::PropertyValueStatus&>(::ServerData::_PropertyValueStatus_default_instance_);
}
inline const ::ServerData::PropertyValueStatus& RelayRemoteMessage::propertyvaluestatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PropertyValueStatus)
  return _internal_propertyvaluestatus();
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::unsafe_arena_release_propertyvaluestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PropertyValueStatus)
  if (_internal_has_propertyvaluestatus()) {
    clear_has_Msg();
    ::ServerData::PropertyValueStatus* temp = _impl_.Msg_.propertyvaluestatus_;
    _impl_.Msg_.propertyvaluestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_propertyvaluestatus(::ServerData::PropertyValueStatus* propertyvaluestatus) {
  clear_Msg();
  if (propertyvaluestatus) {
    set_has_propertyvaluestatus();
    _impl_.Msg_.propertyvaluestatus_ = propertyvaluestatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PropertyValueStatus)
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::_internal_mutable_propertyvaluestatus() {
  if (!_internal_has_propertyvaluestatus()) {
    clear_Msg();
    set_has_propertyvaluestatus();
    _impl_.Msg_.propertyvaluestatus_ = CreateMaybeMessage< ::ServerData::PropertyValueStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.propertyvaluestatus_;
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::mutable_propertyvaluestatus() {
  ::ServerData::PropertyValueStatus* _msg = _internal_mutable_propertyvaluestatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PropertyValueStatus)
  return _msg;
}

// .ServerData.LocalPropertyHandledResp LocalPropertyHandledResp = 51;
inline bool RelayRemoteMessage::_internal_has_localpropertyhandledresp() const {
  return Msg_case() == kLocalPropertyHandledResp;
}
inline bool RelayRemoteMessage::has_localpropertyhandledresp() const {
  return _internal_has_localpropertyhandledresp();
}
inline void RelayRemoteMessage::set_has_localpropertyhandledresp() {
  _impl_._oneof_case_[0] = kLocalPropertyHandledResp;
}
inline void RelayRemoteMessage::clear_localpropertyhandledresp() {
  if (_internal_has_localpropertyhandledresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.localpropertyhandledresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::release_localpropertyhandledresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  if (_internal_has_localpropertyhandledresp()) {
    clear_has_Msg();
    ::ServerData::LocalPropertyHandledResp* temp = _impl_.Msg_.localpropertyhandledresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.localpropertyhandledresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::LocalPropertyHandledResp& RelayRemoteMessage::_internal_localpropertyhandledresp() const {
  return _internal_has_localpropertyhandledresp()
      ? *_impl_.Msg_.localpropertyhandledresp_
      : reinterpret_cast< ::ServerData::LocalPropertyHandledResp&>(::ServerData::_LocalPropertyHandledResp_default_instance_);
}
inline const ::ServerData::LocalPropertyHandledResp& RelayRemoteMessage::localpropertyhandledresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  return _internal_localpropertyhandledresp();
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::unsafe_arena_release_localpropertyhandledresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  if (_internal_has_localpropertyhandledresp()) {
    clear_has_Msg();
    ::ServerData::LocalPropertyHandledResp* temp = _impl_.Msg_.localpropertyhandledresp_;
    _impl_.Msg_.localpropertyhandledresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_localpropertyhandledresp(::ServerData::LocalPropertyHandledResp* localpropertyhandledresp) {
  clear_Msg();
  if (localpropertyhandledresp) {
    set_has_localpropertyhandledresp();
    _impl_.Msg_.localpropertyhandledresp_ = localpropertyhandledresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::_internal_mutable_localpropertyhandledresp() {
  if (!_internal_has_localpropertyhandledresp()) {
    clear_Msg();
    set_has_localpropertyhandledresp();
    _impl_.Msg_.localpropertyhandledresp_ = CreateMaybeMessage< ::ServerData::LocalPropertyHandledResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.localpropertyhandledresp_;
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::mutable_localpropertyhandledresp() {
  ::ServerData::LocalPropertyHandledResp* _msg = _internal_mutable_localpropertyhandledresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  return _msg;
}

// .ServerData.PropMetadataStatus PropMetadataStatus = 52;
inline bool RelayRemoteMessage::_internal_has_propmetadatastatus() const {
  return Msg_case() == kPropMetadataStatus;
}
inline bool RelayRemoteMessage::has_propmetadatastatus() const {
  return _internal_has_propmetadatastatus();
}
inline void RelayRemoteMessage::set_has_propmetadatastatus() {
  _impl_._oneof_case_[0] = kPropMetadataStatus;
}
inline void RelayRemoteMessage::clear_propmetadatastatus() {
  if (_internal_has_propmetadatastatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.propmetadatastatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::release_propmetadatastatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PropMetadataStatus)
  if (_internal_has_propmetadatastatus()) {
    clear_has_Msg();
    ::ServerData::PropMetadataStatus* temp = _impl_.Msg_.propmetadatastatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.propmetadatastatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PropMetadataStatus& RelayRemoteMessage::_internal_propmetadatastatus() const {
  return _internal_has_propmetadatastatus()
      ? *_impl_.Msg_.propmetadatastatus_
      : reinterpret_cast< ::ServerData::PropMetadataStatus&>(::ServerData::_PropMetadataStatus_default_instance_);
}
inline const ::ServerData::PropMetadataStatus& RelayRemoteMessage::propmetadatastatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PropMetadataStatus)
  return _internal_propmetadatastatus();
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::unsafe_arena_release_propmetadatastatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PropMetadataStatus)
  if (_internal_has_propmetadatastatus()) {
    clear_has_Msg();
    ::ServerData::PropMetadataStatus* temp = _impl_.Msg_.propmetadatastatus_;
    _impl_.Msg_.propmetadatastatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_propmetadatastatus(::ServerData::PropMetadataStatus* propmetadatastatus) {
  clear_Msg();
  if (propmetadatastatus) {
    set_has_propmetadatastatus();
    _impl_.Msg_.propmetadatastatus_ = propmetadatastatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PropMetadataStatus)
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::_internal_mutable_propmetadatastatus() {
  if (!_internal_has_propmetadatastatus()) {
    clear_Msg();
    set_has_propmetadatastatus();
    _impl_.Msg_.propmetadatastatus_ = CreateMaybeMessage< ::ServerData::PropMetadataStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.propmetadatastatus_;
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::mutable_propmetadatastatus() {
  ::ServerData::PropMetadataStatus* _msg = _internal_mutable_propmetadatastatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PropMetadataStatus)
  return _msg;
}

// .ServerData.UserAdded UserAdded = 60;
inline bool RelayRemoteMessage::_internal_has_useradded() const {
  return Msg_case() == kUserAdded;
}
inline bool RelayRemoteMessage::has_useradded() const {
  return _internal_has_useradded();
}
inline void RelayRemoteMessage::set_has_useradded() {
  _impl_._oneof_case_[0] = kUserAdded;
}
inline void RelayRemoteMessage::clear_useradded() {
  if (_internal_has_useradded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.useradded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserAdded* RelayRemoteMessage::release_useradded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserAdded)
  if (_internal_has_useradded()) {
    clear_has_Msg();
    ::ServerData::UserAdded* temp = _impl_.Msg_.useradded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.useradded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserAdded& RelayRemoteMessage::_internal_useradded() const {
  return _internal_has_useradded()
      ? *_impl_.Msg_.useradded_
      : reinterpret_cast< ::ServerData::UserAdded&>(::ServerData::_UserAdded_default_instance_);
}
inline const ::ServerData::UserAdded& RelayRemoteMessage::useradded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserAdded)
  return _internal_useradded();
}
inline ::ServerData::UserAdded* RelayRemoteMessage::unsafe_arena_release_useradded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserAdded)
  if (_internal_has_useradded()) {
    clear_has_Msg();
    ::ServerData::UserAdded* temp = _impl_.Msg_.useradded_;
    _impl_.Msg_.useradded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_useradded(::ServerData::UserAdded* useradded) {
  clear_Msg();
  if (useradded) {
    set_has_useradded();
    _impl_.Msg_.useradded_ = useradded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserAdded)
}
inline ::ServerData::UserAdded* RelayRemoteMessage::_internal_mutable_useradded() {
  if (!_internal_has_useradded()) {
    clear_Msg();
    set_has_useradded();
    _impl_.Msg_.useradded_ = CreateMaybeMessage< ::ServerData::UserAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.useradded_;
}
inline ::ServerData::UserAdded* RelayRemoteMessage::mutable_useradded() {
  ::ServerData::UserAdded* _msg = _internal_mutable_useradded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserAdded)
  return _msg;
}

// .ServerData.UserRemoved UserRemoved = 61;
inline bool RelayRemoteMessage::_internal_has_userremoved() const {
  return Msg_case() == kUserRemoved;
}
inline bool RelayRemoteMessage::has_userremoved() const {
  return _internal_has_userremoved();
}
inline void RelayRemoteMessage::set_has_userremoved() {
  _impl_._oneof_case_[0] = kUserRemoved;
}
inline void RelayRemoteMessage::clear_userremoved() {
  if (_internal_has_userremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.userremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::release_userremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserRemoved)
  if (_internal_has_userremoved()) {
    clear_has_Msg();
    ::ServerData::UserRemoved* temp = _impl_.Msg_.userremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.userremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserRemoved& RelayRemoteMessage::_internal_userremoved() const {
  return _internal_has_userremoved()
      ? *_impl_.Msg_.userremoved_
      : reinterpret_cast< ::ServerData::UserRemoved&>(::ServerData::_UserRemoved_default_instance_);
}
inline const ::ServerData::UserRemoved& RelayRemoteMessage::userremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserRemoved)
  return _internal_userremoved();
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::unsafe_arena_release_userremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserRemoved)
  if (_internal_has_userremoved()) {
    clear_has_Msg();
    ::ServerData::UserRemoved* temp = _impl_.Msg_.userremoved_;
    _impl_.Msg_.userremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_userremoved(::ServerData::UserRemoved* userremoved) {
  clear_Msg();
  if (userremoved) {
    set_has_userremoved();
    _impl_.Msg_.userremoved_ = userremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserRemoved)
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::_internal_mutable_userremoved() {
  if (!_internal_has_userremoved()) {
    clear_Msg();
    set_has_userremoved();
    _impl_.Msg_.userremoved_ = CreateMaybeMessage< ::ServerData::UserRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.userremoved_;
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::mutable_userremoved() {
  ::ServerData::UserRemoved* _msg = _internal_mutable_userremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserRemoved)
  return _msg;
}

// .ServerData.UserVideoFrame UserVideoFrame = 65;
inline bool RelayRemoteMessage::_internal_has_uservideoframe() const {
  return Msg_case() == kUserVideoFrame;
}
inline bool RelayRemoteMessage::has_uservideoframe() const {
  return _internal_has_uservideoframe();
}
inline void RelayRemoteMessage::set_has_uservideoframe() {
  _impl_._oneof_case_[0] = kUserVideoFrame;
}
inline void RelayRemoteMessage::clear_uservideoframe() {
  if (_internal_has_uservideoframe()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uservideoframe_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::release_uservideoframe() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserVideoFrame)
  if (_internal_has_uservideoframe()) {
    clear_has_Msg();
    ::ServerData::UserVideoFrame* temp = _impl_.Msg_.uservideoframe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uservideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserVideoFrame& RelayRemoteMessage::_internal_uservideoframe() const {
  return _internal_has_uservideoframe()
      ? *_impl_.Msg_.uservideoframe_
      : reinterpret_cast< ::ServerData::UserVideoFrame&>(::ServerData::_UserVideoFrame_default_instance_);
}
inline const ::ServerData::UserVideoFrame& RelayRemoteMessage::uservideoframe() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserVideoFrame)
  return _internal_uservideoframe();
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::unsafe_arena_release_uservideoframe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserVideoFrame)
  if (_internal_has_uservideoframe()) {
    clear_has_Msg();
    ::ServerData::UserVideoFrame* temp = _impl_.Msg_.uservideoframe_;
    _impl_.Msg_.uservideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_uservideoframe(::ServerData::UserVideoFrame* uservideoframe) {
  clear_Msg();
  if (uservideoframe) {
    set_has_uservideoframe();
    _impl_.Msg_.uservideoframe_ = uservideoframe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserVideoFrame)
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::_internal_mutable_uservideoframe() {
  if (!_internal_has_uservideoframe()) {
    clear_Msg();
    set_has_uservideoframe();
    _impl_.Msg_.uservideoframe_ = CreateMaybeMessage< ::ServerData::UserVideoFrame >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uservideoframe_;
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::mutable_uservideoframe() {
  ::ServerData::UserVideoFrame* _msg = _internal_mutable_uservideoframe();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserVideoFrame)
  return _msg;
}

// .ServerData.SpaceInfo SpaceAdded = 70;
inline bool RelayRemoteMessage::_internal_has_spaceadded() const {
  return Msg_case() == kSpaceAdded;
}
inline bool RelayRemoteMessage::has_spaceadded() const {
  return _internal_has_spaceadded();
}
inline void RelayRemoteMessage::set_has_spaceadded() {
  _impl_._oneof_case_[0] = kSpaceAdded;
}
inline void RelayRemoteMessage::clear_spaceadded() {
  if (_internal_has_spaceadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.spaceadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceAdded)
  if (_internal_has_spaceadded()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceadded() const {
  return _internal_has_spaceadded()
      ? *_impl_.Msg_.spaceadded_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceAdded)
  return _internal_spaceadded();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceAdded)
  if (_internal_has_spaceadded()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceadded_;
    _impl_.Msg_.spaceadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceadded(::ServerData::SpaceInfo* spaceadded) {
  clear_Msg();
  if (spaceadded) {
    set_has_spaceadded();
    _impl_.Msg_.spaceadded_ = spaceadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceAdded)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceadded() {
  if (!_internal_has_spaceadded()) {
    clear_Msg();
    set_has_spaceadded();
    _impl_.Msg_.spaceadded_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceadded_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceadded() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceAdded)
  return _msg;
}

// .ServerData.SpaceInfo SpaceUpdated = 71;
inline bool RelayRemoteMessage::_internal_has_spaceupdated() const {
  return Msg_case() == kSpaceUpdated;
}
inline bool RelayRemoteMessage::has_spaceupdated() const {
  return _internal_has_spaceupdated();
}
inline void RelayRemoteMessage::set_has_spaceupdated() {
  _impl_._oneof_case_[0] = kSpaceUpdated;
}
inline void RelayRemoteMessage::clear_spaceupdated() {
  if (_internal_has_spaceupdated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.spaceupdated_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceupdated() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceUpdated)
  if (_internal_has_spaceupdated()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceupdated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceupdated() const {
  return _internal_has_spaceupdated()
      ? *_impl_.Msg_.spaceupdated_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceupdated() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceUpdated)
  return _internal_spaceupdated();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceupdated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceUpdated)
  if (_internal_has_spaceupdated()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceupdated_;
    _impl_.Msg_.spaceupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceupdated(::ServerData::SpaceInfo* spaceupdated) {
  clear_Msg();
  if (spaceupdated) {
    set_has_spaceupdated();
    _impl_.Msg_.spaceupdated_ = spaceupdated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceUpdated)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceupdated() {
  if (!_internal_has_spaceupdated()) {
    clear_Msg();
    set_has_spaceupdated();
    _impl_.Msg_.spaceupdated_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceupdated_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceupdated() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceupdated();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceUpdated)
  return _msg;
}

// .ServerData.SpaceInfo SpaceRemoved = 72;
inline bool RelayRemoteMessage::_internal_has_spaceremoved() const {
  return Msg_case() == kSpaceRemoved;
}
inline bool RelayRemoteMessage::has_spaceremoved() const {
  return _internal_has_spaceremoved();
}
inline void RelayRemoteMessage::set_has_spaceremoved() {
  _impl_._oneof_case_[0] = kSpaceRemoved;
}
inline void RelayRemoteMessage::clear_spaceremoved() {
  if (_internal_has_spaceremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.spaceremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceRemoved)
  if (_internal_has_spaceremoved()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceremoved() const {
  return _internal_has_spaceremoved()
      ? *_impl_.Msg_.spaceremoved_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceRemoved)
  return _internal_spaceremoved();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceRemoved)
  if (_internal_has_spaceremoved()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceremoved_;
    _impl_.Msg_.spaceremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceremoved(::ServerData::SpaceInfo* spaceremoved) {
  clear_Msg();
  if (spaceremoved) {
    set_has_spaceremoved();
    _impl_.Msg_.spaceremoved_ = spaceremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceRemoved)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceremoved() {
  if (!_internal_has_spaceremoved()) {
    clear_Msg();
    set_has_spaceremoved();
    _impl_.Msg_.spaceremoved_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceremoved_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceremoved() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceRemoved)
  return _msg;
}

// .ServerData.ObjectAdded ObjectAdded = 80;
inline bool RelayRemoteMessage::_internal_has_objectadded() const {
  return Msg_case() == kObjectAdded;
}
inline bool RelayRemoteMessage::has_objectadded() const {
  return _internal_has_objectadded();
}
inline void RelayRemoteMessage::set_has_objectadded() {
  _impl_._oneof_case_[0] = kObjectAdded;
}
inline void RelayRemoteMessage::clear_objectadded() {
  if (_internal_has_objectadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.objectadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::release_objectadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ObjectAdded)
  if (_internal_has_objectadded()) {
    clear_has_Msg();
    ::ServerData::ObjectAdded* temp = _impl_.Msg_.objectadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.objectadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ObjectAdded& RelayRemoteMessage::_internal_objectadded() const {
  return _internal_has_objectadded()
      ? *_impl_.Msg_.objectadded_
      : reinterpret_cast< ::ServerData::ObjectAdded&>(::ServerData::_ObjectAdded_default_instance_);
}
inline const ::ServerData::ObjectAdded& RelayRemoteMessage::objectadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ObjectAdded)
  return _internal_objectadded();
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::unsafe_arena_release_objectadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ObjectAdded)
  if (_internal_has_objectadded()) {
    clear_has_Msg();
    ::ServerData::ObjectAdded* temp = _impl_.Msg_.objectadded_;
    _impl_.Msg_.objectadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_objectadded(::ServerData::ObjectAdded* objectadded) {
  clear_Msg();
  if (objectadded) {
    set_has_objectadded();
    _impl_.Msg_.objectadded_ = objectadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ObjectAdded)
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::_internal_mutable_objectadded() {
  if (!_internal_has_objectadded()) {
    clear_Msg();
    set_has_objectadded();
    _impl_.Msg_.objectadded_ = CreateMaybeMessage< ::ServerData::ObjectAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.objectadded_;
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::mutable_objectadded() {
  ::ServerData::ObjectAdded* _msg = _internal_mutable_objectadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ObjectAdded)
  return _msg;
}

// .ServerData.ObjectRemoved ObjectRemoved = 81;
inline bool RelayRemoteMessage::_internal_has_objectremoved() const {
  return Msg_case() == kObjectRemoved;
}
inline bool RelayRemoteMessage::has_objectremoved() const {
  return _internal_has_objectremoved();
}
inline void RelayRemoteMessage::set_has_objectremoved() {
  _impl_._oneof_case_[0] = kObjectRemoved;
}
inline void RelayRemoteMessage::clear_objectremoved() {
  if (_internal_has_objectremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.objectremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::release_objectremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ObjectRemoved)
  if (_internal_has_objectremoved()) {
    clear_has_Msg();
    ::ServerData::ObjectRemoved* temp = _impl_.Msg_.objectremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.objectremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ObjectRemoved& RelayRemoteMessage::_internal_objectremoved() const {
  return _internal_has_objectremoved()
      ? *_impl_.Msg_.objectremoved_
      : reinterpret_cast< ::ServerData::ObjectRemoved&>(::ServerData::_ObjectRemoved_default_instance_);
}
inline const ::ServerData::ObjectRemoved& RelayRemoteMessage::objectremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ObjectRemoved)
  return _internal_objectremoved();
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::unsafe_arena_release_objectremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ObjectRemoved)
  if (_internal_has_objectremoved()) {
    clear_has_Msg();
    ::ServerData::ObjectRemoved* temp = _impl_.Msg_.objectremoved_;
    _impl_.Msg_.objectremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_objectremoved(::ServerData::ObjectRemoved* objectremoved) {
  clear_Msg();
  if (objectremoved) {
    set_has_objectremoved();
    _impl_.Msg_.objectremoved_ = objectremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ObjectRemoved)
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::_internal_mutable_objectremoved() {
  if (!_internal_has_objectremoved()) {
    clear_Msg();
    set_has_objectremoved();
    _impl_.Msg_.objectremoved_ = CreateMaybeMessage< ::ServerData::ObjectRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.objectremoved_;
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::mutable_objectremoved() {
  ::ServerData::ObjectRemoved* _msg = _internal_mutable_objectremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ObjectRemoved)
  return _msg;
}

// .ServerData.PermissionStatus PermissionStatus = 90;
inline bool RelayRemoteMessage::_internal_has_permissionstatus() const {
  return Msg_case() == kPermissionStatus;
}
inline bool RelayRemoteMessage::has_permissionstatus() const {
  return _internal_has_permissionstatus();
}
inline void RelayRemoteMessage::set_has_permissionstatus() {
  _impl_._oneof_case_[0] = kPermissionStatus;
}
inline void RelayRemoteMessage::clear_permissionstatus() {
  if (_internal_has_permissionstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.permissionstatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::release_permissionstatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PermissionStatus)
  if (_internal_has_permissionstatus()) {
    clear_has_Msg();
    ::ServerData::PermissionStatus* temp = _impl_.Msg_.permissionstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.permissionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PermissionStatus& RelayRemoteMessage::_internal_permissionstatus() const {
  return _internal_has_permissionstatus()
      ? *_impl_.Msg_.permissionstatus_
      : reinterpret_cast< ::ServerData::PermissionStatus&>(::ServerData::_PermissionStatus_default_instance_);
}
inline const ::ServerData::PermissionStatus& RelayRemoteMessage::permissionstatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PermissionStatus)
  return _internal_permissionstatus();
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::unsafe_arena_release_permissionstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PermissionStatus)
  if (_internal_has_permissionstatus()) {
    clear_has_Msg();
    ::ServerData::PermissionStatus* temp = _impl_.Msg_.permissionstatus_;
    _impl_.Msg_.permissionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_permissionstatus(::ServerData::PermissionStatus* permissionstatus) {
  clear_Msg();
  if (permissionstatus) {
    set_has_permissionstatus();
    _impl_.Msg_.permissionstatus_ = permissionstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PermissionStatus)
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::_internal_mutable_permissionstatus() {
  if (!_internal_has_permissionstatus()) {
    clear_Msg();
    set_has_permissionstatus();
    _impl_.Msg_.permissionstatus_ = CreateMaybeMessage< ::ServerData::PermissionStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.permissionstatus_;
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::mutable_permissionstatus() {
  ::ServerData::PermissionStatus* _msg = _internal_mutable_permissionstatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PermissionStatus)
  return _msg;
}

// .ServerData.AllJoinableSpacesResp AllJoinableSpacesResp = 100;
inline bool RelayRemoteMessage::_internal_has_alljoinablespacesresp() const {
  return Msg_case() == kAllJoinableSpacesResp;
}
inline bool RelayRemoteMessage::has_alljoinablespacesresp() const {
  return _internal_has_alljoinablespacesresp();
}
inline void RelayRemoteMessage::set_has_alljoinablespacesresp() {
  _impl_._oneof_case_[0] = kAllJoinableSpacesResp;
}
inline void RelayRemoteMessage::clear_alljoinablespacesresp() {
  if (_internal_has_alljoinablespacesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.alljoinablespacesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::release_alljoinablespacesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  if (_internal_has_alljoinablespacesresp()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesResp* temp = _impl_.Msg_.alljoinablespacesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.alljoinablespacesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AllJoinableSpacesResp& RelayRemoteMessage::_internal_alljoinablespacesresp() const {
  return _internal_has_alljoinablespacesresp()
      ? *_impl_.Msg_.alljoinablespacesresp_
      : reinterpret_cast< ::ServerData::AllJoinableSpacesResp&>(::ServerData::_AllJoinableSpacesResp_default_instance_);
}
inline const ::ServerData::AllJoinableSpacesResp& RelayRemoteMessage::alljoinablespacesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  return _internal_alljoinablespacesresp();
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::unsafe_arena_release_alljoinablespacesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  if (_internal_has_alljoinablespacesresp()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesResp* temp = _impl_.Msg_.alljoinablespacesresp_;
    _impl_.Msg_.alljoinablespacesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_alljoinablespacesresp(::ServerData::AllJoinableSpacesResp* alljoinablespacesresp) {
  clear_Msg();
  if (alljoinablespacesresp) {
    set_has_alljoinablespacesresp();
    _impl_.Msg_.alljoinablespacesresp_ = alljoinablespacesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::_internal_mutable_alljoinablespacesresp() {
  if (!_internal_has_alljoinablespacesresp()) {
    clear_Msg();
    set_has_alljoinablespacesresp();
    _impl_.Msg_.alljoinablespacesresp_ = CreateMaybeMessage< ::ServerData::AllJoinableSpacesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.alljoinablespacesresp_;
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::mutable_alljoinablespacesresp() {
  ::ServerData::AllJoinableSpacesResp* _msg = _internal_mutable_alljoinablespacesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  return _msg;
}

// .ServerData.FetchFileByIdProgressResp FetchFileByIdProgressResp = 110;
inline bool RelayRemoteMessage::_internal_has_fetchfilebyidprogressresp() const {
  return Msg_case() == kFetchFileByIdProgressResp;
}
inline bool RelayRemoteMessage::has_fetchfilebyidprogressresp() const {
  return _internal_has_fetchfilebyidprogressresp();
}
inline void RelayRemoteMessage::set_has_fetchfilebyidprogressresp() {
  _impl_._oneof_case_[0] = kFetchFileByIdProgressResp;
}
inline void RelayRemoteMessage::clear_fetchfilebyidprogressresp() {
  if (_internal_has_fetchfilebyidprogressresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidprogressresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::release_fetchfilebyidprogressresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  if (_internal_has_fetchfilebyidprogressresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdProgressResp* temp = _impl_.Msg_.fetchfilebyidprogressresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdProgressResp& RelayRemoteMessage::_internal_fetchfilebyidprogressresp() const {
  return _internal_has_fetchfilebyidprogressresp()
      ? *_impl_.Msg_.fetchfilebyidprogressresp_
      : reinterpret_cast< ::ServerData::FetchFileByIdProgressResp&>(::ServerData::_FetchFileByIdProgressResp_default_instance_);
}
inline const ::ServerData::FetchFileByIdProgressResp& RelayRemoteMessage::fetchfilebyidprogressresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  return _internal_fetchfilebyidprogressresp();
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::unsafe_arena_release_fetchfilebyidprogressresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  if (_internal_has_fetchfilebyidprogressresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdProgressResp* temp = _impl_.Msg_.fetchfilebyidprogressresp_;
    _impl_.Msg_.fetchfilebyidprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchfilebyidprogressresp(::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp) {
  clear_Msg();
  if (fetchfilebyidprogressresp) {
    set_has_fetchfilebyidprogressresp();
    _impl_.Msg_.fetchfilebyidprogressresp_ = fetchfilebyidprogressresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::_internal_mutable_fetchfilebyidprogressresp() {
  if (!_internal_has_fetchfilebyidprogressresp()) {
    clear_Msg();
    set_has_fetchfilebyidprogressresp();
    _impl_.Msg_.fetchfilebyidprogressresp_ = CreateMaybeMessage< ::ServerData::FetchFileByIdProgressResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidprogressresp_;
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::mutable_fetchfilebyidprogressresp() {
  ::ServerData::FetchFileByIdProgressResp* _msg = _internal_mutable_fetchfilebyidprogressresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  return _msg;
}

// .ServerData.FetchFileByIdCompletedResp FetchFileByIdCompletedResp = 111;
inline bool RelayRemoteMessage::_internal_has_fetchfilebyidcompletedresp() const {
  return Msg_case() == kFetchFileByIdCompletedResp;
}
inline bool RelayRemoteMessage::has_fetchfilebyidcompletedresp() const {
  return _internal_has_fetchfilebyidcompletedresp();
}
inline void RelayRemoteMessage::set_has_fetchfilebyidcompletedresp() {
  _impl_._oneof_case_[0] = kFetchFileByIdCompletedResp;
}
inline void RelayRemoteMessage::clear_fetchfilebyidcompletedresp() {
  if (_internal_has_fetchfilebyidcompletedresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidcompletedresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::release_fetchfilebyidcompletedresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  if (_internal_has_fetchfilebyidcompletedresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdCompletedResp* temp = _impl_.Msg_.fetchfilebyidcompletedresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidcompletedresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdCompletedResp& RelayRemoteMessage::_internal_fetchfilebyidcompletedresp() const {
  return _internal_has_fetchfilebyidcompletedresp()
      ? *_impl_.Msg_.fetchfilebyidcompletedresp_
      : reinterpret_cast< ::ServerData::FetchFileByIdCompletedResp&>(::ServerData::_FetchFileByIdCompletedResp_default_instance_);
}
inline const ::ServerData::FetchFileByIdCompletedResp& RelayRemoteMessage::fetchfilebyidcompletedresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  return _internal_fetchfilebyidcompletedresp();
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::unsafe_arena_release_fetchfilebyidcompletedresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  if (_internal_has_fetchfilebyidcompletedresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdCompletedResp* temp = _impl_.Msg_.fetchfilebyidcompletedresp_;
    _impl_.Msg_.fetchfilebyidcompletedresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchfilebyidcompletedresp(::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp) {
  clear_Msg();
  if (fetchfilebyidcompletedresp) {
    set_has_fetchfilebyidcompletedresp();
    _impl_.Msg_.fetchfilebyidcompletedresp_ = fetchfilebyidcompletedresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::_internal_mutable_fetchfilebyidcompletedresp() {
  if (!_internal_has_fetchfilebyidcompletedresp()) {
    clear_Msg();
    set_has_fetchfilebyidcompletedresp();
    _impl_.Msg_.fetchfilebyidcompletedresp_ = CreateMaybeMessage< ::ServerData::FetchFileByIdCompletedResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidcompletedresp_;
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::mutable_fetchfilebyidcompletedresp() {
  ::ServerData::FetchFileByIdCompletedResp* _msg = _internal_mutable_fetchfilebyidcompletedresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  return _msg;
}

// .ServerData.FetchAllUploadedContentResp FetchAllUploadedContentResp = 112;
inline bool RelayRemoteMessage::_internal_has_fetchalluploadedcontentresp() const {
  return Msg_case() == kFetchAllUploadedContentResp;
}
inline bool RelayRemoteMessage::has_fetchalluploadedcontentresp() const {
  return _internal_has_fetchalluploadedcontentresp();
}
inline void RelayRemoteMessage::set_has_fetchalluploadedcontentresp() {
  _impl_._oneof_case_[0] = kFetchAllUploadedContentResp;
}
inline void RelayRemoteMessage::clear_fetchalluploadedcontentresp() {
  if (_internal_has_fetchalluploadedcontentresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluploadedcontentresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::release_fetchalluploadedcontentresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  if (_internal_has_fetchalluploadedcontentresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentResp* temp = _impl_.Msg_.fetchalluploadedcontentresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluploadedcontentresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUploadedContentResp& RelayRemoteMessage::_internal_fetchalluploadedcontentresp() const {
  return _internal_has_fetchalluploadedcontentresp()
      ? *_impl_.Msg_.fetchalluploadedcontentresp_
      : reinterpret_cast< ::ServerData::FetchAllUploadedContentResp&>(::ServerData::_FetchAllUploadedContentResp_default_instance_);
}
inline const ::ServerData::FetchAllUploadedContentResp& RelayRemoteMessage::fetchalluploadedcontentresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  return _internal_fetchalluploadedcontentresp();
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::unsafe_arena_release_fetchalluploadedcontentresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  if (_internal_has_fetchalluploadedcontentresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentResp* temp = _impl_.Msg_.fetchalluploadedcontentresp_;
    _impl_.Msg_.fetchalluploadedcontentresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchalluploadedcontentresp(::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp) {
  clear_Msg();
  if (fetchalluploadedcontentresp) {
    set_has_fetchalluploadedcontentresp();
    _impl_.Msg_.fetchalluploadedcontentresp_ = fetchalluploadedcontentresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::_internal_mutable_fetchalluploadedcontentresp() {
  if (!_internal_has_fetchalluploadedcontentresp()) {
    clear_Msg();
    set_has_fetchalluploadedcontentresp();
    _impl_.Msg_.fetchalluploadedcontentresp_ = CreateMaybeMessage< ::ServerData::FetchAllUploadedContentResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluploadedcontentresp_;
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::mutable_fetchalluploadedcontentresp() {
  ::ServerData::FetchAllUploadedContentResp* _msg = _internal_mutable_fetchalluploadedcontentresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  return _msg;
}

// .ServerData.UploadLocalFileResp UploadLocalFileResp = 113;
inline bool RelayRemoteMessage::_internal_has_uploadlocalfileresp() const {
  return Msg_case() == kUploadLocalFileResp;
}
inline bool RelayRemoteMessage::has_uploadlocalfileresp() const {
  return _internal_has_uploadlocalfileresp();
}
inline void RelayRemoteMessage::set_has_uploadlocalfileresp() {
  _impl_._oneof_case_[0] = kUploadLocalFileResp;
}
inline void RelayRemoteMessage::clear_uploadlocalfileresp() {
  if (_internal_has_uploadlocalfileresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uploadlocalfileresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::release_uploadlocalfileresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  if (_internal_has_uploadlocalfileresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileResp* temp = _impl_.Msg_.uploadlocalfileresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uploadlocalfileresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UploadLocalFileResp& RelayRemoteMessage::_internal_uploadlocalfileresp() const {
  return _internal_has_uploadlocalfileresp()
      ? *_impl_.Msg_.uploadlocalfileresp_
      : reinterpret_cast< ::ServerData::UploadLocalFileResp&>(::ServerData::_UploadLocalFileResp_default_instance_);
}
inline const ::ServerData::UploadLocalFileResp& RelayRemoteMessage::uploadlocalfileresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  return _internal_uploadlocalfileresp();
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::unsafe_arena_release_uploadlocalfileresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  if (_internal_has_uploadlocalfileresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileResp* temp = _impl_.Msg_.uploadlocalfileresp_;
    _impl_.Msg_.uploadlocalfileresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_uploadlocalfileresp(::ServerData::UploadLocalFileResp* uploadlocalfileresp) {
  clear_Msg();
  if (uploadlocalfileresp) {
    set_has_uploadlocalfileresp();
    _impl_.Msg_.uploadlocalfileresp_ = uploadlocalfileresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UploadLocalFileResp)
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::_internal_mutable_uploadlocalfileresp() {
  if (!_internal_has_uploadlocalfileresp()) {
    clear_Msg();
    set_has_uploadlocalfileresp();
    _impl_.Msg_.uploadlocalfileresp_ = CreateMaybeMessage< ::ServerData::UploadLocalFileResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uploadlocalfileresp_;
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::mutable_uploadlocalfileresp() {
  ::ServerData::UploadLocalFileResp* _msg = _internal_mutable_uploadlocalfileresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  return _msg;
}

// .ServerData.ChatAdded ChatAdded = 120;
inline bool RelayRemoteMessage::_internal_has_chatadded() const {
  return Msg_case() == kChatAdded;
}
inline bool RelayRemoteMessage::has_chatadded() const {
  return _internal_has_chatadded();
}
inline void RelayRemoteMessage::set_has_chatadded() {
  _impl_._oneof_case_[0] = kChatAdded;
}
inline void RelayRemoteMessage::clear_chatadded() {
  if (_internal_has_chatadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::release_chatadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatAdded)
  if (_internal_has_chatadded()) {
    clear_has_Msg();
    ::ServerData::ChatAdded* temp = _impl_.Msg_.chatadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatAdded& RelayRemoteMessage::_internal_chatadded() const {
  return _internal_has_chatadded()
      ? *_impl_.Msg_.chatadded_
      : reinterpret_cast< ::ServerData::ChatAdded&>(::ServerData::_ChatAdded_default_instance_);
}
inline const ::ServerData::ChatAdded& RelayRemoteMessage::chatadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatAdded)
  return _internal_chatadded();
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::unsafe_arena_release_chatadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatAdded)
  if (_internal_has_chatadded()) {
    clear_has_Msg();
    ::ServerData::ChatAdded* temp = _impl_.Msg_.chatadded_;
    _impl_.Msg_.chatadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatadded(::ServerData::ChatAdded* chatadded) {
  clear_Msg();
  if (chatadded) {
    set_has_chatadded();
    _impl_.Msg_.chatadded_ = chatadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatAdded)
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::_internal_mutable_chatadded() {
  if (!_internal_has_chatadded()) {
    clear_Msg();
    set_has_chatadded();
    _impl_.Msg_.chatadded_ = CreateMaybeMessage< ::ServerData::ChatAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatadded_;
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::mutable_chatadded() {
  ::ServerData::ChatAdded* _msg = _internal_mutable_chatadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatAdded)
  return _msg;
}

// .ServerData.ChatUpdated ChatUpdated = 121;
inline bool RelayRemoteMessage::_internal_has_chatupdated() const {
  return Msg_case() == kChatUpdated;
}
inline bool RelayRemoteMessage::has_chatupdated() const {
  return _internal_has_chatupdated();
}
inline void RelayRemoteMessage::set_has_chatupdated() {
  _impl_._oneof_case_[0] = kChatUpdated;
}
inline void RelayRemoteMessage::clear_chatupdated() {
  if (_internal_has_chatupdated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatupdated_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::release_chatupdated() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatUpdated)
  if (_internal_has_chatupdated()) {
    clear_has_Msg();
    ::ServerData::ChatUpdated* temp = _impl_.Msg_.chatupdated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatUpdated& RelayRemoteMessage::_internal_chatupdated() const {
  return _internal_has_chatupdated()
      ? *_impl_.Msg_.chatupdated_
      : reinterpret_cast< ::ServerData::ChatUpdated&>(::ServerData::_ChatUpdated_default_instance_);
}
inline const ::ServerData::ChatUpdated& RelayRemoteMessage::chatupdated() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatUpdated)
  return _internal_chatupdated();
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::unsafe_arena_release_chatupdated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatUpdated)
  if (_internal_has_chatupdated()) {
    clear_has_Msg();
    ::ServerData::ChatUpdated* temp = _impl_.Msg_.chatupdated_;
    _impl_.Msg_.chatupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatupdated(::ServerData::ChatUpdated* chatupdated) {
  clear_Msg();
  if (chatupdated) {
    set_has_chatupdated();
    _impl_.Msg_.chatupdated_ = chatupdated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatUpdated)
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::_internal_mutable_chatupdated() {
  if (!_internal_has_chatupdated()) {
    clear_Msg();
    set_has_chatupdated();
    _impl_.Msg_.chatupdated_ = CreateMaybeMessage< ::ServerData::ChatUpdated >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatupdated_;
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::mutable_chatupdated() {
  ::ServerData::ChatUpdated* _msg = _internal_mutable_chatupdated();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatUpdated)
  return _msg;
}

// .ServerData.ChatRemoved ChatRemoved = 122;
inline bool RelayRemoteMessage::_internal_has_chatremoved() const {
  return Msg_case() == kChatRemoved;
}
inline bool RelayRemoteMessage::has_chatremoved() const {
  return _internal_has_chatremoved();
}
inline void RelayRemoteMessage::set_has_chatremoved() {
  _impl_._oneof_case_[0] = kChatRemoved;
}
inline void RelayRemoteMessage::clear_chatremoved() {
  if (_internal_has_chatremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::release_chatremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatRemoved)
  if (_internal_has_chatremoved()) {
    clear_has_Msg();
    ::ServerData::ChatRemoved* temp = _impl_.Msg_.chatremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatRemoved& RelayRemoteMessage::_internal_chatremoved() const {
  return _internal_has_chatremoved()
      ? *_impl_.Msg_.chatremoved_
      : reinterpret_cast< ::ServerData::ChatRemoved&>(::ServerData::_ChatRemoved_default_instance_);
}
inline const ::ServerData::ChatRemoved& RelayRemoteMessage::chatremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatRemoved)
  return _internal_chatremoved();
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::unsafe_arena_release_chatremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatRemoved)
  if (_internal_has_chatremoved()) {
    clear_has_Msg();
    ::ServerData::ChatRemoved* temp = _impl_.Msg_.chatremoved_;
    _impl_.Msg_.chatremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatremoved(::ServerData::ChatRemoved* chatremoved) {
  clear_Msg();
  if (chatremoved) {
    set_has_chatremoved();
    _impl_.Msg_.chatremoved_ = chatremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatRemoved)
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::_internal_mutable_chatremoved() {
  if (!_internal_has_chatremoved()) {
    clear_Msg();
    set_has_chatremoved();
    _impl_.Msg_.chatremoved_ = CreateMaybeMessage< ::ServerData::ChatRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatremoved_;
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::mutable_chatremoved() {
  ::ServerData::ChatRemoved* _msg = _internal_mutable_chatremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatRemoved)
  return _msg;
}

inline bool RelayRemoteMessage::has_Msg() const {
  return Msg_case() != MSG_NOT_SET;
}
inline void RelayRemoteMessage::clear_has_Msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline RelayRemoteMessage::MsgCase RelayRemoteMessage::Msg_case() const {
  return RelayRemoteMessage::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeepAlive

// -------------------------------------------------------------------

// UpdateTime

// double time = 1;
inline void UpdateTime::clear_time() {
  _impl_.time_ = 0;
}
inline double UpdateTime::_internal_time() const {
  return _impl_.time_;
}
inline double UpdateTime::time() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateTime.time)
  return _internal_time();
}
inline void UpdateTime::_internal_set_time(double value) {
  
  _impl_.time_ = value;
}
inline void UpdateTime::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateTime.time)
}

// -------------------------------------------------------------------

// StatusMessage

// string error = 1;
inline bool StatusMessage::_internal_has_error() const {
  return Message_case() == kError;
}
inline bool StatusMessage::has_error() const {
  return _internal_has_error();
}
inline void StatusMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void StatusMessage::clear_error() {
  if (_internal_has_error()) {
    _impl_.Message_.error_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::error() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  _impl_.Message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.error)
}
inline std::string* StatusMessage::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.error)
  return _s;
}
inline const std::string& StatusMessage::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  _impl_.Message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  return _impl_.Message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.error)
  if (_internal_has_error()) {
    clear_has_Message();
    return _impl_.Message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_error(std::string* error) {
  if (has_Message()) {
    clear_Message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.error)
}

// string warning = 2;
inline bool StatusMessage::_internal_has_warning() const {
  return Message_case() == kWarning;
}
inline bool StatusMessage::has_warning() const {
  return _internal_has_warning();
}
inline void StatusMessage::set_has_warning() {
  _impl_._oneof_case_[0] = kWarning;
}
inline void StatusMessage::clear_warning() {
  if (_internal_has_warning()) {
    _impl_.Message_.warning_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::warning() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_warning(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  _impl_.Message_.warning_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.warning)
}
inline std::string* StatusMessage::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.warning)
  return _s;
}
inline const std::string& StatusMessage::_internal_warning() const {
  if (_internal_has_warning()) {
    return _impl_.Message_.warning_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_warning(const std::string& value) {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  _impl_.Message_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_warning() {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  return _impl_.Message_.warning_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_warning() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.warning)
  if (_internal_has_warning()) {
    clear_has_Message();
    return _impl_.Message_.warning_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_warning(std::string* warning) {
  if (has_Message()) {
    clear_Message();
  }
  if (warning != nullptr) {
    set_has_warning();
    _impl_.Message_.warning_.InitAllocated(warning, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.warning)
}

// string log = 3;
inline bool StatusMessage::_internal_has_log() const {
  return Message_case() == kLog;
}
inline bool StatusMessage::has_log() const {
  return _internal_has_log();
}
inline void StatusMessage::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void StatusMessage::clear_log() {
  if (_internal_has_log()) {
    _impl_.Message_.log_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::log() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_log(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  _impl_.Message_.log_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.log)
}
inline std::string* StatusMessage::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.log)
  return _s;
}
inline const std::string& StatusMessage::_internal_log() const {
  if (_internal_has_log()) {
    return _impl_.Message_.log_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_log(const std::string& value) {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  _impl_.Message_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  return _impl_.Message_.log_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_log() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.log)
  if (_internal_has_log()) {
    clear_has_Message();
    return _impl_.Message_.log_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_log(std::string* log) {
  if (has_Message()) {
    clear_Message();
  }
  if (log != nullptr) {
    set_has_log();
    _impl_.Message_.log_.InitAllocated(log, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.log)
}

inline bool StatusMessage::has_Message() const {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void StatusMessage::clear_has_Message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline StatusMessage::MessageCase StatusMessage::Message_case() const {
  return StatusMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateReq

// int32 reqId = 1;
inline void AuthenticateReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.reqId)
}

// string server = 10;
inline void AuthenticateReq::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.server)
}
inline std::string* AuthenticateReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.server)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateReq::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.server)
  return _impl_.server_.Release();
}
inline void AuthenticateReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.server)
}

// string email = 11;
inline void AuthenticateReq::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::email() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.email)
}
inline std::string* AuthenticateReq::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.email)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_email() const {
  return _impl_.email_.Get();
}
inline void AuthenticateReq::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_email() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.email)
  return _impl_.email_.Release();
}
inline void AuthenticateReq::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.email)
}

// string password = 12;
inline void AuthenticateReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::password() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.password)
}
inline std::string* AuthenticateReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.password)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthenticateReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_password() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.password)
  return _impl_.password_.Release();
}
inline void AuthenticateReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.password)
}

// -------------------------------------------------------------------

// AuthenticateGuestReq

// int32 reqId = 1;
inline void AuthenticateGuestReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateGuestReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateGuestReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateGuestReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateGuestReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.reqId)
}

// string server = 10;
inline void AuthenticateGuestReq::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& AuthenticateGuestReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateGuestReq::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.server)
}
inline std::string* AuthenticateGuestReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestReq.server)
  return _s;
}
inline const std::string& AuthenticateGuestReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateGuestReq::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestReq.server)
  return _impl_.server_.Release();
}
inline void AuthenticateGuestReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateGuestReq.server)
}

// string screenName = 11;
inline void AuthenticateGuestReq::clear_screenname() {
  _impl_.screenname_.ClearToEmpty();
}
inline const std::string& AuthenticateGuestReq::screenname() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.screenName)
  return _internal_screenname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateGuestReq::set_screenname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.screenname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.screenName)
}
inline std::string* AuthenticateGuestReq::mutable_screenname() {
  std::string* _s = _internal_mutable_screenname();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestReq.screenName)
  return _s;
}
inline const std::string& AuthenticateGuestReq::_internal_screenname() const {
  return _impl_.screenname_.Get();
}
inline void AuthenticateGuestReq::_internal_set_screenname(const std::string& value) {
  
  _impl_.screenname_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::_internal_mutable_screenname() {
  
  return _impl_.screenname_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::release_screenname() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestReq.screenName)
  return _impl_.screenname_.Release();
}
inline void AuthenticateGuestReq::set_allocated_screenname(std::string* screenname) {
  if (screenname != nullptr) {
    
  } else {
    
  }
  _impl_.screenname_.SetAllocated(screenname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.screenname_.IsDefault()) {
    _impl_.screenname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateGuestReq.screenName)
}

// -------------------------------------------------------------------

// AuthenticateResp

// int32 reqId = 1;
inline void AuthenticateResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateResp.reqId)
}

// .ServerData.CavrnusAuth auth = 10;
inline bool AuthenticateResp::_internal_has_auth() const {
  return Resp_case() == kAuth;
}
inline bool AuthenticateResp::has_auth() const {
  return _internal_has_auth();
}
inline void AuthenticateResp::set_has_auth() {
  _impl_._oneof_case_[0] = kAuth;
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::release_auth() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateResp.auth)
  if (_internal_has_auth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuth* temp = _impl_.Resp_.auth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusAuth& AuthenticateResp::_internal_auth() const {
  return _internal_has_auth()
      ? *_impl_.Resp_.auth_
      : reinterpret_cast< ::ServerData::CavrnusAuth&>(::ServerData::_CavrnusAuth_default_instance_);
}
inline const ::ServerData::CavrnusAuth& AuthenticateResp::auth() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateResp.auth)
  return _internal_auth();
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.AuthenticateResp.auth)
  if (_internal_has_auth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuth* temp = _impl_.Resp_.auth_;
    _impl_.Resp_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateResp::unsafe_arena_set_allocated_auth(::ServerData::CavrnusAuth* auth) {
  clear_Resp();
  if (auth) {
    set_has_auth();
    _impl_.Resp_.auth_ = auth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.AuthenticateResp.auth)
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::_internal_mutable_auth() {
  if (!_internal_has_auth()) {
    clear_Resp();
    set_has_auth();
    _impl_.Resp_.auth_ = CreateMaybeMessage< ::ServerData::CavrnusAuth >(GetArenaForAllocation());
  }
  return _impl_.Resp_.auth_;
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::mutable_auth() {
  ::ServerData::CavrnusAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateResp.auth)
  return _msg;
}

// string error = 11;
inline bool AuthenticateResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool AuthenticateResp::has_error() const {
  return _internal_has_error();
}
inline void AuthenticateResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AuthenticateResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& AuthenticateResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateResp.error)
}
inline std::string* AuthenticateResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateResp.error)
  return _s;
}
inline const std::string& AuthenticateResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* AuthenticateResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void AuthenticateResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateResp.error)
}

inline bool AuthenticateResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void AuthenticateResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline AuthenticateResp::RespCase AuthenticateResp::Resp_case() const {
  return AuthenticateResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateGuestResp

// int32 reqId = 1;
inline void AuthenticateGuestResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateGuestResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateGuestResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateGuestResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateGuestResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestResp.reqId)
}

// .ServerData.CavrnusAuth auth = 10;
inline bool AuthenticateGuestResp::_internal_has_auth() const {
  return Resp_case() == kAuth;
}
inline bool AuthenticateGuestResp::has_auth() const {
  return _internal_has_auth();
}
inline void AuthenticateGuestResp::set_has_auth() {
  _impl_._oneof_case_[0] = kAuth;
}
inline ::ServerData::CavrnusAuth* AuthenticateGuestResp::release_auth() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestResp.auth)
  if (_internal_has_auth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuth* temp = _impl_.Resp_.auth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusAuth& AuthenticateGuestResp::_internal_auth() const {
  return _internal_has_auth()
      ? *_impl_.Resp_.auth_
      : reinterpret_cast< ::ServerData::CavrnusAuth&>(::ServerData::_CavrnusAuth_default_instance_);
}
inline const ::ServerData::CavrnusAuth& AuthenticateGuestResp::auth() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestResp.auth)
  return _internal_auth();
}
inline ::ServerData::CavrnusAuth* AuthenticateGuestResp::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.AuthenticateGuestResp.auth)
  if (_internal_has_auth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuth* temp = _impl_.Resp_.auth_;
    _impl_.Resp_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateGuestResp::unsafe_arena_set_allocated_auth(::ServerData::CavrnusAuth* auth) {
  clear_Resp();
  if (auth) {
    set_has_auth();
    _impl_.Resp_.auth_ = auth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.AuthenticateGuestResp.auth)
}
inline ::ServerData::CavrnusAuth* AuthenticateGuestResp::_internal_mutable_auth() {
  if (!_internal_has_auth()) {
    clear_Resp();
    set_has_auth();
    _impl_.Resp_.auth_ = CreateMaybeMessage< ::ServerData::CavrnusAuth >(GetArenaForAllocation());
  }
  return _impl_.Resp_.auth_;
}
inline ::ServerData::CavrnusAuth* AuthenticateGuestResp::mutable_auth() {
  ::ServerData::CavrnusAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestResp.auth)
  return _msg;
}

// string error = 11;
inline bool AuthenticateGuestResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool AuthenticateGuestResp::has_error() const {
  return _internal_has_error();
}
inline void AuthenticateGuestResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AuthenticateGuestResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& AuthenticateGuestResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateGuestResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestResp.error)
}
inline std::string* AuthenticateGuestResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestResp.error)
  return _s;
}
inline const std::string& AuthenticateGuestResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateGuestResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateGuestResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* AuthenticateGuestResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void AuthenticateGuestResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateGuestResp.error)
}

inline bool AuthenticateGuestResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void AuthenticateGuestResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline AuthenticateGuestResp::RespCase AuthenticateGuestResp::Resp_case() const {
  return AuthenticateGuestResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateWithLinkReq

// int32 reqId = 1;
inline void AuthenticateWithLinkReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateWithLinkReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateWithLinkReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateWithLinkReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateWithLinkReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkReq.reqId)
}

// string link = 10;
inline void AuthenticateWithLinkReq::clear_link() {
  _impl_.link_.ClearToEmpty();
}
inline const std::string& AuthenticateWithLinkReq::link() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkReq.link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateWithLinkReq::set_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkReq.link)
}
inline std::string* AuthenticateWithLinkReq::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateWithLinkReq.link)
  return _s;
}
inline const std::string& AuthenticateWithLinkReq::_internal_link() const {
  return _impl_.link_.Get();
}
inline void AuthenticateWithLinkReq::_internal_set_link(const std::string& value) {
  
  _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkReq::_internal_mutable_link() {
  
  return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkReq::release_link() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateWithLinkReq.link)
  return _impl_.link_.Release();
}
inline void AuthenticateWithLinkReq::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_.IsDefault()) {
    _impl_.link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateWithLinkReq.link)
}

// -------------------------------------------------------------------

// AuthenticateWithLinkResp

// int32 reqId = 1;
inline void AuthenticateWithLinkResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateWithLinkResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateWithLinkResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateWithLinkResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateWithLinkResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkResp.reqId)
}

// .ServerData.CavrnusAuthLinkResponse linkAuth = 10;
inline bool AuthenticateWithLinkResp::_internal_has_linkauth() const {
  return Resp_case() == kLinkAuth;
}
inline bool AuthenticateWithLinkResp::has_linkauth() const {
  return _internal_has_linkauth();
}
inline void AuthenticateWithLinkResp::set_has_linkauth() {
  _impl_._oneof_case_[0] = kLinkAuth;
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::release_linkauth() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateWithLinkResp.linkAuth)
  if (_internal_has_linkauth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuthLinkResponse* temp = _impl_.Resp_.linkauth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.linkauth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusAuthLinkResponse& AuthenticateWithLinkResp::_internal_linkauth() const {
  return _internal_has_linkauth()
      ? *_impl_.Resp_.linkauth_
      : reinterpret_cast< ::ServerData::CavrnusAuthLinkResponse&>(::ServerData::_CavrnusAuthLinkResponse_default_instance_);
}
inline const ::ServerData::CavrnusAuthLinkResponse& AuthenticateWithLinkResp::linkauth() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkResp.linkAuth)
  return _internal_linkauth();
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::unsafe_arena_release_linkauth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.AuthenticateWithLinkResp.linkAuth)
  if (_internal_has_linkauth()) {
    clear_has_Resp();
    ::ServerData::CavrnusAuthLinkResponse* temp = _impl_.Resp_.linkauth_;
    _impl_.Resp_.linkauth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateWithLinkResp::unsafe_arena_set_allocated_linkauth(::ServerData::CavrnusAuthLinkResponse* linkauth) {
  clear_Resp();
  if (linkauth) {
    set_has_linkauth();
    _impl_.Resp_.linkauth_ = linkauth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.AuthenticateWithLinkResp.linkAuth)
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::_internal_mutable_linkauth() {
  if (!_internal_has_linkauth()) {
    clear_Resp();
    set_has_linkauth();
    _impl_.Resp_.linkauth_ = CreateMaybeMessage< ::ServerData::CavrnusAuthLinkResponse >(GetArenaForAllocation());
  }
  return _impl_.Resp_.linkauth_;
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::mutable_linkauth() {
  ::ServerData::CavrnusAuthLinkResponse* _msg = _internal_mutable_linkauth();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateWithLinkResp.linkAuth)
  return _msg;
}

// string error = 11;
inline bool AuthenticateWithLinkResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool AuthenticateWithLinkResp::has_error() const {
  return _internal_has_error();
}
inline void AuthenticateWithLinkResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AuthenticateWithLinkResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& AuthenticateWithLinkResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateWithLinkResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkResp.error)
}
inline std::string* AuthenticateWithLinkResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateWithLinkResp.error)
  return _s;
}
inline const std::string& AuthenticateWithLinkResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateWithLinkResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateWithLinkResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void AuthenticateWithLinkResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateWithLinkResp.error)
}

inline bool AuthenticateWithLinkResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void AuthenticateWithLinkResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline AuthenticateWithLinkResp::RespCase AuthenticateWithLinkResp::Resp_case() const {
  return AuthenticateWithLinkResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExitAllSpacesAndLogoutReq

// int32 reqId = 1;
inline void ExitAllSpacesAndLogoutReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ExitAllSpacesAndLogoutReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ExitAllSpacesAndLogoutReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutReq.reqId)
  return _internal_reqid();
}
inline void ExitAllSpacesAndLogoutReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ExitAllSpacesAndLogoutReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutReq.reqId)
}

// -------------------------------------------------------------------

// ExitAllSpacesAndLogoutResp

// int32 reqId = 1;
inline void ExitAllSpacesAndLogoutResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ExitAllSpacesAndLogoutResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ExitAllSpacesAndLogoutResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.reqId)
  return _internal_reqid();
}
inline void ExitAllSpacesAndLogoutResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ExitAllSpacesAndLogoutResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.reqId)
}

// bool logoutSuccess = 10;
inline bool ExitAllSpacesAndLogoutResp::_internal_has_logoutsuccess() const {
  return Resp_case() == kLogoutSuccess;
}
inline bool ExitAllSpacesAndLogoutResp::has_logoutsuccess() const {
  return _internal_has_logoutsuccess();
}
inline void ExitAllSpacesAndLogoutResp::set_has_logoutsuccess() {
  _impl_._oneof_case_[0] = kLogoutSuccess;
}
inline void ExitAllSpacesAndLogoutResp::clear_logoutsuccess() {
  if (_internal_has_logoutsuccess()) {
    _impl_.Resp_.logoutsuccess_ = false;
    clear_has_Resp();
  }
}
inline bool ExitAllSpacesAndLogoutResp::_internal_logoutsuccess() const {
  if (_internal_has_logoutsuccess()) {
    return _impl_.Resp_.logoutsuccess_;
  }
  return false;
}
inline void ExitAllSpacesAndLogoutResp::_internal_set_logoutsuccess(bool value) {
  if (!_internal_has_logoutsuccess()) {
    clear_Resp();
    set_has_logoutsuccess();
  }
  _impl_.Resp_.logoutsuccess_ = value;
}
inline bool ExitAllSpacesAndLogoutResp::logoutsuccess() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.logoutSuccess)
  return _internal_logoutsuccess();
}
inline void ExitAllSpacesAndLogoutResp::set_logoutsuccess(bool value) {
  _internal_set_logoutsuccess(value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.logoutSuccess)
}

// string error = 11;
inline bool ExitAllSpacesAndLogoutResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool ExitAllSpacesAndLogoutResp::has_error() const {
  return _internal_has_error();
}
inline void ExitAllSpacesAndLogoutResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void ExitAllSpacesAndLogoutResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& ExitAllSpacesAndLogoutResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void ExitAllSpacesAndLogoutResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.error)
}
inline std::string* ExitAllSpacesAndLogoutResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.ExitAllSpacesAndLogoutResp.error)
  return _s;
}
inline const std::string& ExitAllSpacesAndLogoutResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ExitAllSpacesAndLogoutResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ExitAllSpacesAndLogoutResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* ExitAllSpacesAndLogoutResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.ExitAllSpacesAndLogoutResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void ExitAllSpacesAndLogoutResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.ExitAllSpacesAndLogoutResp.error)
}

// repeated int32 spacesExited = 20;
inline int ExitAllSpacesAndLogoutResp::_internal_spacesexited_size() const {
  return _impl_.spacesexited_.size();
}
inline int ExitAllSpacesAndLogoutResp::spacesexited_size() const {
  return _internal_spacesexited_size();
}
inline void ExitAllSpacesAndLogoutResp::clear_spacesexited() {
  _impl_.spacesexited_.Clear();
}
inline int32_t ExitAllSpacesAndLogoutResp::_internal_spacesexited(int index) const {
  return _impl_.spacesexited_.Get(index);
}
inline int32_t ExitAllSpacesAndLogoutResp::spacesexited(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_spacesexited(index);
}
inline void ExitAllSpacesAndLogoutResp::set_spacesexited(int index, int32_t value) {
  _impl_.spacesexited_.Set(index, value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
}
inline void ExitAllSpacesAndLogoutResp::_internal_add_spacesexited(int32_t value) {
  _impl_.spacesexited_.Add(value);
}
inline void ExitAllSpacesAndLogoutResp::add_spacesexited(int32_t value) {
  _internal_add_spacesexited(value);
  // @@protoc_insertion_point(field_add:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ExitAllSpacesAndLogoutResp::_internal_spacesexited() const {
  return _impl_.spacesexited_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ExitAllSpacesAndLogoutResp::spacesexited() const {
  // @@protoc_insertion_point(field_list:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_spacesexited();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ExitAllSpacesAndLogoutResp::_internal_mutable_spacesexited() {
  return &_impl_.spacesexited_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ExitAllSpacesAndLogoutResp::mutable_spacesexited() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_mutable_spacesexited();
}

inline bool ExitAllSpacesAndLogoutResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void ExitAllSpacesAndLogoutResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline ExitAllSpacesAndLogoutResp::RespCase ExitAllSpacesAndLogoutResp::Resp_case() const {
  return ExitAllSpacesAndLogoutResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// JoinSpaceFromIdReq

// int32 reqId = 1;
inline void JoinSpaceFromIdReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t JoinSpaceFromIdReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t JoinSpaceFromIdReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdReq.reqId)
  return _internal_reqid();
}
inline void JoinSpaceFromIdReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void JoinSpaceFromIdReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdReq.reqId)
}

// string spaceId = 10;
inline void JoinSpaceFromIdReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& JoinSpaceFromIdReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinSpaceFromIdReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdReq.spaceId)
}
inline std::string* JoinSpaceFromIdReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdReq.spaceId)
  return _s;
}
inline const std::string& JoinSpaceFromIdReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void JoinSpaceFromIdReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void JoinSpaceFromIdReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.JoinSpaceFromIdReq.spaceId)
}

// -------------------------------------------------------------------

// JoinSpaceFromIdResp

// int32 reqId = 1;
inline void JoinSpaceFromIdResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t JoinSpaceFromIdResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t JoinSpaceFromIdResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.reqId)
  return _internal_reqid();
}
inline void JoinSpaceFromIdResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void JoinSpaceFromIdResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdResp.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 10;
inline bool JoinSpaceFromIdResp::_internal_has_spaceconn() const {
  return Resp_case() == kSpaceConn;
}
inline bool JoinSpaceFromIdResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline void JoinSpaceFromIdResp::set_has_spaceconn() {
  _impl_._oneof_case_[0] = kSpaceConn;
}
inline ::ServerData::CavrnusSpaceConnection* JoinSpaceFromIdResp::release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnection* temp = _impl_.Resp_.spaceconn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusSpaceConnection& JoinSpaceFromIdResp::_internal_spaceconn() const {
  return _internal_has_spaceconn()
      ? *_impl_.Resp_.spaceconn_
      : reinterpret_cast< ::ServerData::CavrnusSpaceConnection&>(::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& JoinSpaceFromIdResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.spaceConn)
  return _internal_spaceconn();
}
inline ::ServerData::CavrnusSpaceConnection* JoinSpaceFromIdResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.JoinSpaceFromIdResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnection* temp = _impl_.Resp_.spaceconn_;
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JoinSpaceFromIdResp::unsafe_arena_set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  clear_Resp();
  if (spaceconn) {
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = spaceconn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.JoinSpaceFromIdResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* JoinSpaceFromIdResp::_internal_mutable_spaceconn() {
  if (!_internal_has_spaceconn()) {
    clear_Resp();
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = CreateMaybeMessage< ::ServerData::CavrnusSpaceConnection >(GetArenaForAllocation());
  }
  return _impl_.Resp_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* JoinSpaceFromIdResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdResp.spaceConn)
  return _msg;
}

// string error = 11;
inline bool JoinSpaceFromIdResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool JoinSpaceFromIdResp::has_error() const {
  return _internal_has_error();
}
inline void JoinSpaceFromIdResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void JoinSpaceFromIdResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& JoinSpaceFromIdResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void JoinSpaceFromIdResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdResp.error)
}
inline std::string* JoinSpaceFromIdResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdResp.error)
  return _s;
}
inline const std::string& JoinSpaceFromIdResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void JoinSpaceFromIdResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void JoinSpaceFromIdResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.JoinSpaceFromIdResp.error)
}

inline bool JoinSpaceFromIdResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void JoinSpaceFromIdResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline JoinSpaceFromIdResp::RespCase JoinSpaceFromIdResp::Resp_case() const {
  return JoinSpaceFromIdResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShutdownSpaceConnectionReq

// int32 reqId = 1;
inline void ShutdownSpaceConnectionReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ShutdownSpaceConnectionReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ShutdownSpaceConnectionReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionReq.reqId)
  return _internal_reqid();
}
inline void ShutdownSpaceConnectionReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ShutdownSpaceConnectionReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ShutdownSpaceConnectionReq.reqId)
}

// .ServerData.CavrnusSpaceConnection SpaceConnection = 10;
inline bool ShutdownSpaceConnectionReq::_internal_has_spaceconnection() const {
  return this != internal_default_instance() && _impl_.spaceconnection_ != nullptr;
}
inline bool ShutdownSpaceConnectionReq::has_spaceconnection() const {
  return _internal_has_spaceconnection();
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionReq::_internal_spaceconnection() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionReq::spaceconnection() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  return _internal_spaceconnection();
}
inline void ShutdownSpaceConnectionReq::unsafe_arena_set_allocated_spaceconnection(
    ::ServerData::CavrnusSpaceConnection* spaceconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconnection_);
  }
  _impl_.spaceconnection_ = spaceconnection;
  if (spaceconnection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::release_spaceconnection() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconnection_;
  _impl_.spaceconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::unsafe_arena_release_spaceconnection() {
  // @@protoc_insertion_point(field_release:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconnection_;
  _impl_.spaceconnection_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::_internal_mutable_spaceconnection() {
  
  if (_impl_.spaceconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconnection_ = p;
  }
  return _impl_.spaceconnection_;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::mutable_spaceconnection() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconnection();
  // @@protoc_insertion_point(field_mutable:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  return _msg;
}
inline void ShutdownSpaceConnectionReq::set_allocated_spaceconnection(::ServerData::CavrnusSpaceConnection* spaceconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconnection_);
  }
  if (spaceconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconnection));
    if (message_arena != submessage_arena) {
      spaceconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconnection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconnection_ = spaceconnection;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
}

// -------------------------------------------------------------------

// ShutdownSpaceConnectionResp

// int32 reqId = 1;
inline void ShutdownSpaceConnectionResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ShutdownSpaceConnectionResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ShutdownSpaceConnectionResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionResp.reqId)
  return _internal_reqid();
}
inline void ShutdownSpaceConnectionResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ShutdownSpaceConnectionResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ShutdownSpaceConnectionResp.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 10;
inline bool ShutdownSpaceConnectionResp::_internal_has_spaceconn() const {
  return Resp_case() == kSpaceConn;
}
inline bool ShutdownSpaceConnectionResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline void ShutdownSpaceConnectionResp::set_has_spaceconn() {
  _impl_._oneof_case_[0] = kSpaceConn;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnection* temp = _impl_.Resp_.spaceconn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionResp::_internal_spaceconn() const {
  return _internal_has_spaceconn()
      ? *_impl_.Resp_.spaceconn_
      : reinterpret_cast< ::ServerData::CavrnusSpaceConnection&>(::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  return _internal_spaceconn();
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnection* temp = _impl_.Resp_.spaceconn_;
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShutdownSpaceConnectionResp::unsafe_arena_set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  clear_Resp();
  if (spaceconn) {
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = spaceconn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ShutdownSpaceConnectionResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::_internal_mutable_spaceconn() {
  if (!_internal_has_spaceconn()) {
    clear_Resp();
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = CreateMaybeMessage< ::ServerData::CavrnusSpaceConnection >(GetArenaForAllocation());
  }
  return _impl_.Resp_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  return _msg;
}

// string error = 11;
inline bool ShutdownSpaceConnectionResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool ShutdownSpaceConnectionResp::has_error() const {
  return _internal_has_error();
}
inline void ShutdownSpaceConnectionResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void ShutdownSpaceConnectionResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& ShutdownSpaceConnectionResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void ShutdownSpaceConnectionResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ShutdownSpaceConnectionResp.error)
}
inline std::string* ShutdownSpaceConnectionResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.ShutdownSpaceConnectionResp.error)
  return _s;
}
inline const std::string& ShutdownSpaceConnectionResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ShutdownSpaceConnectionResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ShutdownSpaceConnectionResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* ShutdownSpaceConnectionResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.ShutdownSpaceConnectionResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void ShutdownSpaceConnectionResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.ShutdownSpaceConnectionResp.error)
}

inline bool ShutdownSpaceConnectionResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void ShutdownSpaceConnectionResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline ShutdownSpaceConnectionResp::RespCase ShutdownSpaceConnectionResp::Resp_case() const {
  return ShutdownSpaceConnectionResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateSpaceReq

// int32 reqId = 1;
inline void CreateSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CreateSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CreateSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceReq.reqId)
  return _internal_reqid();
}
inline void CreateSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CreateSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.reqId)
}

// string newSpaceName = 10;
inline void CreateSpaceReq::clear_newspacename() {
  _impl_.newspacename_.ClearToEmpty();
}
inline const std::string& CreateSpaceReq::newspacename() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceReq.newSpaceName)
  return _internal_newspacename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSpaceReq::set_newspacename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newspacename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.newSpaceName)
}
inline std::string* CreateSpaceReq::mutable_newspacename() {
  std::string* _s = _internal_mutable_newspacename();
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceReq.newSpaceName)
  return _s;
}
inline const std::string& CreateSpaceReq::_internal_newspacename() const {
  return _impl_.newspacename_.Get();
}
inline void CreateSpaceReq::_internal_set_newspacename(const std::string& value) {
  
  _impl_.newspacename_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSpaceReq::_internal_mutable_newspacename() {
  
  return _impl_.newspacename_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSpaceReq::release_newspacename() {
  // @@protoc_insertion_point(field_release:ServerData.CreateSpaceReq.newSpaceName)
  return _impl_.newspacename_.Release();
}
inline void CreateSpaceReq::set_allocated_newspacename(std::string* newspacename) {
  if (newspacename != nullptr) {
    
  } else {
    
  }
  _impl_.newspacename_.SetAllocated(newspacename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newspacename_.IsDefault()) {
    _impl_.newspacename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CreateSpaceReq.newSpaceName)
}

// -------------------------------------------------------------------

// CreateSpaceResp

// int32 reqId = 1;
inline void CreateSpaceResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CreateSpaceResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CreateSpaceResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceResp.reqId)
  return _internal_reqid();
}
inline void CreateSpaceResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CreateSpaceResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceResp.reqId)
}

// .ServerData.SpaceInfo newSpaceInfo = 10;
inline bool CreateSpaceResp::_internal_has_newspaceinfo() const {
  return Resp_case() == kNewSpaceInfo;
}
inline bool CreateSpaceResp::has_newspaceinfo() const {
  return _internal_has_newspaceinfo();
}
inline void CreateSpaceResp::set_has_newspaceinfo() {
  _impl_._oneof_case_[0] = kNewSpaceInfo;
}
inline void CreateSpaceResp::clear_newspaceinfo() {
  if (_internal_has_newspaceinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Resp_.newspaceinfo_;
    }
    clear_has_Resp();
  }
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::release_newspaceinfo() {
  // @@protoc_insertion_point(field_release:ServerData.CreateSpaceResp.newSpaceInfo)
  if (_internal_has_newspaceinfo()) {
    clear_has_Resp();
    ::ServerData::SpaceInfo* temp = _impl_.Resp_.newspaceinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.newspaceinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& CreateSpaceResp::_internal_newspaceinfo() const {
  return _internal_has_newspaceinfo()
      ? *_impl_.Resp_.newspaceinfo_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& CreateSpaceResp::newspaceinfo() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceResp.newSpaceInfo)
  return _internal_newspaceinfo();
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::unsafe_arena_release_newspaceinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.CreateSpaceResp.newSpaceInfo)
  if (_internal_has_newspaceinfo()) {
    clear_has_Resp();
    ::ServerData::SpaceInfo* temp = _impl_.Resp_.newspaceinfo_;
    _impl_.Resp_.newspaceinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateSpaceResp::unsafe_arena_set_allocated_newspaceinfo(::ServerData::SpaceInfo* newspaceinfo) {
  clear_Resp();
  if (newspaceinfo) {
    set_has_newspaceinfo();
    _impl_.Resp_.newspaceinfo_ = newspaceinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CreateSpaceResp.newSpaceInfo)
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::_internal_mutable_newspaceinfo() {
  if (!_internal_has_newspaceinfo()) {
    clear_Resp();
    set_has_newspaceinfo();
    _impl_.Resp_.newspaceinfo_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Resp_.newspaceinfo_;
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::mutable_newspaceinfo() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_newspaceinfo();
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceResp.newSpaceInfo)
  return _msg;
}

// string error = 11;
inline bool CreateSpaceResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool CreateSpaceResp::has_error() const {
  return _internal_has_error();
}
inline void CreateSpaceResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void CreateSpaceResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& CreateSpaceResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void CreateSpaceResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceResp.error)
}
inline std::string* CreateSpaceResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceResp.error)
  return _s;
}
inline const std::string& CreateSpaceResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateSpaceResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSpaceResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateSpaceResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.CreateSpaceResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateSpaceResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.CreateSpaceResp.error)
}

inline bool CreateSpaceResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void CreateSpaceResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline CreateSpaceResp::RespCase CreateSpaceResp::Resp_case() const {
  return CreateSpaceResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PropertyValue

// bool boolVal = 10;
inline bool PropertyValue::_internal_has_boolval() const {
  return Value_case() == kBoolVal;
}
inline bool PropertyValue::has_boolval() const {
  return _internal_has_boolval();
}
inline void PropertyValue::set_has_boolval() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void PropertyValue::clear_boolval() {
  if (_internal_has_boolval()) {
    _impl_.Value_.boolval_ = false;
    clear_has_Value();
  }
}
inline bool PropertyValue::_internal_boolval() const {
  if (_internal_has_boolval()) {
    return _impl_.Value_.boolval_;
  }
  return false;
}
inline void PropertyValue::_internal_set_boolval(bool value) {
  if (!_internal_has_boolval()) {
    clear_Value();
    set_has_boolval();
  }
  _impl_.Value_.boolval_ = value;
}
inline bool PropertyValue::boolval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.boolVal)
  return _internal_boolval();
}
inline void PropertyValue::set_boolval(bool value) {
  _internal_set_boolval(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.boolVal)
}

// string stringVal = 11;
inline bool PropertyValue::_internal_has_stringval() const {
  return Value_case() == kStringVal;
}
inline bool PropertyValue::has_stringval() const {
  return _internal_has_stringval();
}
inline void PropertyValue::set_has_stringval() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void PropertyValue::clear_stringval() {
  if (_internal_has_stringval()) {
    _impl_.Value_.stringval_.Destroy();
    clear_has_Value();
  }
}
inline const std::string& PropertyValue::stringval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.stringVal)
  return _internal_stringval();
}
template <typename ArgT0, typename... ArgT>
inline void PropertyValue::set_stringval(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  _impl_.Value_.stringval_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.stringVal)
}
inline std::string* PropertyValue::mutable_stringval() {
  std::string* _s = _internal_mutable_stringval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.stringVal)
  return _s;
}
inline const std::string& PropertyValue::_internal_stringval() const {
  if (_internal_has_stringval()) {
    return _impl_.Value_.stringval_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PropertyValue::_internal_set_stringval(const std::string& value) {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  _impl_.Value_.stringval_.Set(value, GetArenaForAllocation());
}
inline std::string* PropertyValue::_internal_mutable_stringval() {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  return _impl_.Value_.stringval_.Mutable(      GetArenaForAllocation());
}
inline std::string* PropertyValue::release_stringval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.stringVal)
  if (_internal_has_stringval()) {
    clear_has_Value();
    return _impl_.Value_.stringval_.Release();
  } else {
    return nullptr;
  }
}
inline void PropertyValue::set_allocated_stringval(std::string* stringval) {
  if (has_Value()) {
    clear_Value();
  }
  if (stringval != nullptr) {
    set_has_stringval();
    _impl_.Value_.stringval_.InitAllocated(stringval, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValue.stringVal)
}

// float scalarVal = 12;
inline bool PropertyValue::_internal_has_scalarval() const {
  return Value_case() == kScalarVal;
}
inline bool PropertyValue::has_scalarval() const {
  return _internal_has_scalarval();
}
inline void PropertyValue::set_has_scalarval() {
  _impl_._oneof_case_[0] = kScalarVal;
}
inline void PropertyValue::clear_scalarval() {
  if (_internal_has_scalarval()) {
    _impl_.Value_.scalarval_ = 0;
    clear_has_Value();
  }
}
inline float PropertyValue::_internal_scalarval() const {
  if (_internal_has_scalarval()) {
    return _impl_.Value_.scalarval_;
  }
  return 0;
}
inline void PropertyValue::_internal_set_scalarval(float value) {
  if (!_internal_has_scalarval()) {
    clear_Value();
    set_has_scalarval();
  }
  _impl_.Value_.scalarval_ = value;
}
inline float PropertyValue::scalarval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.scalarVal)
  return _internal_scalarval();
}
inline void PropertyValue::set_scalarval(float value) {
  _internal_set_scalarval(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.scalarVal)
}

// .Common.Float4 vectorVal = 13;
inline bool PropertyValue::_internal_has_vectorval() const {
  return Value_case() == kVectorVal;
}
inline bool PropertyValue::has_vectorval() const {
  return _internal_has_vectorval();
}
inline void PropertyValue::set_has_vectorval() {
  _impl_._oneof_case_[0] = kVectorVal;
}
inline ::Common::Float4* PropertyValue::release_vectorval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.vectorVal)
  if (_internal_has_vectorval()) {
    clear_has_Value();
    ::Common::Float4* temp = _impl_.Value_.vectorval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.vectorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::Float4& PropertyValue::_internal_vectorval() const {
  return _internal_has_vectorval()
      ? *_impl_.Value_.vectorval_
      : reinterpret_cast< ::Common::Float4&>(::Common::_Float4_default_instance_);
}
inline const ::Common::Float4& PropertyValue::vectorval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.vectorVal)
  return _internal_vectorval();
}
inline ::Common::Float4* PropertyValue::unsafe_arena_release_vectorval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.vectorVal)
  if (_internal_has_vectorval()) {
    clear_has_Value();
    ::Common::Float4* temp = _impl_.Value_.vectorval_;
    _impl_.Value_.vectorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_vectorval(::Common::Float4* vectorval) {
  clear_Value();
  if (vectorval) {
    set_has_vectorval();
    _impl_.Value_.vectorval_ = vectorval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.vectorVal)
}
inline ::Common::Float4* PropertyValue::_internal_mutable_vectorval() {
  if (!_internal_has_vectorval()) {
    clear_Value();
    set_has_vectorval();
    _impl_.Value_.vectorval_ = CreateMaybeMessage< ::Common::Float4 >(GetArenaForAllocation());
  }
  return _impl_.Value_.vectorval_;
}
inline ::Common::Float4* PropertyValue::mutable_vectorval() {
  ::Common::Float4* _msg = _internal_mutable_vectorval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.vectorVal)
  return _msg;
}

// .Common.Color4 colorVal = 14;
inline bool PropertyValue::_internal_has_colorval() const {
  return Value_case() == kColorVal;
}
inline bool PropertyValue::has_colorval() const {
  return _internal_has_colorval();
}
inline void PropertyValue::set_has_colorval() {
  _impl_._oneof_case_[0] = kColorVal;
}
inline ::Common::Color4* PropertyValue::release_colorval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.colorVal)
  if (_internal_has_colorval()) {
    clear_has_Value();
    ::Common::Color4* temp = _impl_.Value_.colorval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.colorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::Color4& PropertyValue::_internal_colorval() const {
  return _internal_has_colorval()
      ? *_impl_.Value_.colorval_
      : reinterpret_cast< ::Common::Color4&>(::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& PropertyValue::colorval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.colorVal)
  return _internal_colorval();
}
inline ::Common::Color4* PropertyValue::unsafe_arena_release_colorval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.colorVal)
  if (_internal_has_colorval()) {
    clear_has_Value();
    ::Common::Color4* temp = _impl_.Value_.colorval_;
    _impl_.Value_.colorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_colorval(::Common::Color4* colorval) {
  clear_Value();
  if (colorval) {
    set_has_colorval();
    _impl_.Value_.colorval_ = colorval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.colorVal)
}
inline ::Common::Color4* PropertyValue::_internal_mutable_colorval() {
  if (!_internal_has_colorval()) {
    clear_Value();
    set_has_colorval();
    _impl_.Value_.colorval_ = CreateMaybeMessage< ::Common::Color4 >(GetArenaForAllocation());
  }
  return _impl_.Value_.colorval_;
}
inline ::Common::Color4* PropertyValue::mutable_colorval() {
  ::Common::Color4* _msg = _internal_mutable_colorval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.colorVal)
  return _msg;
}

// .ServerData.TransformPropertyValue transformVal = 17;
inline bool PropertyValue::_internal_has_transformval() const {
  return Value_case() == kTransformVal;
}
inline bool PropertyValue::has_transformval() const {
  return _internal_has_transformval();
}
inline void PropertyValue::set_has_transformval() {
  _impl_._oneof_case_[0] = kTransformVal;
}
inline void PropertyValue::clear_transformval() {
  if (_internal_has_transformval()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Value_.transformval_;
    }
    clear_has_Value();
  }
}
inline ::ServerData::TransformPropertyValue* PropertyValue::release_transformval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.transformVal)
  if (_internal_has_transformval()) {
    clear_has_Value();
    ::ServerData::TransformPropertyValue* temp = _impl_.Value_.transformval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.transformval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::TransformPropertyValue& PropertyValue::_internal_transformval() const {
  return _internal_has_transformval()
      ? *_impl_.Value_.transformval_
      : reinterpret_cast< ::ServerData::TransformPropertyValue&>(::ServerData::_TransformPropertyValue_default_instance_);
}
inline const ::ServerData::TransformPropertyValue& PropertyValue::transformval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.transformVal)
  return _internal_transformval();
}
inline ::ServerData::TransformPropertyValue* PropertyValue::unsafe_arena_release_transformval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.transformVal)
  if (_internal_has_transformval()) {
    clear_has_Value();
    ::ServerData::TransformPropertyValue* temp = _impl_.Value_.transformval_;
    _impl_.Value_.transformval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_transformval(::ServerData::TransformPropertyValue* transformval) {
  clear_Value();
  if (transformval) {
    set_has_transformval();
    _impl_.Value_.transformval_ = transformval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.transformVal)
}
inline ::ServerData::TransformPropertyValue* PropertyValue::_internal_mutable_transformval() {
  if (!_internal_has_transformval()) {
    clear_Value();
    set_has_transformval();
    _impl_.Value_.transformval_ = CreateMaybeMessage< ::ServerData::TransformPropertyValue >(GetArenaForAllocation());
  }
  return _impl_.Value_.transformval_;
}
inline ::ServerData::TransformPropertyValue* PropertyValue::mutable_transformval() {
  ::ServerData::TransformPropertyValue* _msg = _internal_mutable_transformval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.transformVal)
  return _msg;
}

// .Property.PropertyIdentifier linkVal = 15;
inline bool PropertyValue::_internal_has_linkval() const {
  return Value_case() == kLinkVal;
}
inline bool PropertyValue::has_linkval() const {
  return _internal_has_linkval();
}
inline void PropertyValue::set_has_linkval() {
  _impl_._oneof_case_[0] = kLinkVal;
}
inline ::Property::PropertyIdentifier* PropertyValue::release_linkval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.linkVal)
  if (_internal_has_linkval()) {
    clear_has_Value();
    ::Property::PropertyIdentifier* temp = _impl_.Value_.linkval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.linkval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::PropertyIdentifier& PropertyValue::_internal_linkval() const {
  return _internal_has_linkval()
      ? *_impl_.Value_.linkval_
      : reinterpret_cast< ::Property::PropertyIdentifier&>(::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropertyValue::linkval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.linkVal)
  return _internal_linkval();
}
inline ::Property::PropertyIdentifier* PropertyValue::unsafe_arena_release_linkval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.linkVal)
  if (_internal_has_linkval()) {
    clear_has_Value();
    ::Property::PropertyIdentifier* temp = _impl_.Value_.linkval_;
    _impl_.Value_.linkval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_linkval(::Property::PropertyIdentifier* linkval) {
  clear_Value();
  if (linkval) {
    set_has_linkval();
    _impl_.Value_.linkval_ = linkval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.linkVal)
}
inline ::Property::PropertyIdentifier* PropertyValue::_internal_mutable_linkval() {
  if (!_internal_has_linkval()) {
    clear_Value();
    set_has_linkval();
    _impl_.Value_.linkval_ = CreateMaybeMessage< ::Property::PropertyIdentifier >(GetArenaForAllocation());
  }
  return _impl_.Value_.linkval_;
}
inline ::Property::PropertyIdentifier* PropertyValue::mutable_linkval() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_linkval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.linkVal)
  return _msg;
}

inline bool PropertyValue::has_Value() const {
  return Value_case() != VALUE_NOT_SET;
}
inline void PropertyValue::clear_has_Value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline PropertyValue::ValueCase PropertyValue::Value_case() const {
  return PropertyValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DefinePropertyDefaultValue

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool DefinePropertyDefaultValue::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool DefinePropertyDefaultValue::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& DefinePropertyDefaultValue::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& DefinePropertyDefaultValue::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.SpaceConn)
  return _internal_spaceconn();
}
inline void DefinePropertyDefaultValue::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.DefinePropertyDefaultValue.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.SpaceConn)
  return _msg;
}
inline void DefinePropertyDefaultValue::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.SpaceConn)
}

// string PropertyId = 2;
inline void DefinePropertyDefaultValue::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& DefinePropertyDefaultValue::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefinePropertyDefaultValue::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.DefinePropertyDefaultValue.PropertyId)
}
inline std::string* DefinePropertyDefaultValue::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _s;
}
inline const std::string& DefinePropertyDefaultValue::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void DefinePropertyDefaultValue::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* DefinePropertyDefaultValue::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* DefinePropertyDefaultValue::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void DefinePropertyDefaultValue::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyId)
}

// int32 localChangeId = 3;
inline void DefinePropertyDefaultValue::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t DefinePropertyDefaultValue::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t DefinePropertyDefaultValue::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.localChangeId)
  return _internal_localchangeid();
}
inline void DefinePropertyDefaultValue::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void DefinePropertyDefaultValue::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.DefinePropertyDefaultValue.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool DefinePropertyDefaultValue::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool DefinePropertyDefaultValue::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void DefinePropertyDefaultValue::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& DefinePropertyDefaultValue::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& DefinePropertyDefaultValue::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.PropertyValue)
  return _internal_propertyvalue();
}
inline void DefinePropertyDefaultValue::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyValue)
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.PropertyValue)
  return _msg;
}
inline void DefinePropertyDefaultValue::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyValue)
}

// -------------------------------------------------------------------

// PostPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool PostPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void PostPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.SpaceConn)
  return _msg;
}
inline void PostPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.SpaceConn)
}

// string PropertyId = 3;
inline void PostPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& PostPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.PropertyId)
}
inline std::string* PostPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& PostPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void PostPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void PostPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void PostPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t PostPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t PostPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void PostPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void PostPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool PostPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool PostPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void PostPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& PostPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& PostPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void PostPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.PropertyValue)
  return _msg;
}
inline void PostPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void PostPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool PostPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool PostPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void PostPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void PostPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// BeginTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool BeginTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool BeginTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& BeginTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& BeginTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void BeginTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.BeginTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void BeginTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void BeginTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& BeginTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeginTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* BeginTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& BeginTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void BeginTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void BeginTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void BeginTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& BeginTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeginTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.PropertyId)
}
inline std::string* BeginTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& BeginTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void BeginTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void BeginTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void BeginTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t BeginTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t BeginTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void BeginTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void BeginTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool BeginTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool BeginTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void BeginTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& BeginTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& BeginTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void BeginTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void BeginTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void BeginTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool BeginTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool BeginTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void BeginTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void BeginTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// ContinueTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool ContinueTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ContinueTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ContinueTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ContinueTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void ContinueTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void ContinueTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void ContinueTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& ContinueTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContinueTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* ContinueTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& ContinueTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void ContinueTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void ContinueTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void ContinueTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& ContinueTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContinueTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.PropertyId)
}
inline std::string* ContinueTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& ContinueTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void ContinueTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void ContinueTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void ContinueTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t ContinueTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t ContinueTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void ContinueTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void ContinueTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool ContinueTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool ContinueTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void ContinueTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& ContinueTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& ContinueTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void ContinueTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void ContinueTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void ContinueTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool ContinueTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool ContinueTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void ContinueTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void ContinueTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// FinalizeTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool FinalizeTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool FinalizeTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& FinalizeTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& FinalizeTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void FinalizeTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void FinalizeTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void FinalizeTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& FinalizeTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinalizeTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* FinalizeTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& FinalizeTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void FinalizeTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void FinalizeTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& FinalizeTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinalizeTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
}
inline std::string* FinalizeTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& FinalizeTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void FinalizeTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void FinalizeTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t FinalizeTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t FinalizeTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void FinalizeTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool FinalizeTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool FinalizeTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void FinalizeTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& FinalizeTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& FinalizeTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void FinalizeTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void FinalizeTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void FinalizeTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool FinalizeTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool FinalizeTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void FinalizeTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// CancelTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool CancelTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool CancelTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& CancelTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& CancelTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void CancelTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CancelTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void CancelTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CancelTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void CancelTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& CancelTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* CancelTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& CancelTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void CancelTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void CancelTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
}

// -------------------------------------------------------------------

// TransformPropertyValue

// .Common.Float3 pos = 1;
inline bool TransformPropertyValue::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool TransformPropertyValue::has_pos() const {
  return _internal_has_pos();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_pos() const {
  const ::Common::Float3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::pos() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.pos)
  return _internal_pos();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_pos(
    ::Common::Float3* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.pos)
}
inline ::Common::Float3* TransformPropertyValue::release_pos() {
  
  ::Common::Float3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.pos)
  
  ::Common::Float3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_pos() {
  ::Common::Float3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.pos)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_pos(::Common::Float3* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.pos)
}

// .Common.Float3 rot = 2;
inline bool TransformPropertyValue::_internal_has_rot() const {
  return this != internal_default_instance() && _impl_.rot_ != nullptr;
}
inline bool TransformPropertyValue::has_rot() const {
  return _internal_has_rot();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_rot() const {
  const ::Common::Float3* p = _impl_.rot_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::rot() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.rot)
  return _internal_rot();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_rot(
    ::Common::Float3* rot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rot_);
  }
  _impl_.rot_ = rot;
  if (rot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.rot)
}
inline ::Common::Float3* TransformPropertyValue::release_rot() {
  
  ::Common::Float3* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_rot() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.rot)
  
  ::Common::Float3* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_rot() {
  
  if (_impl_.rot_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.rot_ = p;
  }
  return _impl_.rot_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_rot() {
  ::Common::Float3* _msg = _internal_mutable_rot();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.rot)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_rot(::Common::Float3* rot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rot_);
  }
  if (rot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rot));
    if (message_arena != submessage_arena) {
      rot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rot_ = rot;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.rot)
}

// .Common.Float3 scl = 3;
inline bool TransformPropertyValue::_internal_has_scl() const {
  return this != internal_default_instance() && _impl_.scl_ != nullptr;
}
inline bool TransformPropertyValue::has_scl() const {
  return _internal_has_scl();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_scl() const {
  const ::Common::Float3* p = _impl_.scl_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::scl() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.scl)
  return _internal_scl();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_scl(
    ::Common::Float3* scl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scl_);
  }
  _impl_.scl_ = scl;
  if (scl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.scl)
}
inline ::Common::Float3* TransformPropertyValue::release_scl() {
  
  ::Common::Float3* temp = _impl_.scl_;
  _impl_.scl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_scl() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.scl)
  
  ::Common::Float3* temp = _impl_.scl_;
  _impl_.scl_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_scl() {
  
  if (_impl_.scl_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.scl_ = p;
  }
  return _impl_.scl_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_scl() {
  ::Common::Float3* _msg = _internal_mutable_scl();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.scl)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_scl(::Common::Float3* scl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scl_);
  }
  if (scl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scl));
    if (message_arena != submessage_arena) {
      scl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scl_ = scl;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.scl)
}

// -------------------------------------------------------------------

// GetAudioInputDevicesReq

// int32 reqId = 1;
inline void GetAudioInputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioInputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioInputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetAudioInputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioInputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioInputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetAudioOutputDevicesReq

// int32 reqId = 1;
inline void GetAudioOutputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioOutputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioOutputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetAudioOutputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioOutputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioOutputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetVideoInputDevicesReq

// int32 reqId = 1;
inline void GetVideoInputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetVideoInputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetVideoInputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetVideoInputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetVideoInputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetVideoInputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetAudioInputDevicesResp

// int32 reqId = 1;
inline void GetAudioInputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioInputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioInputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetAudioInputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioInputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioInputDevicesResp.reqId)
}

// .ServerData.RtcAudioInputDeviceList Devices = 10;
inline bool GetAudioInputDevicesResp::_internal_has_devices() const {
  return Resp_case() == kDevices;
}
inline bool GetAudioInputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline void GetAudioInputDevicesResp::set_has_devices() {
  _impl_._oneof_case_[0] = kDevices;
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioInputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcAudioInputDeviceList* temp = _impl_.Resp_.devices_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RtcAudioInputDeviceList& GetAudioInputDevicesResp::_internal_devices() const {
  return _internal_has_devices()
      ? *_impl_.Resp_.devices_
      : reinterpret_cast< ::ServerData::RtcAudioInputDeviceList&>(::ServerData::_RtcAudioInputDeviceList_default_instance_);
}
inline const ::ServerData::RtcAudioInputDeviceList& GetAudioInputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesResp.Devices)
  return _internal_devices();
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.GetAudioInputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcAudioInputDeviceList* temp = _impl_.Resp_.devices_;
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetAudioInputDevicesResp::unsafe_arena_set_allocated_devices(::ServerData::RtcAudioInputDeviceList* devices) {
  clear_Resp();
  if (devices) {
    set_has_devices();
    _impl_.Resp_.devices_ = devices;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetAudioInputDevicesResp.Devices)
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::_internal_mutable_devices() {
  if (!_internal_has_devices()) {
    clear_Resp();
    set_has_devices();
    _impl_.Resp_.devices_ = CreateMaybeMessage< ::ServerData::RtcAudioInputDeviceList >(GetArenaForAllocation());
  }
  return _impl_.Resp_.devices_;
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::mutable_devices() {
  ::ServerData::RtcAudioInputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioInputDevicesResp.Devices)
  return _msg;
}

// string error = 11;
inline bool GetAudioInputDevicesResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool GetAudioInputDevicesResp::has_error() const {
  return _internal_has_error();
}
inline void GetAudioInputDevicesResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void GetAudioInputDevicesResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& GetAudioInputDevicesResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void GetAudioInputDevicesResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.GetAudioInputDevicesResp.error)
}
inline std::string* GetAudioInputDevicesResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioInputDevicesResp.error)
  return _s;
}
inline const std::string& GetAudioInputDevicesResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetAudioInputDevicesResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAudioInputDevicesResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetAudioInputDevicesResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioInputDevicesResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void GetAudioInputDevicesResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetAudioInputDevicesResp.error)
}

inline bool GetAudioInputDevicesResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void GetAudioInputDevicesResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline GetAudioInputDevicesResp::RespCase GetAudioInputDevicesResp::Resp_case() const {
  return GetAudioInputDevicesResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetAudioOutputDevicesResp

// int32 reqId = 1;
inline void GetAudioOutputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioOutputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioOutputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetAudioOutputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioOutputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioOutputDevicesResp.reqId)
}

// .ServerData.RtcAudioOutputDeviceList Devices = 10;
inline bool GetAudioOutputDevicesResp::_internal_has_devices() const {
  return Resp_case() == kDevices;
}
inline bool GetAudioOutputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline void GetAudioOutputDevicesResp::set_has_devices() {
  _impl_._oneof_case_[0] = kDevices;
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioOutputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcAudioOutputDeviceList* temp = _impl_.Resp_.devices_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RtcAudioOutputDeviceList& GetAudioOutputDevicesResp::_internal_devices() const {
  return _internal_has_devices()
      ? *_impl_.Resp_.devices_
      : reinterpret_cast< ::ServerData::RtcAudioOutputDeviceList&>(::ServerData::_RtcAudioOutputDeviceList_default_instance_);
}
inline const ::ServerData::RtcAudioOutputDeviceList& GetAudioOutputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesResp.Devices)
  return _internal_devices();
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.GetAudioOutputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcAudioOutputDeviceList* temp = _impl_.Resp_.devices_;
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetAudioOutputDevicesResp::unsafe_arena_set_allocated_devices(::ServerData::RtcAudioOutputDeviceList* devices) {
  clear_Resp();
  if (devices) {
    set_has_devices();
    _impl_.Resp_.devices_ = devices;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetAudioOutputDevicesResp.Devices)
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::_internal_mutable_devices() {
  if (!_internal_has_devices()) {
    clear_Resp();
    set_has_devices();
    _impl_.Resp_.devices_ = CreateMaybeMessage< ::ServerData::RtcAudioOutputDeviceList >(GetArenaForAllocation());
  }
  return _impl_.Resp_.devices_;
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::mutable_devices() {
  ::ServerData::RtcAudioOutputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioOutputDevicesResp.Devices)
  return _msg;
}

// string error = 11;
inline bool GetAudioOutputDevicesResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool GetAudioOutputDevicesResp::has_error() const {
  return _internal_has_error();
}
inline void GetAudioOutputDevicesResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void GetAudioOutputDevicesResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& GetAudioOutputDevicesResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void GetAudioOutputDevicesResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.GetAudioOutputDevicesResp.error)
}
inline std::string* GetAudioOutputDevicesResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioOutputDevicesResp.error)
  return _s;
}
inline const std::string& GetAudioOutputDevicesResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetAudioOutputDevicesResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAudioOutputDevicesResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetAudioOutputDevicesResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioOutputDevicesResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void GetAudioOutputDevicesResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetAudioOutputDevicesResp.error)
}

inline bool GetAudioOutputDevicesResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void GetAudioOutputDevicesResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline GetAudioOutputDevicesResp::RespCase GetAudioOutputDevicesResp::Resp_case() const {
  return GetAudioOutputDevicesResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetVideoInputDevicesResp

// int32 reqId = 1;
inline void GetVideoInputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetVideoInputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetVideoInputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetVideoInputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetVideoInputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetVideoInputDevicesResp.reqId)
}

// .ServerData.RtcVideoInputDeviceList Devices = 10;
inline bool GetVideoInputDevicesResp::_internal_has_devices() const {
  return Resp_case() == kDevices;
}
inline bool GetVideoInputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline void GetVideoInputDevicesResp::set_has_devices() {
  _impl_._oneof_case_[0] = kDevices;
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetVideoInputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcVideoInputDeviceList* temp = _impl_.Resp_.devices_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RtcVideoInputDeviceList& GetVideoInputDevicesResp::_internal_devices() const {
  return _internal_has_devices()
      ? *_impl_.Resp_.devices_
      : reinterpret_cast< ::ServerData::RtcVideoInputDeviceList&>(::ServerData::_RtcVideoInputDeviceList_default_instance_);
}
inline const ::ServerData::RtcVideoInputDeviceList& GetVideoInputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesResp.Devices)
  return _internal_devices();
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.GetVideoInputDevicesResp.Devices)
  if (_internal_has_devices()) {
    clear_has_Resp();
    ::ServerData::RtcVideoInputDeviceList* temp = _impl_.Resp_.devices_;
    _impl_.Resp_.devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetVideoInputDevicesResp::unsafe_arena_set_allocated_devices(::ServerData::RtcVideoInputDeviceList* devices) {
  clear_Resp();
  if (devices) {
    set_has_devices();
    _impl_.Resp_.devices_ = devices;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetVideoInputDevicesResp.Devices)
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::_internal_mutable_devices() {
  if (!_internal_has_devices()) {
    clear_Resp();
    set_has_devices();
    _impl_.Resp_.devices_ = CreateMaybeMessage< ::ServerData::RtcVideoInputDeviceList >(GetArenaForAllocation());
  }
  return _impl_.Resp_.devices_;
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::mutable_devices() {
  ::ServerData::RtcVideoInputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetVideoInputDevicesResp.Devices)
  return _msg;
}

// string error = 11;
inline bool GetVideoInputDevicesResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool GetVideoInputDevicesResp::has_error() const {
  return _internal_has_error();
}
inline void GetVideoInputDevicesResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void GetVideoInputDevicesResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& GetVideoInputDevicesResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void GetVideoInputDevicesResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.GetVideoInputDevicesResp.error)
}
inline std::string* GetVideoInputDevicesResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.GetVideoInputDevicesResp.error)
  return _s;
}
inline const std::string& GetVideoInputDevicesResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetVideoInputDevicesResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GetVideoInputDevicesResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetVideoInputDevicesResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.GetVideoInputDevicesResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void GetVideoInputDevicesResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetVideoInputDevicesResp.error)
}

inline bool GetVideoInputDevicesResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void GetVideoInputDevicesResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline GetVideoInputDevicesResp::RespCase GetVideoInputDevicesResp::Resp_case() const {
  return GetVideoInputDevicesResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetAudioInputDeviceReq

// int32 reqId = 1;
inline void SetAudioInputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetAudioInputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetAudioInputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioInputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetAudioInputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetAudioInputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetAudioInputDeviceReq.reqId)
}

// .ServerData.RtcAudioInputDevice Device = 2;
inline bool SetAudioInputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetAudioInputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcAudioInputDevice& SetAudioInputDeviceReq::_internal_device() const {
  const ::ServerData::RtcAudioInputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioInputDevice&>(
      ::ServerData::_RtcAudioInputDevice_default_instance_);
}
inline const ::ServerData::RtcAudioInputDevice& SetAudioInputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioInputDeviceReq.Device)
  return _internal_device();
}
inline void SetAudioInputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcAudioInputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetAudioInputDeviceReq.Device)
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::release_device() {
  
  ::ServerData::RtcAudioInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetAudioInputDeviceReq.Device)
  
  ::ServerData::RtcAudioInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioInputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::mutable_device() {
  ::ServerData::RtcAudioInputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetAudioInputDeviceReq.Device)
  return _msg;
}
inline void SetAudioInputDeviceReq::set_allocated_device(::ServerData::RtcAudioInputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetAudioInputDeviceReq.Device)
}

// -------------------------------------------------------------------

// SetAudioOutputDeviceReq

// int32 reqId = 1;
inline void SetAudioOutputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetAudioOutputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetAudioOutputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioOutputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetAudioOutputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetAudioOutputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetAudioOutputDeviceReq.reqId)
}

// .ServerData.RtcAudioOutputDevice Device = 2;
inline bool SetAudioOutputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetAudioOutputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcAudioOutputDevice& SetAudioOutputDeviceReq::_internal_device() const {
  const ::ServerData::RtcAudioOutputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioOutputDevice&>(
      ::ServerData::_RtcAudioOutputDevice_default_instance_);
}
inline const ::ServerData::RtcAudioOutputDevice& SetAudioOutputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioOutputDeviceReq.Device)
  return _internal_device();
}
inline void SetAudioOutputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcAudioOutputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetAudioOutputDeviceReq.Device)
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::release_device() {
  
  ::ServerData::RtcAudioOutputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetAudioOutputDeviceReq.Device)
  
  ::ServerData::RtcAudioOutputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioOutputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::mutable_device() {
  ::ServerData::RtcAudioOutputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetAudioOutputDeviceReq.Device)
  return _msg;
}
inline void SetAudioOutputDeviceReq::set_allocated_device(::ServerData::RtcAudioOutputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetAudioOutputDeviceReq.Device)
}

// -------------------------------------------------------------------

// SetVideoInputDeviceReq

// int32 reqId = 1;
inline void SetVideoInputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetVideoInputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetVideoInputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetVideoInputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetVideoInputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetVideoInputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetVideoInputDeviceReq.reqId)
}

// .ServerData.RtcVideoInputDevice Device = 2;
inline bool SetVideoInputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetVideoInputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcVideoInputDevice& SetVideoInputDeviceReq::_internal_device() const {
  const ::ServerData::RtcVideoInputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcVideoInputDevice&>(
      ::ServerData::_RtcVideoInputDevice_default_instance_);
}
inline const ::ServerData::RtcVideoInputDevice& SetVideoInputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetVideoInputDeviceReq.Device)
  return _internal_device();
}
inline void SetVideoInputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcVideoInputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetVideoInputDeviceReq.Device)
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::release_device() {
  
  ::ServerData::RtcVideoInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetVideoInputDeviceReq.Device)
  
  ::ServerData::RtcVideoInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcVideoInputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::mutable_device() {
  ::ServerData::RtcVideoInputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetVideoInputDeviceReq.Device)
  return _msg;
}
inline void SetVideoInputDeviceReq::set_allocated_device(::ServerData::RtcVideoInputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetVideoInputDeviceReq.Device)
}

// -------------------------------------------------------------------

// PostCreateObject

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostCreateObject::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostCreateObject::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostCreateObject::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostCreateObject::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.spaceConn)
  return _internal_spaceconn();
}
inline void PostCreateObject::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostCreateObject.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.spaceConn)
  return _msg;
}
inline void PostCreateObject::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.spaceConn)
}

// string newInstanceId = 2;
inline void PostCreateObject::clear_newinstanceid() {
  _impl_.newinstanceid_.ClearToEmpty();
}
inline const std::string& PostCreateObject::newinstanceid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.newInstanceId)
  return _internal_newinstanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostCreateObject::set_newinstanceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newinstanceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostCreateObject.newInstanceId)
}
inline std::string* PostCreateObject::mutable_newinstanceid() {
  std::string* _s = _internal_mutable_newinstanceid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.newInstanceId)
  return _s;
}
inline const std::string& PostCreateObject::_internal_newinstanceid() const {
  return _impl_.newinstanceid_.Get();
}
inline void PostCreateObject::_internal_set_newinstanceid(const std::string& value) {
  
  _impl_.newinstanceid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostCreateObject::_internal_mutable_newinstanceid() {
  
  return _impl_.newinstanceid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostCreateObject::release_newinstanceid() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.newInstanceId)
  return _impl_.newinstanceid_.Release();
}
inline void PostCreateObject::set_allocated_newinstanceid(std::string* newinstanceid) {
  if (newinstanceid != nullptr) {
    
  } else {
    
  }
  _impl_.newinstanceid_.SetAllocated(newinstanceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newinstanceid_.IsDefault()) {
    _impl_.newinstanceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.newInstanceId)
}

// string uniqueObjectIdent = 10;
inline void PostCreateObject::clear_uniqueobjectident() {
  _impl_.uniqueobjectident_.ClearToEmpty();
}
inline const std::string& PostCreateObject::uniqueobjectident() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.uniqueObjectIdent)
  return _internal_uniqueobjectident();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostCreateObject::set_uniqueobjectident(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueobjectident_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostCreateObject.uniqueObjectIdent)
}
inline std::string* PostCreateObject::mutable_uniqueobjectident() {
  std::string* _s = _internal_mutable_uniqueobjectident();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.uniqueObjectIdent)
  return _s;
}
inline const std::string& PostCreateObject::_internal_uniqueobjectident() const {
  return _impl_.uniqueobjectident_.Get();
}
inline void PostCreateObject::_internal_set_uniqueobjectident(const std::string& value) {
  
  _impl_.uniqueobjectident_.Set(value, GetArenaForAllocation());
}
inline std::string* PostCreateObject::_internal_mutable_uniqueobjectident() {
  
  return _impl_.uniqueobjectident_.Mutable(GetArenaForAllocation());
}
inline std::string* PostCreateObject::release_uniqueobjectident() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.uniqueObjectIdent)
  return _impl_.uniqueobjectident_.Release();
}
inline void PostCreateObject::set_allocated_uniqueobjectident(std::string* uniqueobjectident) {
  if (uniqueobjectident != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueobjectident_.SetAllocated(uniqueobjectident, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueobjectident_.IsDefault()) {
    _impl_.uniqueobjectident_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.uniqueObjectIdent)
}

// -------------------------------------------------------------------

// PostRemoveObject

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostRemoveObject::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostRemoveObject::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostRemoveObject::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostRemoveObject::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostRemoveObject.spaceConn)
  return _internal_spaceconn();
}
inline void PostRemoveObject::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostRemoveObject.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostRemoveObject.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostRemoveObject.spaceConn)
  return _msg;
}
inline void PostRemoveObject::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostRemoveObject.spaceConn)
}

// string containerId = 2;
inline void PostRemoveObject::clear_containerid() {
  _impl_.containerid_.ClearToEmpty();
}
inline const std::string& PostRemoveObject::containerid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostRemoveObject.containerId)
  return _internal_containerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostRemoveObject::set_containerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.containerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostRemoveObject.containerId)
}
inline std::string* PostRemoveObject::mutable_containerid() {
  std::string* _s = _internal_mutable_containerid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostRemoveObject.containerId)
  return _s;
}
inline const std::string& PostRemoveObject::_internal_containerid() const {
  return _impl_.containerid_.Get();
}
inline void PostRemoveObject::_internal_set_containerid(const std::string& value) {
  
  _impl_.containerid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostRemoveObject::_internal_mutable_containerid() {
  
  return _impl_.containerid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostRemoveObject::release_containerid() {
  // @@protoc_insertion_point(field_release:ServerData.PostRemoveObject.containerId)
  return _impl_.containerid_.Release();
}
inline void PostRemoveObject::set_allocated_containerid(std::string* containerid) {
  if (containerid != nullptr) {
    
  } else {
    
  }
  _impl_.containerid_.SetAllocated(containerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.containerid_.IsDefault()) {
    _impl_.containerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostRemoveObject.containerId)
}

// -------------------------------------------------------------------

// FetchFileByIdReq

// string contentId = 1;
inline void FetchFileByIdReq::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdReq::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdReq.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdReq::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdReq.contentId)
}
inline std::string* FetchFileByIdReq::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdReq.contentId)
  return _s;
}
inline const std::string& FetchFileByIdReq::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdReq::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdReq::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdReq::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdReq.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdReq::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdReq.contentId)
}

// -------------------------------------------------------------------

// FetchFileByIdProgressResp

// string contentId = 1;
inline void FetchFileByIdProgressResp::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdProgressResp::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdProgressResp::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.contentId)
}
inline std::string* FetchFileByIdProgressResp::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdProgressResp.contentId)
  return _s;
}
inline const std::string& FetchFileByIdProgressResp::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdProgressResp::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdProgressResp.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdProgressResp::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdProgressResp.contentId)
}

// float progress = 10;
inline void FetchFileByIdProgressResp::clear_progress() {
  _impl_.progress_ = 0;
}
inline float FetchFileByIdProgressResp::_internal_progress() const {
  return _impl_.progress_;
}
inline float FetchFileByIdProgressResp::progress() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.progress)
  return _internal_progress();
}
inline void FetchFileByIdProgressResp::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void FetchFileByIdProgressResp::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.progress)
}

// string progressStep = 11;
inline void FetchFileByIdProgressResp::clear_progressstep() {
  _impl_.progressstep_.ClearToEmpty();
}
inline const std::string& FetchFileByIdProgressResp::progressstep() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.progressStep)
  return _internal_progressstep();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdProgressResp::set_progressstep(ArgT0&& arg0, ArgT... args) {
 
 _impl_.progressstep_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.progressStep)
}
inline std::string* FetchFileByIdProgressResp::mutable_progressstep() {
  std::string* _s = _internal_mutable_progressstep();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdProgressResp.progressStep)
  return _s;
}
inline const std::string& FetchFileByIdProgressResp::_internal_progressstep() const {
  return _impl_.progressstep_.Get();
}
inline void FetchFileByIdProgressResp::_internal_set_progressstep(const std::string& value) {
  
  _impl_.progressstep_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::_internal_mutable_progressstep() {
  
  return _impl_.progressstep_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::release_progressstep() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdProgressResp.progressStep)
  return _impl_.progressstep_.Release();
}
inline void FetchFileByIdProgressResp::set_allocated_progressstep(std::string* progressstep) {
  if (progressstep != nullptr) {
    
  } else {
    
  }
  _impl_.progressstep_.SetAllocated(progressstep, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.progressstep_.IsDefault()) {
    _impl_.progressstep_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdProgressResp.progressStep)
}

// -------------------------------------------------------------------

// FetchFileByIdCompletedResp

// string contentId = 1;
inline void FetchFileByIdCompletedResp::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.contentId)
}
inline std::string* FetchFileByIdCompletedResp::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.contentId)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.contentId)
}

// string filePath = 10;
inline void FetchFileByIdCompletedResp::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::filepath() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.filePath)
}
inline std::string* FetchFileByIdCompletedResp::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.filePath)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_filepath() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.filePath)
  return _impl_.filepath_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.filePath)
}

// string finalFileNameWithExtension = 11;
inline void FetchFileByIdCompletedResp::clear_finalfilenamewithextension() {
  _impl_.finalfilenamewithextension_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::finalfilenamewithextension() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _internal_finalfilenamewithextension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_finalfilenamewithextension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finalfilenamewithextension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
}
inline std::string* FetchFileByIdCompletedResp::mutable_finalfilenamewithextension() {
  std::string* _s = _internal_mutable_finalfilenamewithextension();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_finalfilenamewithextension() const {
  return _impl_.finalfilenamewithextension_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_finalfilenamewithextension(const std::string& value) {
  
  _impl_.finalfilenamewithextension_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_finalfilenamewithextension() {
  
  return _impl_.finalfilenamewithextension_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_finalfilenamewithextension() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _impl_.finalfilenamewithextension_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_finalfilenamewithextension(std::string* finalfilenamewithextension) {
  if (finalfilenamewithextension != nullptr) {
    
  } else {
    
  }
  _impl_.finalfilenamewithextension_.SetAllocated(finalfilenamewithextension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finalfilenamewithextension_.IsDefault()) {
    _impl_.finalfilenamewithextension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
}

// -------------------------------------------------------------------

// FetchAllUploadedContentReq

// int32 reqId = 1;
inline void FetchAllUploadedContentReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUploadedContentReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUploadedContentReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentReq.reqId)
  return _internal_reqid();
}
inline void FetchAllUploadedContentReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUploadedContentReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUploadedContentReq.reqId)
}

// -------------------------------------------------------------------

// UploadLocalFileResp

// int32 reqId = 1;
inline void UploadLocalFileResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UploadLocalFileResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UploadLocalFileResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileResp.reqId)
  return _internal_reqid();
}
inline void UploadLocalFileResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UploadLocalFileResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileResp.reqId)
}

// .ServerData.CavrnusRemoteContent uploadedContent = 10;
inline bool UploadLocalFileResp::_internal_has_uploadedcontent() const {
  return this != internal_default_instance() && _impl_.uploadedcontent_ != nullptr;
}
inline bool UploadLocalFileResp::has_uploadedcontent() const {
  return _internal_has_uploadedcontent();
}
inline const ::ServerData::CavrnusRemoteContent& UploadLocalFileResp::_internal_uploadedcontent() const {
  const ::ServerData::CavrnusRemoteContent* p = _impl_.uploadedcontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusRemoteContent&>(
      ::ServerData::_CavrnusRemoteContent_default_instance_);
}
inline const ::ServerData::CavrnusRemoteContent& UploadLocalFileResp::uploadedcontent() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileResp.uploadedContent)
  return _internal_uploadedcontent();
}
inline void UploadLocalFileResp::unsafe_arena_set_allocated_uploadedcontent(
    ::ServerData::CavrnusRemoteContent* uploadedcontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  if (uploadedcontent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UploadLocalFileResp.uploadedContent)
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::release_uploadedcontent() {
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::unsafe_arena_release_uploadedcontent() {
  // @@protoc_insertion_point(field_release:ServerData.UploadLocalFileResp.uploadedContent)
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::_internal_mutable_uploadedcontent() {
  
  if (_impl_.uploadedcontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(GetArenaForAllocation());
    _impl_.uploadedcontent_ = p;
  }
  return _impl_.uploadedcontent_;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::mutable_uploadedcontent() {
  ::ServerData::CavrnusRemoteContent* _msg = _internal_mutable_uploadedcontent();
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileResp.uploadedContent)
  return _msg;
}
inline void UploadLocalFileResp::set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  if (uploadedcontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploadedcontent));
    if (message_arena != submessage_arena) {
      uploadedcontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploadedcontent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UploadLocalFileResp.uploadedContent)
}

// -------------------------------------------------------------------

// UploadLocalFileReq

// int32 reqId = 1;
inline void UploadLocalFileReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UploadLocalFileReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UploadLocalFileReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.reqId)
  return _internal_reqid();
}
inline void UploadLocalFileReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UploadLocalFileReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.reqId)
}

// string filePath = 10;
inline void UploadLocalFileReq::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& UploadLocalFileReq::filepath() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadLocalFileReq::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.filePath)
}
inline std::string* UploadLocalFileReq::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.filePath)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void UploadLocalFileReq::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadLocalFileReq::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadLocalFileReq::release_filepath() {
  // @@protoc_insertion_point(field_release:ServerData.UploadLocalFileReq.filePath)
  return _impl_.filepath_.Release();
}
inline void UploadLocalFileReq::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UploadLocalFileReq.filePath)
}

// repeated string tagKeys = 11;
inline int UploadLocalFileReq::_internal_tagkeys_size() const {
  return _impl_.tagkeys_.size();
}
inline int UploadLocalFileReq::tagkeys_size() const {
  return _internal_tagkeys_size();
}
inline void UploadLocalFileReq::clear_tagkeys() {
  _impl_.tagkeys_.Clear();
}
inline std::string* UploadLocalFileReq::add_tagkeys() {
  std::string* _s = _internal_add_tagkeys();
  // @@protoc_insertion_point(field_add_mutable:ServerData.UploadLocalFileReq.tagKeys)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_tagkeys(int index) const {
  return _impl_.tagkeys_.Get(index);
}
inline const std::string& UploadLocalFileReq::tagkeys(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.tagKeys)
  return _internal_tagkeys(index);
}
inline std::string* UploadLocalFileReq::mutable_tagkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.tagKeys)
  return _impl_.tagkeys_.Mutable(index);
}
inline void UploadLocalFileReq::set_tagkeys(int index, const std::string& value) {
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, std::string&& value) {
  _impl_.tagkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, const char* value, size_t size) {
  _impl_.tagkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.UploadLocalFileReq.tagKeys)
}
inline std::string* UploadLocalFileReq::_internal_add_tagkeys() {
  return _impl_.tagkeys_.Add();
}
inline void UploadLocalFileReq::add_tagkeys(const std::string& value) {
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(std::string&& value) {
  _impl_.tagkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(const char* value, size_t size) {
  _impl_.tagkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.UploadLocalFileReq.tagKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadLocalFileReq::tagkeys() const {
  // @@protoc_insertion_point(field_list:ServerData.UploadLocalFileReq.tagKeys)
  return _impl_.tagkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadLocalFileReq::mutable_tagkeys() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.UploadLocalFileReq.tagKeys)
  return &_impl_.tagkeys_;
}

// repeated string tagValues = 12;
inline int UploadLocalFileReq::_internal_tagvalues_size() const {
  return _impl_.tagvalues_.size();
}
inline int UploadLocalFileReq::tagvalues_size() const {
  return _internal_tagvalues_size();
}
inline void UploadLocalFileReq::clear_tagvalues() {
  _impl_.tagvalues_.Clear();
}
inline std::string* UploadLocalFileReq::add_tagvalues() {
  std::string* _s = _internal_add_tagvalues();
  // @@protoc_insertion_point(field_add_mutable:ServerData.UploadLocalFileReq.tagValues)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_tagvalues(int index) const {
  return _impl_.tagvalues_.Get(index);
}
inline const std::string& UploadLocalFileReq::tagvalues(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.tagValues)
  return _internal_tagvalues(index);
}
inline std::string* UploadLocalFileReq::mutable_tagvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.tagValues)
  return _impl_.tagvalues_.Mutable(index);
}
inline void UploadLocalFileReq::set_tagvalues(int index, const std::string& value) {
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, std::string&& value) {
  _impl_.tagvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, const char* value, size_t size) {
  _impl_.tagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.UploadLocalFileReq.tagValues)
}
inline std::string* UploadLocalFileReq::_internal_add_tagvalues() {
  return _impl_.tagvalues_.Add();
}
inline void UploadLocalFileReq::add_tagvalues(const std::string& value) {
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(std::string&& value) {
  _impl_.tagvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(const char* value, size_t size) {
  _impl_.tagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.UploadLocalFileReq.tagValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadLocalFileReq::tagvalues() const {
  // @@protoc_insertion_point(field_list:ServerData.UploadLocalFileReq.tagValues)
  return _impl_.tagvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadLocalFileReq::mutable_tagvalues() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.UploadLocalFileReq.tagValues)
  return &_impl_.tagvalues_;
}

// -------------------------------------------------------------------

// FetchAllUploadedContentResp

// int32 reqId = 1;
inline void FetchAllUploadedContentResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUploadedContentResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUploadedContentResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentResp.reqId)
  return _internal_reqid();
}
inline void FetchAllUploadedContentResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUploadedContentResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUploadedContentResp.reqId)
}

// repeated .ServerData.CavrnusRemoteContent availableContent = 10;
inline int FetchAllUploadedContentResp::_internal_availablecontent_size() const {
  return _impl_.availablecontent_.size();
}
inline int FetchAllUploadedContentResp::availablecontent_size() const {
  return _internal_availablecontent_size();
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::mutable_availablecontent(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.FetchAllUploadedContentResp.availableContent)
  return _impl_.availablecontent_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >*
FetchAllUploadedContentResp::mutable_availablecontent() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.FetchAllUploadedContentResp.availableContent)
  return &_impl_.availablecontent_;
}
inline const ::ServerData::CavrnusRemoteContent& FetchAllUploadedContentResp::_internal_availablecontent(int index) const {
  return _impl_.availablecontent_.Get(index);
}
inline const ::ServerData::CavrnusRemoteContent& FetchAllUploadedContentResp::availablecontent(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentResp.availableContent)
  return _internal_availablecontent(index);
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::_internal_add_availablecontent() {
  return _impl_.availablecontent_.Add();
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::add_availablecontent() {
  ::ServerData::CavrnusRemoteContent* _add = _internal_add_availablecontent();
  // @@protoc_insertion_point(field_add:ServerData.FetchAllUploadedContentResp.availableContent)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >&
FetchAllUploadedContentResp::availablecontent() const {
  // @@protoc_insertion_point(field_list:ServerData.FetchAllUploadedContentResp.availableContent)
  return _impl_.availablecontent_;
}

// -------------------------------------------------------------------

// PropMetadataStatus

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PropMetadataStatus::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PropMetadataStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PropMetadataStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PropMetadataStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PropMetadataStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropMetadataStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PropMetadataStatus.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PropMetadataStatus.spaceConn)
  return _msg;
}
inline void PropMetadataStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropMetadataStatus.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool PropMetadataStatus::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool PropMetadataStatus::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& PropMetadataStatus::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropMetadataStatus::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.propertyPath)
  return _internal_propertypath();
}
inline void PropMetadataStatus::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropMetadataStatus.propertyPath)
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.PropMetadataStatus.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.PropMetadataStatus.propertyPath)
  return _msg;
}
inline void PropMetadataStatus::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropMetadataStatus.propertyPath)
}

// bool isReadonly = 10;
inline void PropMetadataStatus::clear_isreadonly() {
  _impl_.isreadonly_ = false;
}
inline bool PropMetadataStatus::_internal_isreadonly() const {
  return _impl_.isreadonly_;
}
inline bool PropMetadataStatus::isreadonly() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.isReadonly)
  return _internal_isreadonly();
}
inline void PropMetadataStatus::_internal_set_isreadonly(bool value) {
  
  _impl_.isreadonly_ = value;
}
inline void PropMetadataStatus::set_isreadonly(bool value) {
  _internal_set_isreadonly(value);
  // @@protoc_insertion_point(field_set:ServerData.PropMetadataStatus.isReadonly)
}

// -------------------------------------------------------------------

// PropertyValueStatus

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PropertyValueStatus::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PropertyValueStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PropertyValueStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PropertyValueStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.spaceConn)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool PropertyValueStatus::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool PropertyValueStatus::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& PropertyValueStatus::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropertyValueStatus::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.propertyPath)
  return _internal_propertypath();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.propertyPath)
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.propertyPath)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.propertyPath)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool PropertyValueStatus::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool PropertyValueStatus::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void PropertyValueStatus::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& PropertyValueStatus::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& PropertyValueStatus::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.PropertyValue)
  return _internal_propertyvalue();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.PropertyValue)
}
inline ::ServerData::PropertyValue* PropertyValueStatus::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.PropertyValue)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.PropertyValue)
}

// int32 priority = 11;
inline void PropertyValueStatus::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t PropertyValueStatus::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t PropertyValueStatus::priority() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.priority)
  return _internal_priority();
}
inline void PropertyValueStatus::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void PropertyValueStatus::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValueStatus.priority)
}

// -------------------------------------------------------------------

// LocalPropertyHandledResp

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool LocalPropertyHandledResp::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool LocalPropertyHandledResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& LocalPropertyHandledResp::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& LocalPropertyHandledResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.spaceConn)
  return _internal_spaceconn();
}
inline void LocalPropertyHandledResp::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.LocalPropertyHandledResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.LocalPropertyHandledResp.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.LocalPropertyHandledResp.spaceConn)
  return _msg;
}
inline void LocalPropertyHandledResp::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.LocalPropertyHandledResp.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool LocalPropertyHandledResp::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool LocalPropertyHandledResp::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& LocalPropertyHandledResp::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& LocalPropertyHandledResp::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.propertyPath)
  return _internal_propertypath();
}
inline void LocalPropertyHandledResp::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.LocalPropertyHandledResp.propertyPath)
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.LocalPropertyHandledResp.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.LocalPropertyHandledResp.propertyPath)
  return _msg;
}
inline void LocalPropertyHandledResp::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.LocalPropertyHandledResp.propertyPath)
}

// int32 localPropChangeId = 10;
inline void LocalPropertyHandledResp::clear_localpropchangeid() {
  _impl_.localpropchangeid_ = 0;
}
inline int32_t LocalPropertyHandledResp::_internal_localpropchangeid() const {
  return _impl_.localpropchangeid_;
}
inline int32_t LocalPropertyHandledResp::localpropchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.localPropChangeId)
  return _internal_localpropchangeid();
}
inline void LocalPropertyHandledResp::_internal_set_localpropchangeid(int32_t value) {
  
  _impl_.localpropchangeid_ = value;
}
inline void LocalPropertyHandledResp::set_localpropchangeid(int32_t value) {
  _internal_set_localpropchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.LocalPropertyHandledResp.localPropChangeId)
}

// -------------------------------------------------------------------

// UserAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserAdded.spaceConn)
  return _internal_spaceconn();
}
inline void UserAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserAdded.spaceConn)
  return _msg;
}
inline void UserAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserAdded.spaceConn)
}

// .ServerData.CavrnusUser user = 2;
inline bool UserAdded::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserAdded::has_user() const {
  return _internal_has_user();
}
inline const ::ServerData::CavrnusUser& UserAdded::_internal_user() const {
  const ::ServerData::CavrnusUser* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusUser&>(
      ::ServerData::_CavrnusUser_default_instance_);
}
inline const ::ServerData::CavrnusUser& UserAdded::user() const {
  // @@protoc_insertion_point(field_get:ServerData.UserAdded.user)
  return _internal_user();
}
inline void UserAdded::unsafe_arena_set_allocated_user(
    ::ServerData::CavrnusUser* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserAdded.user)
}
inline ::ServerData::CavrnusUser* UserAdded::release_user() {
  
  ::ServerData::CavrnusUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusUser* UserAdded::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ServerData.UserAdded.user)
  
  ::ServerData::CavrnusUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusUser* UserAdded::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusUser>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ServerData::CavrnusUser* UserAdded::mutable_user() {
  ::ServerData::CavrnusUser* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ServerData.UserAdded.user)
  return _msg;
}
inline void UserAdded::set_allocated_user(::ServerData::CavrnusUser* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserAdded.user)
}

// -------------------------------------------------------------------

// UserRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void UserRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserRemoved.spaceConn)
  return _msg;
}
inline void UserRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserRemoved.spaceConn)
}

// string userId = 2;
inline void UserRemoved::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserRemoved::userid() const {
  // @@protoc_insertion_point(field_get:ServerData.UserRemoved.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRemoved::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserRemoved.userId)
}
inline std::string* UserRemoved::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerData.UserRemoved.userId)
  return _s;
}
inline const std::string& UserRemoved::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserRemoved::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRemoved::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRemoved::release_userid() {
  // @@protoc_insertion_point(field_release:ServerData.UserRemoved.userId)
  return _impl_.userid_.Release();
}
inline void UserRemoved::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserRemoved.userId)
}

// -------------------------------------------------------------------

// UserVideoFrame

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserVideoFrame::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserVideoFrame::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserVideoFrame::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserVideoFrame::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.spaceConn)
  return _internal_spaceconn();
}
inline void UserVideoFrame::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserVideoFrame.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.spaceConn)
  return _msg;
}
inline void UserVideoFrame::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.spaceConn)
}

// string userId = 2;
inline void UserVideoFrame::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserVideoFrame::userid() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserVideoFrame::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.userId)
}
inline std::string* UserVideoFrame::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.userId)
  return _s;
}
inline const std::string& UserVideoFrame::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserVideoFrame::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserVideoFrame::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserVideoFrame::release_userid() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.userId)
  return _impl_.userid_.Release();
}
inline void UserVideoFrame::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.userId)
}

// int32 resX = 10;
inline void UserVideoFrame::clear_resx() {
  _impl_.resx_ = 0;
}
inline int32_t UserVideoFrame::_internal_resx() const {
  return _impl_.resx_;
}
inline int32_t UserVideoFrame::resx() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.resX)
  return _internal_resx();
}
inline void UserVideoFrame::_internal_set_resx(int32_t value) {
  
  _impl_.resx_ = value;
}
inline void UserVideoFrame::set_resx(int32_t value) {
  _internal_set_resx(value);
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.resX)
}

// int32 resY = 11;
inline void UserVideoFrame::clear_resy() {
  _impl_.resy_ = 0;
}
inline int32_t UserVideoFrame::_internal_resy() const {
  return _impl_.resy_;
}
inline int32_t UserVideoFrame::resy() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.resY)
  return _internal_resy();
}
inline void UserVideoFrame::_internal_set_resy(int32_t value) {
  
  _impl_.resy_ = value;
}
inline void UserVideoFrame::set_resy(int32_t value) {
  _internal_set_resy(value);
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.resY)
}

// bytes stream = 20;
inline void UserVideoFrame::clear_stream() {
  _impl_.stream_.ClearToEmpty();
}
inline const std::string& UserVideoFrame::stream() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserVideoFrame::set_stream(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.stream)
}
inline std::string* UserVideoFrame::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.stream)
  return _s;
}
inline const std::string& UserVideoFrame::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void UserVideoFrame::_internal_set_stream(const std::string& value) {
  
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* UserVideoFrame::_internal_mutable_stream() {
  
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* UserVideoFrame::release_stream() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.stream)
  return _impl_.stream_.Release();
}
inline void UserVideoFrame::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.stream)
}

// -------------------------------------------------------------------

// SpaceInfo

// string spaceId = 1;
inline void SpaceInfo::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceId)
}
inline std::string* SpaceInfo::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceId)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void SpaceInfo::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceId)
  return _impl_.spaceid_.Release();
}
inline void SpaceInfo::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceId)
}

// string spaceName = 2;
inline void SpaceInfo::clear_spacename() {
  _impl_.spacename_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spacename() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceName)
  return _internal_spacename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spacename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spacename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceName)
}
inline std::string* SpaceInfo::mutable_spacename() {
  std::string* _s = _internal_mutable_spacename();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceName)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spacename() const {
  return _impl_.spacename_.Get();
}
inline void SpaceInfo::_internal_set_spacename(const std::string& value) {
  
  _impl_.spacename_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spacename() {
  
  return _impl_.spacename_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spacename() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceName)
  return _impl_.spacename_.Release();
}
inline void SpaceInfo::set_allocated_spacename(std::string* spacename) {
  if (spacename != nullptr) {
    
  } else {
    
  }
  _impl_.spacename_.SetAllocated(spacename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spacename_.IsDefault()) {
    _impl_.spacename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceName)
}

// string spaceThumbnailUrl = 3;
inline void SpaceInfo::clear_spacethumbnailurl() {
  _impl_.spacethumbnailurl_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spacethumbnailurl() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _internal_spacethumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spacethumbnailurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spacethumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceThumbnailUrl)
}
inline std::string* SpaceInfo::mutable_spacethumbnailurl() {
  std::string* _s = _internal_mutable_spacethumbnailurl();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spacethumbnailurl() const {
  return _impl_.spacethumbnailurl_.Get();
}
inline void SpaceInfo::_internal_set_spacethumbnailurl(const std::string& value) {
  
  _impl_.spacethumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spacethumbnailurl() {
  
  return _impl_.spacethumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spacethumbnailurl() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _impl_.spacethumbnailurl_.Release();
}
inline void SpaceInfo::set_allocated_spacethumbnailurl(std::string* spacethumbnailurl) {
  if (spacethumbnailurl != nullptr) {
    
  } else {
    
  }
  _impl_.spacethumbnailurl_.SetAllocated(spacethumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spacethumbnailurl_.IsDefault()) {
    _impl_.spacethumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceThumbnailUrl)
}

// bool archived = 4;
inline void SpaceInfo::clear_archived() {
  _impl_.archived_ = false;
}
inline bool SpaceInfo::_internal_archived() const {
  return _impl_.archived_;
}
inline bool SpaceInfo::archived() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.archived)
  return _internal_archived();
}
inline void SpaceInfo::_internal_set_archived(bool value) {
  
  _impl_.archived_ = value;
}
inline void SpaceInfo::set_archived(bool value) {
  _internal_set_archived(value);
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.archived)
}

// .google.protobuf.Timestamp lastAccess = 5;
inline bool SpaceInfo::_internal_has_lastaccess() const {
  return this != internal_default_instance() && _impl_.lastaccess_ != nullptr;
}
inline bool SpaceInfo::has_lastaccess() const {
  return _internal_has_lastaccess();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpaceInfo::_internal_lastaccess() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.lastaccess_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpaceInfo::lastaccess() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.lastAccess)
  return _internal_lastaccess();
}
inline void SpaceInfo::unsafe_arena_set_allocated_lastaccess(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastaccess_);
  }
  _impl_.lastaccess_ = lastaccess;
  if (lastaccess) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SpaceInfo.lastAccess)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::release_lastaccess() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.lastaccess_;
  _impl_.lastaccess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::unsafe_arena_release_lastaccess() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.lastAccess)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.lastaccess_;
  _impl_.lastaccess_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::_internal_mutable_lastaccess() {
  
  if (_impl_.lastaccess_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.lastaccess_ = p;
  }
  return _impl_.lastaccess_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::mutable_lastaccess() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_lastaccess();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.lastAccess)
  return _msg;
}
inline void SpaceInfo::set_allocated_lastaccess(::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastaccess_);
  }
  if (lastaccess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lastaccess));
    if (message_arena != submessage_arena) {
      lastaccess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lastaccess, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lastaccess_ = lastaccess;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.lastAccess)
}

// -------------------------------------------------------------------

// ObjectAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ObjectAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ObjectAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.spaceConn)
  return _internal_spaceconn();
}
inline void ObjectAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.spaceConn)
  return _msg;
}
inline void ObjectAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.spaceConn)
}

// string propertiesContainer = 3;
inline void ObjectAdded::clear_propertiescontainer() {
  _impl_.propertiescontainer_.ClearToEmpty();
}
inline const std::string& ObjectAdded::propertiescontainer() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.propertiesContainer)
  return _internal_propertiescontainer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectAdded::set_propertiescontainer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertiescontainer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectAdded.propertiesContainer)
}
inline std::string* ObjectAdded::mutable_propertiescontainer() {
  std::string* _s = _internal_mutable_propertiescontainer();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.propertiesContainer)
  return _s;
}
inline const std::string& ObjectAdded::_internal_propertiescontainer() const {
  return _impl_.propertiescontainer_.Get();
}
inline void ObjectAdded::_internal_set_propertiescontainer(const std::string& value) {
  
  _impl_.propertiescontainer_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectAdded::_internal_mutable_propertiescontainer() {
  
  return _impl_.propertiescontainer_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectAdded::release_propertiescontainer() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.propertiesContainer)
  return _impl_.propertiescontainer_.Release();
}
inline void ObjectAdded::set_allocated_propertiescontainer(std::string* propertiescontainer) {
  if (propertiescontainer != nullptr) {
    
  } else {
    
  }
  _impl_.propertiescontainer_.SetAllocated(propertiescontainer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertiescontainer_.IsDefault()) {
    _impl_.propertiescontainer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.propertiesContainer)
}

// string objectCreated = 4;
inline void ObjectAdded::clear_objectcreated() {
  _impl_.objectcreated_.ClearToEmpty();
}
inline const std::string& ObjectAdded::objectcreated() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.objectCreated)
  return _internal_objectcreated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectAdded::set_objectcreated(ArgT0&& arg0, ArgT... args) {
 
 _impl_.objectcreated_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectAdded.objectCreated)
}
inline std::string* ObjectAdded::mutable_objectcreated() {
  std::string* _s = _internal_mutable_objectcreated();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.objectCreated)
  return _s;
}
inline const std::string& ObjectAdded::_internal_objectcreated() const {
  return _impl_.objectcreated_.Get();
}
inline void ObjectAdded::_internal_set_objectcreated(const std::string& value) {
  
  _impl_.objectcreated_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectAdded::_internal_mutable_objectcreated() {
  
  return _impl_.objectcreated_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectAdded::release_objectcreated() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.objectCreated)
  return _impl_.objectcreated_.Release();
}
inline void ObjectAdded::set_allocated_objectcreated(std::string* objectcreated) {
  if (objectcreated != nullptr) {
    
  } else {
    
  }
  _impl_.objectcreated_.SetAllocated(objectcreated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.objectcreated_.IsDefault()) {
    _impl_.objectcreated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.objectCreated)
}

// .google.protobuf.Timestamp createdTime = 5;
inline bool ObjectAdded::_internal_has_createdtime() const {
  return this != internal_default_instance() && _impl_.createdtime_ != nullptr;
}
inline bool ObjectAdded::has_createdtime() const {
  return _internal_has_createdtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectAdded::_internal_createdtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.createdtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectAdded::createdtime() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.createdTime)
  return _internal_createdtime();
}
inline void ObjectAdded::unsafe_arena_set_allocated_createdtime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  _impl_.createdtime_ = createdtime;
  if (createdtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectAdded.createdTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::release_createdtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::unsafe_arena_release_createdtime() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.createdTime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::_internal_mutable_createdtime() {
  
  if (_impl_.createdtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.createdtime_ = p;
  }
  return _impl_.createdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::mutable_createdtime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdtime();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.createdTime)
  return _msg;
}
inline void ObjectAdded::set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  if (createdtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdtime));
    if (message_arena != submessage_arena) {
      createdtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createdtime_ = createdtime;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.createdTime)
}

// -------------------------------------------------------------------

// ObjectRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ObjectRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ObjectRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void ObjectRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectRemoved.spaceConn)
  return _msg;
}
inline void ObjectRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectRemoved.spaceConn)
}

// string propertiesContainer = 3;
inline void ObjectRemoved::clear_propertiescontainer() {
  _impl_.propertiescontainer_.ClearToEmpty();
}
inline const std::string& ObjectRemoved::propertiescontainer() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectRemoved.propertiesContainer)
  return _internal_propertiescontainer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRemoved::set_propertiescontainer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertiescontainer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectRemoved.propertiesContainer)
}
inline std::string* ObjectRemoved::mutable_propertiescontainer() {
  std::string* _s = _internal_mutable_propertiescontainer();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectRemoved.propertiesContainer)
  return _s;
}
inline const std::string& ObjectRemoved::_internal_propertiescontainer() const {
  return _impl_.propertiescontainer_.Get();
}
inline void ObjectRemoved::_internal_set_propertiescontainer(const std::string& value) {
  
  _impl_.propertiescontainer_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectRemoved::_internal_mutable_propertiescontainer() {
  
  return _impl_.propertiescontainer_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectRemoved::release_propertiescontainer() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectRemoved.propertiesContainer)
  return _impl_.propertiescontainer_.Release();
}
inline void ObjectRemoved::set_allocated_propertiescontainer(std::string* propertiescontainer) {
  if (propertiescontainer != nullptr) {
    
  } else {
    
  }
  _impl_.propertiescontainer_.SetAllocated(propertiescontainer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertiescontainer_.IsDefault()) {
    _impl_.propertiescontainer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectRemoved.propertiesContainer)
}

// -------------------------------------------------------------------

// UpdateLocalUserMuted

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserMuted::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserMuted::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserMuted::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserMuted::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserMuted.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserMuted::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserMuted.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserMuted.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserMuted.spaceConn)
  return _msg;
}
inline void UpdateLocalUserMuted::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserMuted.spaceConn)
}

// bool muted = 2;
inline void UpdateLocalUserMuted::clear_muted() {
  _impl_.muted_ = false;
}
inline bool UpdateLocalUserMuted::_internal_muted() const {
  return _impl_.muted_;
}
inline bool UpdateLocalUserMuted::muted() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserMuted.muted)
  return _internal_muted();
}
inline void UpdateLocalUserMuted::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void UpdateLocalUserMuted::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateLocalUserMuted.muted)
}

// -------------------------------------------------------------------

// UpdateLocalUserCoPresence

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserCoPresence::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserCoPresence::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserCoPresence::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserCoPresence::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserCoPresence.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserCoPresence::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserCoPresence.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserCoPresence.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserCoPresence.spaceConn)
  return _msg;
}
inline void UpdateLocalUserCoPresence::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserCoPresence.spaceConn)
}

// .ServerData.TransformPropertyValue localUserRootTransform = 10;
inline bool UpdateLocalUserCoPresence::_internal_has_localuserroottransform() const {
  return this != internal_default_instance() && _impl_.localuserroottransform_ != nullptr;
}
inline bool UpdateLocalUserCoPresence::has_localuserroottransform() const {
  return _internal_has_localuserroottransform();
}
inline void UpdateLocalUserCoPresence::clear_localuserroottransform() {
  if (GetArenaForAllocation() == nullptr && _impl_.localuserroottransform_ != nullptr) {
    delete _impl_.localuserroottransform_;
  }
  _impl_.localuserroottransform_ = nullptr;
}
inline const ::ServerData::TransformPropertyValue& UpdateLocalUserCoPresence::_internal_localuserroottransform() const {
  const ::ServerData::TransformPropertyValue* p = _impl_.localuserroottransform_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::TransformPropertyValue&>(
      ::ServerData::_TransformPropertyValue_default_instance_);
}
inline const ::ServerData::TransformPropertyValue& UpdateLocalUserCoPresence::localuserroottransform() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  return _internal_localuserroottransform();
}
inline void UpdateLocalUserCoPresence::unsafe_arena_set_allocated_localuserroottransform(
    ::ServerData::TransformPropertyValue* localuserroottransform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localuserroottransform_);
  }
  _impl_.localuserroottransform_ = localuserroottransform;
  if (localuserroottransform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::release_localuserroottransform() {
  
  ::ServerData::TransformPropertyValue* temp = _impl_.localuserroottransform_;
  _impl_.localuserroottransform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::unsafe_arena_release_localuserroottransform() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  
  ::ServerData::TransformPropertyValue* temp = _impl_.localuserroottransform_;
  _impl_.localuserroottransform_ = nullptr;
  return temp;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::_internal_mutable_localuserroottransform() {
  
  if (_impl_.localuserroottransform_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::TransformPropertyValue>(GetArenaForAllocation());
    _impl_.localuserroottransform_ = p;
  }
  return _impl_.localuserroottransform_;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::mutable_localuserroottransform() {
  ::ServerData::TransformPropertyValue* _msg = _internal_mutable_localuserroottransform();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  return _msg;
}
inline void UpdateLocalUserCoPresence::set_allocated_localuserroottransform(::ServerData::TransformPropertyValue* localuserroottransform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.localuserroottransform_;
  }
  if (localuserroottransform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(localuserroottransform);
    if (message_arena != submessage_arena) {
      localuserroottransform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localuserroottransform, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localuserroottransform_ = localuserroottransform;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
}

// -------------------------------------------------------------------

// UpdateLocalUserStreamState

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserStreamState::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserStreamState::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserStreamState::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserStreamState::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserStreamState.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserStreamState::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserStreamState.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserStreamState.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserStreamState.spaceConn)
  return _msg;
}
inline void UpdateLocalUserStreamState::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserStreamState.spaceConn)
}

// bool streaming = 2;
inline void UpdateLocalUserStreamState::clear_streaming() {
  _impl_.streaming_ = false;
}
inline bool UpdateLocalUserStreamState::_internal_streaming() const {
  return _impl_.streaming_;
}
inline bool UpdateLocalUserStreamState::streaming() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserStreamState.streaming)
  return _internal_streaming();
}
inline void UpdateLocalUserStreamState::_internal_set_streaming(bool value) {
  
  _impl_.streaming_ = value;
}
inline void UpdateLocalUserStreamState::set_streaming(bool value) {
  _internal_set_streaming(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateLocalUserStreamState.streaming)
}

// -------------------------------------------------------------------

// PermissionStatusReq

// optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PermissionStatusReq::_internal_has_spaceconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spaceconn_ != nullptr);
  return value;
}
inline bool PermissionStatusReq::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatusReq::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatusReq::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatusReq.spaceConn)
  return _internal_spaceconn();
}
inline void PermissionStatusReq::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PermissionStatusReq.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::release_spaceconn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatusReq.spaceConn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::_internal_mutable_spaceconn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatusReq.spaceConn)
  return _msg;
}
inline void PermissionStatusReq::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatusReq.spaceConn)
}

// string permission = 2;
inline void PermissionStatusReq::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& PermissionStatusReq::permission() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatusReq.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionStatusReq::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatusReq.permission)
}
inline std::string* PermissionStatusReq::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatusReq.permission)
  return _s;
}
inline const std::string& PermissionStatusReq::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void PermissionStatusReq::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionStatusReq::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionStatusReq::release_permission() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatusReq.permission)
  return _impl_.permission_.Release();
}
inline void PermissionStatusReq::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatusReq.permission)
}

// -------------------------------------------------------------------

// PermissionStatus

// optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PermissionStatus::_internal_has_spaceconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spaceconn_ != nullptr);
  return value;
}
inline bool PermissionStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PermissionStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PermissionStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::release_spaceconn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatus.spaceConn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::_internal_mutable_spaceconn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatus.spaceConn)
  return _msg;
}
inline void PermissionStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatus.spaceConn)
}

// string permission = 2;
inline void PermissionStatus::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& PermissionStatus::permission() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionStatus::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatus.permission)
}
inline std::string* PermissionStatus::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatus.permission)
  return _s;
}
inline const std::string& PermissionStatus::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void PermissionStatus::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionStatus::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionStatus::release_permission() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatus.permission)
  return _impl_.permission_.Release();
}
inline void PermissionStatus::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatus.permission)
}

// bool value = 3;
inline void PermissionStatus::clear_value() {
  _impl_.value_ = false;
}
inline bool PermissionStatus::_internal_value() const {
  return _impl_.value_;
}
inline bool PermissionStatus::value() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.value)
  return _internal_value();
}
inline void PermissionStatus::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void PermissionStatus::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatus.value)
}

// -------------------------------------------------------------------

// AllJoinableSpacesReq

// int32 reqId = 1;
inline void AllJoinableSpacesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AllJoinableSpacesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AllJoinableSpacesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesReq.reqId)
  return _internal_reqid();
}
inline void AllJoinableSpacesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AllJoinableSpacesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AllJoinableSpacesReq.reqId)
}

// -------------------------------------------------------------------

// AllJoinableSpacesResp

// int32 reqId = 1;
inline void AllJoinableSpacesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AllJoinableSpacesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AllJoinableSpacesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesResp.reqId)
  return _internal_reqid();
}
inline void AllJoinableSpacesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AllJoinableSpacesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AllJoinableSpacesResp.reqId)
}

// repeated .ServerData.SpaceInfo availableSpaces = 10;
inline int AllJoinableSpacesResp::_internal_availablespaces_size() const {
  return _impl_.availablespaces_.size();
}
inline int AllJoinableSpacesResp::availablespaces_size() const {
  return _internal_availablespaces_size();
}
inline void AllJoinableSpacesResp::clear_availablespaces() {
  _impl_.availablespaces_.Clear();
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::mutable_availablespaces(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _impl_.availablespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >*
AllJoinableSpacesResp::mutable_availablespaces() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.AllJoinableSpacesResp.availableSpaces)
  return &_impl_.availablespaces_;
}
inline const ::ServerData::SpaceInfo& AllJoinableSpacesResp::_internal_availablespaces(int index) const {
  return _impl_.availablespaces_.Get(index);
}
inline const ::ServerData::SpaceInfo& AllJoinableSpacesResp::availablespaces(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _internal_availablespaces(index);
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::_internal_add_availablespaces() {
  return _impl_.availablespaces_.Add();
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::add_availablespaces() {
  ::ServerData::SpaceInfo* _add = _internal_add_availablespaces();
  // @@protoc_insertion_point(field_add:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >&
AllJoinableSpacesResp::availablespaces() const {
  // @@protoc_insertion_point(field_list:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _impl_.availablespaces_;
}

// -------------------------------------------------------------------

// ChatAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.spaceConn)
  return _internal_spaceconn();
}
inline void ChatAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.spaceConn)
  return _msg;
}
inline void ChatAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatAdded::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatAdded::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatAdded::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatAdded.ChatPropertyId)
}
inline std::string* ChatAdded::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.ChatPropertyId)
  return _s;
}
inline const std::string& ChatAdded::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatAdded::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatAdded::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatAdded::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatAdded::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.ChatPropertyId)
}

// .ServerData.ChatBase ChatData = 10;
inline bool ChatAdded::_internal_has_chatdata() const {
  return this != internal_default_instance() && _impl_.chatdata_ != nullptr;
}
inline bool ChatAdded::has_chatdata() const {
  return _internal_has_chatdata();
}
inline void ChatAdded::clear_chatdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.chatdata_ != nullptr) {
    delete _impl_.chatdata_;
  }
  _impl_.chatdata_ = nullptr;
}
inline const ::ServerData::ChatBase& ChatAdded::_internal_chatdata() const {
  const ::ServerData::ChatBase* p = _impl_.chatdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::ChatBase&>(
      ::ServerData::_ChatBase_default_instance_);
}
inline const ::ServerData::ChatBase& ChatAdded::chatdata() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.ChatData)
  return _internal_chatdata();
}
inline void ChatAdded::unsafe_arena_set_allocated_chatdata(
    ::ServerData::ChatBase* chatdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chatdata_);
  }
  _impl_.chatdata_ = chatdata;
  if (chatdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatAdded.ChatData)
}
inline ::ServerData::ChatBase* ChatAdded::release_chatdata() {
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::ChatBase* ChatAdded::unsafe_arena_release_chatdata() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.ChatData)
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
  return temp;
}
inline ::ServerData::ChatBase* ChatAdded::_internal_mutable_chatdata() {
  
  if (_impl_.chatdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::ChatBase>(GetArenaForAllocation());
    _impl_.chatdata_ = p;
  }
  return _impl_.chatdata_;
}
inline ::ServerData::ChatBase* ChatAdded::mutable_chatdata() {
  ::ServerData::ChatBase* _msg = _internal_mutable_chatdata();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.ChatData)
  return _msg;
}
inline void ChatAdded::set_allocated_chatdata(::ServerData::ChatBase* chatdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chatdata_;
  }
  if (chatdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chatdata);
    if (message_arena != submessage_arena) {
      chatdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chatdata_ = chatdata;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.ChatData)
}

// -------------------------------------------------------------------

// ChatUpdated

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatUpdated::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatUpdated::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatUpdated::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatUpdated::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.spaceConn)
  return _internal_spaceconn();
}
inline void ChatUpdated::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatUpdated.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.spaceConn)
  return _msg;
}
inline void ChatUpdated::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatUpdated::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatUpdated::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatUpdated::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatUpdated.ChatPropertyId)
}
inline std::string* ChatUpdated::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.ChatPropertyId)
  return _s;
}
inline const std::string& ChatUpdated::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatUpdated::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatUpdated::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatUpdated::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatUpdated::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.ChatPropertyId)
}

// .ServerData.ChatBase ChatData = 10;
inline bool ChatUpdated::_internal_has_chatdata() const {
  return this != internal_default_instance() && _impl_.chatdata_ != nullptr;
}
inline bool ChatUpdated::has_chatdata() const {
  return _internal_has_chatdata();
}
inline void ChatUpdated::clear_chatdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.chatdata_ != nullptr) {
    delete _impl_.chatdata_;
  }
  _impl_.chatdata_ = nullptr;
}
inline const ::ServerData::ChatBase& ChatUpdated::_internal_chatdata() const {
  const ::ServerData::ChatBase* p = _impl_.chatdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::ChatBase&>(
      ::ServerData::_ChatBase_default_instance_);
}
inline const ::ServerData::ChatBase& ChatUpdated::chatdata() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.ChatData)
  return _internal_chatdata();
}
inline void ChatUpdated::unsafe_arena_set_allocated_chatdata(
    ::ServerData::ChatBase* chatdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chatdata_);
  }
  _impl_.chatdata_ = chatdata;
  if (chatdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatUpdated.ChatData)
}
inline ::ServerData::ChatBase* ChatUpdated::release_chatdata() {
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::ChatBase* ChatUpdated::unsafe_arena_release_chatdata() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.ChatData)
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
  return temp;
}
inline ::ServerData::ChatBase* ChatUpdated::_internal_mutable_chatdata() {
  
  if (_impl_.chatdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::ChatBase>(GetArenaForAllocation());
    _impl_.chatdata_ = p;
  }
  return _impl_.chatdata_;
}
inline ::ServerData::ChatBase* ChatUpdated::mutable_chatdata() {
  ::ServerData::ChatBase* _msg = _internal_mutable_chatdata();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.ChatData)
  return _msg;
}
inline void ChatUpdated::set_allocated_chatdata(::ServerData::ChatBase* chatdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chatdata_;
  }
  if (chatdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chatdata);
    if (message_arena != submessage_arena) {
      chatdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chatdata_ = chatdata;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.ChatData)
}

// -------------------------------------------------------------------

// ChatRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void ChatRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatRemoved.spaceConn)
  return _msg;
}
inline void ChatRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatRemoved.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatRemoved::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatRemoved::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatRemoved.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRemoved::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatRemoved.ChatPropertyId)
}
inline std::string* ChatRemoved::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatRemoved.ChatPropertyId)
  return _s;
}
inline const std::string& ChatRemoved::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatRemoved::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatRemoved::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatRemoved::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatRemoved.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatRemoved::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatRemoved.ChatPropertyId)
}

// -------------------------------------------------------------------

// PostChat

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostChat::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostChat::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostChat::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostChat::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostChat.spaceConn)
  return _internal_spaceconn();
}
inline void PostChat::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostChat.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostChat.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostChat.spaceConn)
  return _msg;
}
inline void PostChat::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostChat.spaceConn)
}

// string ChatText = 10;
inline void PostChat::clear_chattext() {
  _impl_.chattext_.ClearToEmpty();
}
inline const std::string& PostChat::chattext() const {
  // @@protoc_insertion_point(field_get:ServerData.PostChat.ChatText)
  return _internal_chattext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostChat::set_chattext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chattext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostChat.ChatText)
}
inline std::string* PostChat::mutable_chattext() {
  std::string* _s = _internal_mutable_chattext();
  // @@protoc_insertion_point(field_mutable:ServerData.PostChat.ChatText)
  return _s;
}
inline const std::string& PostChat::_internal_chattext() const {
  return _impl_.chattext_.Get();
}
inline void PostChat::_internal_set_chattext(const std::string& value) {
  
  _impl_.chattext_.Set(value, GetArenaForAllocation());
}
inline std::string* PostChat::_internal_mutable_chattext() {
  
  return _impl_.chattext_.Mutable(GetArenaForAllocation());
}
inline std::string* PostChat::release_chattext() {
  // @@protoc_insertion_point(field_release:ServerData.PostChat.ChatText)
  return _impl_.chattext_.Release();
}
inline void PostChat::set_allocated_chattext(std::string* chattext) {
  if (chattext != nullptr) {
    
  } else {
    
  }
  _impl_.chattext_.SetAllocated(chattext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chattext_.IsDefault()) {
    _impl_.chattext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostChat.ChatText)
}

// -------------------------------------------------------------------

// ChatBase

// .ServerData.ChatBase.ChatMessageSourceTypeEnum ChatType = 1;
inline void ChatBase::clear_chattype() {
  _impl_.chattype_ = 0;
}
inline ::ServerData::ChatBase_ChatMessageSourceTypeEnum ChatBase::_internal_chattype() const {
  return static_cast< ::ServerData::ChatBase_ChatMessageSourceTypeEnum >(_impl_.chattype_);
}
inline ::ServerData::ChatBase_ChatMessageSourceTypeEnum ChatBase::chattype() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.ChatType)
  return _internal_chattype();
}
inline void ChatBase::_internal_set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value) {
  
  _impl_.chattype_ = value;
}
inline void ChatBase::set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value) {
  _internal_set_chattype(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.ChatType)
}

// string Text = 2;
inline void ChatBase::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& ChatBase::text() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.Text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.Text)
}
inline std::string* ChatBase::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.Text)
  return _s;
}
inline const std::string& ChatBase::_internal_text() const {
  return _impl_.text_.Get();
}
inline void ChatBase::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_text() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.Text)
  return _impl_.text_.Release();
}
inline void ChatBase::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.Text)
}

// .google.protobuf.Timestamp CreatedTime = 3;
inline bool ChatBase::_internal_has_createdtime() const {
  return this != internal_default_instance() && _impl_.createdtime_ != nullptr;
}
inline bool ChatBase::has_createdtime() const {
  return _internal_has_createdtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChatBase::_internal_createdtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.createdtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChatBase::createdtime() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatedTime)
  return _internal_createdtime();
}
inline void ChatBase::unsafe_arena_set_allocated_createdtime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  _impl_.createdtime_ = createdtime;
  if (createdtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatBase.CreatedTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::release_createdtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::unsafe_arena_release_createdtime() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatedTime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::_internal_mutable_createdtime() {
  
  if (_impl_.createdtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.createdtime_ = p;
  }
  return _impl_.createdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::mutable_createdtime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdtime();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatedTime)
  return _msg;
}
inline void ChatBase::set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  if (createdtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdtime));
    if (message_arena != submessage_arena) {
      createdtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createdtime_ = createdtime;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatedTime)
}

// bool Complete = 4;
inline void ChatBase::clear_complete() {
  _impl_.complete_ = false;
}
inline bool ChatBase::_internal_complete() const {
  return _impl_.complete_;
}
inline bool ChatBase::complete() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.Complete)
  return _internal_complete();
}
inline void ChatBase::_internal_set_complete(bool value) {
  
  _impl_.complete_ = value;
}
inline void ChatBase::set_complete(bool value) {
  _internal_set_complete(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.Complete)
}

// bool WasTranslated = 5;
inline void ChatBase::clear_wastranslated() {
  _impl_.wastranslated_ = false;
}
inline bool ChatBase::_internal_wastranslated() const {
  return _impl_.wastranslated_;
}
inline bool ChatBase::wastranslated() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.WasTranslated)
  return _internal_wastranslated();
}
inline void ChatBase::_internal_set_wastranslated(bool value) {
  
  _impl_.wastranslated_ = value;
}
inline void ChatBase::set_wastranslated(bool value) {
  _internal_set_wastranslated(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.WasTranslated)
}

// bool CreatorIsLocal = 10;
inline void ChatBase::clear_creatorislocal() {
  _impl_.creatorislocal_ = false;
}
inline bool ChatBase::_internal_creatorislocal() const {
  return _impl_.creatorislocal_;
}
inline bool ChatBase::creatorislocal() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorIsLocal)
  return _internal_creatorislocal();
}
inline void ChatBase::_internal_set_creatorislocal(bool value) {
  
  _impl_.creatorislocal_ = value;
}
inline void ChatBase::set_creatorislocal(bool value) {
  _internal_set_creatorislocal(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorIsLocal)
}

// string CreatorName = 11;
inline void ChatBase::clear_creatorname() {
  _impl_.creatorname_.ClearToEmpty();
}
inline const std::string& ChatBase::creatorname() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorName)
  return _internal_creatorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_creatorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creatorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorName)
}
inline std::string* ChatBase::mutable_creatorname() {
  std::string* _s = _internal_mutable_creatorname();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatorName)
  return _s;
}
inline const std::string& ChatBase::_internal_creatorname() const {
  return _impl_.creatorname_.Get();
}
inline void ChatBase::_internal_set_creatorname(const std::string& value) {
  
  _impl_.creatorname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_creatorname() {
  
  return _impl_.creatorname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_creatorname() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatorName)
  return _impl_.creatorname_.Release();
}
inline void ChatBase::set_allocated_creatorname(std::string* creatorname) {
  if (creatorname != nullptr) {
    
  } else {
    
  }
  _impl_.creatorname_.SetAllocated(creatorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorname_.IsDefault()) {
    _impl_.creatorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatorName)
}

// string CreatorPicUrl = 12;
inline void ChatBase::clear_creatorpicurl() {
  _impl_.creatorpicurl_.ClearToEmpty();
}
inline const std::string& ChatBase::creatorpicurl() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorPicUrl)
  return _internal_creatorpicurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_creatorpicurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creatorpicurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorPicUrl)
}
inline std::string* ChatBase::mutable_creatorpicurl() {
  std::string* _s = _internal_mutable_creatorpicurl();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatorPicUrl)
  return _s;
}
inline const std::string& ChatBase::_internal_creatorpicurl() const {
  return _impl_.creatorpicurl_.Get();
}
inline void ChatBase::_internal_set_creatorpicurl(const std::string& value) {
  
  _impl_.creatorpicurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_creatorpicurl() {
  
  return _impl_.creatorpicurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_creatorpicurl() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatorPicUrl)
  return _impl_.creatorpicurl_.Release();
}
inline void ChatBase::set_allocated_creatorpicurl(std::string* creatorpicurl) {
  if (creatorpicurl != nullptr) {
    
  } else {
    
  }
  _impl_.creatorpicurl_.SetAllocated(creatorpicurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorpicurl_.IsDefault()) {
    _impl_.creatorpicurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatorPicUrl)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerData

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ServerData::ChatBase_ChatMessageSourceTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerData::ChatBase_ChatMessageSourceTypeEnum>() {
  return ::ServerData::ChatBase_ChatMessageSourceTypeEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_relay_2eproto

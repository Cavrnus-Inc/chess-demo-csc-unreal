// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: relay_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_relay_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_relay_5ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_relay_5ftypes_2eproto;
namespace ServerData {
class CavrnusAuth;
struct CavrnusAuthDefaultTypeInternal;
extern CavrnusAuthDefaultTypeInternal _CavrnusAuth_default_instance_;
class CavrnusAuthLinkResponse;
struct CavrnusAuthLinkResponseDefaultTypeInternal;
extern CavrnusAuthLinkResponseDefaultTypeInternal _CavrnusAuthLinkResponse_default_instance_;
class CavrnusRemoteContent;
struct CavrnusRemoteContentDefaultTypeInternal;
extern CavrnusRemoteContentDefaultTypeInternal _CavrnusRemoteContent_default_instance_;
class CavrnusSpaceConnection;
struct CavrnusSpaceConnectionDefaultTypeInternal;
extern CavrnusSpaceConnectionDefaultTypeInternal _CavrnusSpaceConnection_default_instance_;
class CavrnusUser;
struct CavrnusUserDefaultTypeInternal;
extern CavrnusUserDefaultTypeInternal _CavrnusUser_default_instance_;
class RtcAudioInputDevice;
struct RtcAudioInputDeviceDefaultTypeInternal;
extern RtcAudioInputDeviceDefaultTypeInternal _RtcAudioInputDevice_default_instance_;
class RtcAudioInputDeviceList;
struct RtcAudioInputDeviceListDefaultTypeInternal;
extern RtcAudioInputDeviceListDefaultTypeInternal _RtcAudioInputDeviceList_default_instance_;
class RtcAudioOutputDevice;
struct RtcAudioOutputDeviceDefaultTypeInternal;
extern RtcAudioOutputDeviceDefaultTypeInternal _RtcAudioOutputDevice_default_instance_;
class RtcAudioOutputDeviceList;
struct RtcAudioOutputDeviceListDefaultTypeInternal;
extern RtcAudioOutputDeviceListDefaultTypeInternal _RtcAudioOutputDeviceList_default_instance_;
class RtcVideoInputDevice;
struct RtcVideoInputDeviceDefaultTypeInternal;
extern RtcVideoInputDeviceDefaultTypeInternal _RtcVideoInputDevice_default_instance_;
class RtcVideoInputDeviceList;
struct RtcVideoInputDeviceListDefaultTypeInternal;
extern RtcVideoInputDeviceListDefaultTypeInternal _RtcVideoInputDeviceList_default_instance_;
}  // namespace ServerData
PROTOBUF_NAMESPACE_OPEN
template<> ::ServerData::CavrnusAuth* Arena::CreateMaybeMessage<::ServerData::CavrnusAuth>(Arena*);
template<> ::ServerData::CavrnusAuthLinkResponse* Arena::CreateMaybeMessage<::ServerData::CavrnusAuthLinkResponse>(Arena*);
template<> ::ServerData::CavrnusRemoteContent* Arena::CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(Arena*);
template<> ::ServerData::CavrnusSpaceConnection* Arena::CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(Arena*);
template<> ::ServerData::CavrnusUser* Arena::CreateMaybeMessage<::ServerData::CavrnusUser>(Arena*);
template<> ::ServerData::RtcAudioInputDevice* Arena::CreateMaybeMessage<::ServerData::RtcAudioInputDevice>(Arena*);
template<> ::ServerData::RtcAudioInputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcAudioInputDeviceList>(Arena*);
template<> ::ServerData::RtcAudioOutputDevice* Arena::CreateMaybeMessage<::ServerData::RtcAudioOutputDevice>(Arena*);
template<> ::ServerData::RtcAudioOutputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcAudioOutputDeviceList>(Arena*);
template<> ::ServerData::RtcVideoInputDevice* Arena::CreateMaybeMessage<::ServerData::RtcVideoInputDevice>(Arena*);
template<> ::ServerData::RtcVideoInputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcVideoInputDeviceList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ServerData {

// ===================================================================

class CavrnusAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusAuth) */ {
 public:
  inline CavrnusAuth() : CavrnusAuth(nullptr) {}
  ~CavrnusAuth() override;
  explicit PROTOBUF_CONSTEXPR CavrnusAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusAuth(const CavrnusAuth& from);
  CavrnusAuth(CavrnusAuth&& from) noexcept
    : CavrnusAuth() {
    *this = ::std::move(from);
  }

  inline CavrnusAuth& operator=(const CavrnusAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusAuth& operator=(CavrnusAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusAuth* internal_default_instance() {
    return reinterpret_cast<const CavrnusAuth*>(
               &_CavrnusAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CavrnusAuth& a, CavrnusAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusAuth& from) {
    CavrnusAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusAuth";
  }
  protected:
  explicit CavrnusAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusAuthLinkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusAuthLinkResponse) */ {
 public:
  inline CavrnusAuthLinkResponse() : CavrnusAuthLinkResponse(nullptr) {}
  ~CavrnusAuthLinkResponse() override;
  explicit PROTOBUF_CONSTEXPR CavrnusAuthLinkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusAuthLinkResponse(const CavrnusAuthLinkResponse& from);
  CavrnusAuthLinkResponse(CavrnusAuthLinkResponse&& from) noexcept
    : CavrnusAuthLinkResponse() {
    *this = ::std::move(from);
  }

  inline CavrnusAuthLinkResponse& operator=(const CavrnusAuthLinkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusAuthLinkResponse& operator=(CavrnusAuthLinkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusAuthLinkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusAuthLinkResponse* internal_default_instance() {
    return reinterpret_cast<const CavrnusAuthLinkResponse*>(
               &_CavrnusAuthLinkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CavrnusAuthLinkResponse& a, CavrnusAuthLinkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusAuthLinkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusAuthLinkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusAuthLinkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusAuthLinkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusAuthLinkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusAuthLinkResponse& from) {
    CavrnusAuthLinkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusAuthLinkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusAuthLinkResponse";
  }
  protected:
  explicit CavrnusAuthLinkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdToJoinFieldNumber = 1,
    kAuthFieldNumber = 2,
  };
  // string spaceIdToJoin = 1;
  void clear_spaceidtojoin();
  const std::string& spaceidtojoin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceidtojoin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceidtojoin();
  PROTOBUF_NODISCARD std::string* release_spaceidtojoin();
  void set_allocated_spaceidtojoin(std::string* spaceidtojoin);
  private:
  const std::string& _internal_spaceidtojoin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceidtojoin(const std::string& value);
  std::string* _internal_mutable_spaceidtojoin();
  public:

  // .ServerData.CavrnusAuth auth = 2;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::ServerData::CavrnusAuth& auth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuth* release_auth();
  ::ServerData::CavrnusAuth* mutable_auth();
  void set_allocated_auth(::ServerData::CavrnusAuth* auth);
  private:
  const ::ServerData::CavrnusAuth& _internal_auth() const;
  ::ServerData::CavrnusAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::ServerData::CavrnusAuth* auth);
  ::ServerData::CavrnusAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusAuthLinkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceidtojoin_;
    ::ServerData::CavrnusAuth* auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusSpaceConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusSpaceConnection) */ {
 public:
  inline CavrnusSpaceConnection() : CavrnusSpaceConnection(nullptr) {}
  ~CavrnusSpaceConnection() override;
  explicit PROTOBUF_CONSTEXPR CavrnusSpaceConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusSpaceConnection(const CavrnusSpaceConnection& from);
  CavrnusSpaceConnection(CavrnusSpaceConnection&& from) noexcept
    : CavrnusSpaceConnection() {
    *this = ::std::move(from);
  }

  inline CavrnusSpaceConnection& operator=(const CavrnusSpaceConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusSpaceConnection& operator=(CavrnusSpaceConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusSpaceConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusSpaceConnection* internal_default_instance() {
    return reinterpret_cast<const CavrnusSpaceConnection*>(
               &_CavrnusSpaceConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CavrnusSpaceConnection& a, CavrnusSpaceConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusSpaceConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusSpaceConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusSpaceConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusSpaceConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusSpaceConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusSpaceConnection& from) {
    CavrnusSpaceConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusSpaceConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusSpaceConnection";
  }
  protected:
  explicit CavrnusSpaceConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalUserConnectionIdFieldNumber = 10,
    kSpaceConnectionIdFieldNumber = 1,
  };
  // string localUserConnectionId = 10;
  void clear_localuserconnectionid();
  const std::string& localuserconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localuserconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localuserconnectionid();
  PROTOBUF_NODISCARD std::string* release_localuserconnectionid();
  void set_allocated_localuserconnectionid(std::string* localuserconnectionid);
  private:
  const std::string& _internal_localuserconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localuserconnectionid(const std::string& value);
  std::string* _internal_mutable_localuserconnectionid();
  public:

  // int32 SpaceConnectionId = 1;
  void clear_spaceconnectionid();
  int32_t spaceconnectionid() const;
  void set_spaceconnectionid(int32_t value);
  private:
  int32_t _internal_spaceconnectionid() const;
  void _internal_set_spaceconnectionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusSpaceConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localuserconnectionid_;
    int32_t spaceconnectionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusUser) */ {
 public:
  inline CavrnusUser() : CavrnusUser(nullptr) {}
  ~CavrnusUser() override;
  explicit PROTOBUF_CONSTEXPR CavrnusUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusUser(const CavrnusUser& from);
  CavrnusUser(CavrnusUser&& from) noexcept
    : CavrnusUser() {
    *this = ::std::move(from);
  }

  inline CavrnusUser& operator=(const CavrnusUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusUser& operator=(CavrnusUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusUser* internal_default_instance() {
    return reinterpret_cast<const CavrnusUser*>(
               &_CavrnusUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CavrnusUser& a, CavrnusUser& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusUser& from) {
    CavrnusUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusUser";
  }
  protected:
  explicit CavrnusUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserConnectionIdFieldNumber = 1,
    kIsLocalUserFieldNumber = 2,
  };
  // string userConnectionId = 1;
  void clear_userconnectionid();
  const std::string& userconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userconnectionid();
  PROTOBUF_NODISCARD std::string* release_userconnectionid();
  void set_allocated_userconnectionid(std::string* userconnectionid);
  private:
  const std::string& _internal_userconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userconnectionid(const std::string& value);
  std::string* _internal_mutable_userconnectionid();
  public:

  // bool IsLocalUser = 2;
  void clear_islocaluser();
  bool islocaluser() const;
  void set_islocaluser(bool value);
  private:
  bool _internal_islocaluser() const;
  void _internal_set_islocaluser(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userconnectionid_;
    bool islocaluser_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioInputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioInputDevice) */ {
 public:
  inline RtcAudioInputDevice() : RtcAudioInputDevice(nullptr) {}
  ~RtcAudioInputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioInputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioInputDevice(const RtcAudioInputDevice& from);
  RtcAudioInputDevice(RtcAudioInputDevice&& from) noexcept
    : RtcAudioInputDevice() {
    *this = ::std::move(from);
  }

  inline RtcAudioInputDevice& operator=(const RtcAudioInputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioInputDevice& operator=(RtcAudioInputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioInputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioInputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcAudioInputDevice*>(
               &_RtcAudioInputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RtcAudioInputDevice& a, RtcAudioInputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioInputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioInputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioInputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioInputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioInputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioInputDevice& from) {
    RtcAudioInputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioInputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioInputDevice";
  }
  protected:
  explicit RtcAudioInputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioInputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioInputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioInputDeviceList) */ {
 public:
  inline RtcAudioInputDeviceList() : RtcAudioInputDeviceList(nullptr) {}
  ~RtcAudioInputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioInputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioInputDeviceList(const RtcAudioInputDeviceList& from);
  RtcAudioInputDeviceList(RtcAudioInputDeviceList&& from) noexcept
    : RtcAudioInputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcAudioInputDeviceList& operator=(const RtcAudioInputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioInputDeviceList& operator=(RtcAudioInputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioInputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioInputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcAudioInputDeviceList*>(
               &_RtcAudioInputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RtcAudioInputDeviceList& a, RtcAudioInputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioInputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioInputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioInputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioInputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioInputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioInputDeviceList& from) {
    RtcAudioInputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioInputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioInputDeviceList";
  }
  protected:
  explicit RtcAudioInputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcAudioInputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcAudioInputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcAudioInputDevice& _internal_devices(int index) const;
  ::ServerData::RtcAudioInputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcAudioInputDevice& devices(int index) const;
  ::ServerData::RtcAudioInputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioInputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioOutputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioOutputDevice) */ {
 public:
  inline RtcAudioOutputDevice() : RtcAudioOutputDevice(nullptr) {}
  ~RtcAudioOutputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioOutputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioOutputDevice(const RtcAudioOutputDevice& from);
  RtcAudioOutputDevice(RtcAudioOutputDevice&& from) noexcept
    : RtcAudioOutputDevice() {
    *this = ::std::move(from);
  }

  inline RtcAudioOutputDevice& operator=(const RtcAudioOutputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioOutputDevice& operator=(RtcAudioOutputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioOutputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioOutputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcAudioOutputDevice*>(
               &_RtcAudioOutputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RtcAudioOutputDevice& a, RtcAudioOutputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioOutputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioOutputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioOutputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioOutputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioOutputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioOutputDevice& from) {
    RtcAudioOutputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioOutputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioOutputDevice";
  }
  protected:
  explicit RtcAudioOutputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioOutputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioOutputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioOutputDeviceList) */ {
 public:
  inline RtcAudioOutputDeviceList() : RtcAudioOutputDeviceList(nullptr) {}
  ~RtcAudioOutputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioOutputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioOutputDeviceList(const RtcAudioOutputDeviceList& from);
  RtcAudioOutputDeviceList(RtcAudioOutputDeviceList&& from) noexcept
    : RtcAudioOutputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcAudioOutputDeviceList& operator=(const RtcAudioOutputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioOutputDeviceList& operator=(RtcAudioOutputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioOutputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioOutputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcAudioOutputDeviceList*>(
               &_RtcAudioOutputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RtcAudioOutputDeviceList& a, RtcAudioOutputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioOutputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioOutputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioOutputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioOutputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioOutputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioOutputDeviceList& from) {
    RtcAudioOutputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioOutputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioOutputDeviceList";
  }
  protected:
  explicit RtcAudioOutputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcAudioOutputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcAudioOutputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcAudioOutputDevice& _internal_devices(int index) const;
  ::ServerData::RtcAudioOutputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcAudioOutputDevice& devices(int index) const;
  ::ServerData::RtcAudioOutputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioOutputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcVideoInputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcVideoInputDevice) */ {
 public:
  inline RtcVideoInputDevice() : RtcVideoInputDevice(nullptr) {}
  ~RtcVideoInputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcVideoInputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcVideoInputDevice(const RtcVideoInputDevice& from);
  RtcVideoInputDevice(RtcVideoInputDevice&& from) noexcept
    : RtcVideoInputDevice() {
    *this = ::std::move(from);
  }

  inline RtcVideoInputDevice& operator=(const RtcVideoInputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcVideoInputDevice& operator=(RtcVideoInputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcVideoInputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcVideoInputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcVideoInputDevice*>(
               &_RtcVideoInputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RtcVideoInputDevice& a, RtcVideoInputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcVideoInputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcVideoInputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcVideoInputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcVideoInputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcVideoInputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcVideoInputDevice& from) {
    RtcVideoInputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcVideoInputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcVideoInputDevice";
  }
  protected:
  explicit RtcVideoInputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcVideoInputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcVideoInputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcVideoInputDeviceList) */ {
 public:
  inline RtcVideoInputDeviceList() : RtcVideoInputDeviceList(nullptr) {}
  ~RtcVideoInputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcVideoInputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcVideoInputDeviceList(const RtcVideoInputDeviceList& from);
  RtcVideoInputDeviceList(RtcVideoInputDeviceList&& from) noexcept
    : RtcVideoInputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcVideoInputDeviceList& operator=(const RtcVideoInputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcVideoInputDeviceList& operator=(RtcVideoInputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcVideoInputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcVideoInputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcVideoInputDeviceList*>(
               &_RtcVideoInputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RtcVideoInputDeviceList& a, RtcVideoInputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcVideoInputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcVideoInputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcVideoInputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcVideoInputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcVideoInputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcVideoInputDeviceList& from) {
    RtcVideoInputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcVideoInputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcVideoInputDeviceList";
  }
  protected:
  explicit RtcVideoInputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcVideoInputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcVideoInputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcVideoInputDevice& _internal_devices(int index) const;
  ::ServerData::RtcVideoInputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcVideoInputDevice& devices(int index) const;
  ::ServerData::RtcVideoInputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcVideoInputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusRemoteContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusRemoteContent) */ {
 public:
  inline CavrnusRemoteContent() : CavrnusRemoteContent(nullptr) {}
  ~CavrnusRemoteContent() override;
  explicit PROTOBUF_CONSTEXPR CavrnusRemoteContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusRemoteContent(const CavrnusRemoteContent& from);
  CavrnusRemoteContent(CavrnusRemoteContent&& from) noexcept
    : CavrnusRemoteContent() {
    *this = ::std::move(from);
  }

  inline CavrnusRemoteContent& operator=(const CavrnusRemoteContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusRemoteContent& operator=(CavrnusRemoteContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusRemoteContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusRemoteContent* internal_default_instance() {
    return reinterpret_cast<const CavrnusRemoteContent*>(
               &_CavrnusRemoteContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CavrnusRemoteContent& a, CavrnusRemoteContent& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusRemoteContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusRemoteContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusRemoteContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusRemoteContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusRemoteContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusRemoteContent& from) {
    CavrnusRemoteContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusRemoteContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusRemoteContent";
  }
  protected:
  explicit CavrnusRemoteContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagKeysFieldNumber = 10,
    kTagValuesFieldNumber = 11,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kThumbnailUrlFieldNumber = 4,
  };
  // repeated string tagKeys = 10;
  int tagkeys_size() const;
  private:
  int _internal_tagkeys_size() const;
  public:
  void clear_tagkeys();
  const std::string& tagkeys(int index) const;
  std::string* mutable_tagkeys(int index);
  void set_tagkeys(int index, const std::string& value);
  void set_tagkeys(int index, std::string&& value);
  void set_tagkeys(int index, const char* value);
  void set_tagkeys(int index, const char* value, size_t size);
  std::string* add_tagkeys();
  void add_tagkeys(const std::string& value);
  void add_tagkeys(std::string&& value);
  void add_tagkeys(const char* value);
  void add_tagkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagkeys();
  private:
  const std::string& _internal_tagkeys(int index) const;
  std::string* _internal_add_tagkeys();
  public:

  // repeated string tagValues = 11;
  int tagvalues_size() const;
  private:
  int _internal_tagvalues_size() const;
  public:
  void clear_tagvalues();
  const std::string& tagvalues(int index) const;
  std::string* mutable_tagvalues(int index);
  void set_tagvalues(int index, const std::string& value);
  void set_tagvalues(int index, std::string&& value);
  void set_tagvalues(int index, const char* value);
  void set_tagvalues(int index, const char* value, size_t size);
  std::string* add_tagvalues();
  void add_tagvalues(const std::string& value);
  void add_tagvalues(std::string&& value);
  void add_tagvalues(const char* value);
  void add_tagvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagvalues();
  private:
  const std::string& _internal_tagvalues(int index) const;
  std::string* _internal_add_tagvalues();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fileName = 3;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string thumbnailUrl = 4;
  void clear_thumbnailurl();
  const std::string& thumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailurl();
  PROTOBUF_NODISCARD std::string* release_thumbnailurl();
  void set_allocated_thumbnailurl(std::string* thumbnailurl);
  private:
  const std::string& _internal_thumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailurl(const std::string& value);
  std::string* _internal_mutable_thumbnailurl();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusRemoteContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailurl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CavrnusAuth

// string token = 1;
inline void CavrnusAuth::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& CavrnusAuth::token() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuth.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuth::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuth.token)
}
inline std::string* CavrnusAuth::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuth.token)
  return _s;
}
inline const std::string& CavrnusAuth::_internal_token() const {
  return _impl_.token_.Get();
}
inline void CavrnusAuth::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuth::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuth::release_token() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuth.token)
  return _impl_.token_.Release();
}
inline void CavrnusAuth::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuth.token)
}

// -------------------------------------------------------------------

// CavrnusAuthLinkResponse

// string spaceIdToJoin = 1;
inline void CavrnusAuthLinkResponse::clear_spaceidtojoin() {
  _impl_.spaceidtojoin_.ClearToEmpty();
}
inline const std::string& CavrnusAuthLinkResponse::spaceidtojoin() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _internal_spaceidtojoin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuthLinkResponse::set_spaceidtojoin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceidtojoin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
}
inline std::string* CavrnusAuthLinkResponse::mutable_spaceidtojoin() {
  std::string* _s = _internal_mutable_spaceidtojoin();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _s;
}
inline const std::string& CavrnusAuthLinkResponse::_internal_spaceidtojoin() const {
  return _impl_.spaceidtojoin_.Get();
}
inline void CavrnusAuthLinkResponse::_internal_set_spaceidtojoin(const std::string& value) {
  
  _impl_.spaceidtojoin_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuthLinkResponse::_internal_mutable_spaceidtojoin() {
  
  return _impl_.spaceidtojoin_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuthLinkResponse::release_spaceidtojoin() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _impl_.spaceidtojoin_.Release();
}
inline void CavrnusAuthLinkResponse::set_allocated_spaceidtojoin(std::string* spaceidtojoin) {
  if (spaceidtojoin != nullptr) {
    
  } else {
    
  }
  _impl_.spaceidtojoin_.SetAllocated(spaceidtojoin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceidtojoin_.IsDefault()) {
    _impl_.spaceidtojoin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
}

// .ServerData.CavrnusAuth auth = 2;
inline bool CavrnusAuthLinkResponse::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool CavrnusAuthLinkResponse::has_auth() const {
  return _internal_has_auth();
}
inline void CavrnusAuthLinkResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
}
inline const ::ServerData::CavrnusAuth& CavrnusAuthLinkResponse::_internal_auth() const {
  const ::ServerData::CavrnusAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusAuth&>(
      ::ServerData::_CavrnusAuth_default_instance_);
}
inline const ::ServerData::CavrnusAuth& CavrnusAuthLinkResponse::auth() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuthLinkResponse.auth)
  return _internal_auth();
}
inline void CavrnusAuthLinkResponse::unsafe_arena_set_allocated_auth(
    ::ServerData::CavrnusAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CavrnusAuthLinkResponse.auth)
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::release_auth() {
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuthLinkResponse.auth)
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusAuth>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::mutable_auth() {
  ::ServerData::CavrnusAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuthLinkResponse.auth)
  return _msg;
}
inline void CavrnusAuthLinkResponse::set_allocated_auth(::ServerData::CavrnusAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuthLinkResponse.auth)
}

// -------------------------------------------------------------------

// CavrnusSpaceConnection

// int32 SpaceConnectionId = 1;
inline void CavrnusSpaceConnection::clear_spaceconnectionid() {
  _impl_.spaceconnectionid_ = 0;
}
inline int32_t CavrnusSpaceConnection::_internal_spaceconnectionid() const {
  return _impl_.spaceconnectionid_;
}
inline int32_t CavrnusSpaceConnection::spaceconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnection.SpaceConnectionId)
  return _internal_spaceconnectionid();
}
inline void CavrnusSpaceConnection::_internal_set_spaceconnectionid(int32_t value) {
  
  _impl_.spaceconnectionid_ = value;
}
inline void CavrnusSpaceConnection::set_spaceconnectionid(int32_t value) {
  _internal_set_spaceconnectionid(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnection.SpaceConnectionId)
}

// string localUserConnectionId = 10;
inline void CavrnusSpaceConnection::clear_localuserconnectionid() {
  _impl_.localuserconnectionid_.ClearToEmpty();
}
inline const std::string& CavrnusSpaceConnection::localuserconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnection.localUserConnectionId)
  return _internal_localuserconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusSpaceConnection::set_localuserconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.localuserconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnection.localUserConnectionId)
}
inline std::string* CavrnusSpaceConnection::mutable_localuserconnectionid() {
  std::string* _s = _internal_mutable_localuserconnectionid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusSpaceConnection.localUserConnectionId)
  return _s;
}
inline const std::string& CavrnusSpaceConnection::_internal_localuserconnectionid() const {
  return _impl_.localuserconnectionid_.Get();
}
inline void CavrnusSpaceConnection::_internal_set_localuserconnectionid(const std::string& value) {
  
  _impl_.localuserconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusSpaceConnection::_internal_mutable_localuserconnectionid() {
  
  return _impl_.localuserconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusSpaceConnection::release_localuserconnectionid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusSpaceConnection.localUserConnectionId)
  return _impl_.localuserconnectionid_.Release();
}
inline void CavrnusSpaceConnection::set_allocated_localuserconnectionid(std::string* localuserconnectionid) {
  if (localuserconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.localuserconnectionid_.SetAllocated(localuserconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localuserconnectionid_.IsDefault()) {
    _impl_.localuserconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusSpaceConnection.localUserConnectionId)
}

// -------------------------------------------------------------------

// CavrnusUser

// string userConnectionId = 1;
inline void CavrnusUser::clear_userconnectionid() {
  _impl_.userconnectionid_.ClearToEmpty();
}
inline const std::string& CavrnusUser::userconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUser.userConnectionId)
  return _internal_userconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUser::set_userconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUser.userConnectionId)
}
inline std::string* CavrnusUser::mutable_userconnectionid() {
  std::string* _s = _internal_mutable_userconnectionid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUser.userConnectionId)
  return _s;
}
inline const std::string& CavrnusUser::_internal_userconnectionid() const {
  return _impl_.userconnectionid_.Get();
}
inline void CavrnusUser::_internal_set_userconnectionid(const std::string& value) {
  
  _impl_.userconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUser::_internal_mutable_userconnectionid() {
  
  return _impl_.userconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUser::release_userconnectionid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUser.userConnectionId)
  return _impl_.userconnectionid_.Release();
}
inline void CavrnusUser::set_allocated_userconnectionid(std::string* userconnectionid) {
  if (userconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.userconnectionid_.SetAllocated(userconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userconnectionid_.IsDefault()) {
    _impl_.userconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUser.userConnectionId)
}

// bool IsLocalUser = 2;
inline void CavrnusUser::clear_islocaluser() {
  _impl_.islocaluser_ = false;
}
inline bool CavrnusUser::_internal_islocaluser() const {
  return _impl_.islocaluser_;
}
inline bool CavrnusUser::islocaluser() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUser.IsLocalUser)
  return _internal_islocaluser();
}
inline void CavrnusUser::_internal_set_islocaluser(bool value) {
  
  _impl_.islocaluser_ = value;
}
inline void CavrnusUser::set_islocaluser(bool value) {
  _internal_set_islocaluser(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUser.IsLocalUser)
}

// -------------------------------------------------------------------

// RtcAudioInputDevice

// string id = 1;
inline void RtcAudioInputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcAudioInputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioInputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioInputDevice.id)
}
inline std::string* RtcAudioInputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDevice.id)
  return _s;
}
inline const std::string& RtcAudioInputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcAudioInputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioInputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcAudioInputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioInputDevice.id)
}

// string name = 2;
inline void RtcAudioInputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcAudioInputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioInputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioInputDevice.name)
}
inline std::string* RtcAudioInputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDevice.name)
  return _s;
}
inline const std::string& RtcAudioInputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcAudioInputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioInputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcAudioInputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioInputDevice.name)
}

// -------------------------------------------------------------------

// RtcAudioInputDeviceList

// repeated .ServerData.RtcAudioInputDevice devices = 1;
inline int RtcAudioInputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcAudioInputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcAudioInputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >*
RtcAudioInputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcAudioInputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcAudioInputDevice& RtcAudioInputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcAudioInputDevice& RtcAudioInputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::add_devices() {
  ::ServerData::RtcAudioInputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcAudioInputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >&
RtcAudioInputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcAudioInputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// RtcAudioOutputDevice

// string id = 1;
inline void RtcAudioOutputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcAudioOutputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioOutputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioOutputDevice.id)
}
inline std::string* RtcAudioOutputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDevice.id)
  return _s;
}
inline const std::string& RtcAudioOutputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcAudioOutputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioOutputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcAudioOutputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioOutputDevice.id)
}

// string name = 2;
inline void RtcAudioOutputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcAudioOutputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioOutputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioOutputDevice.name)
}
inline std::string* RtcAudioOutputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDevice.name)
  return _s;
}
inline const std::string& RtcAudioOutputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcAudioOutputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioOutputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcAudioOutputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioOutputDevice.name)
}

// -------------------------------------------------------------------

// RtcAudioOutputDeviceList

// repeated .ServerData.RtcAudioOutputDevice devices = 1;
inline int RtcAudioOutputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcAudioOutputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcAudioOutputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >*
RtcAudioOutputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcAudioOutputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcAudioOutputDevice& RtcAudioOutputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcAudioOutputDevice& RtcAudioOutputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::add_devices() {
  ::ServerData::RtcAudioOutputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcAudioOutputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >&
RtcAudioOutputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcAudioOutputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// RtcVideoInputDevice

// string id = 1;
inline void RtcVideoInputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcVideoInputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcVideoInputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcVideoInputDevice.id)
}
inline std::string* RtcVideoInputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDevice.id)
  return _s;
}
inline const std::string& RtcVideoInputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcVideoInputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcVideoInputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcVideoInputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcVideoInputDevice.id)
}

// string name = 2;
inline void RtcVideoInputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcVideoInputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcVideoInputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcVideoInputDevice.name)
}
inline std::string* RtcVideoInputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDevice.name)
  return _s;
}
inline const std::string& RtcVideoInputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcVideoInputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcVideoInputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcVideoInputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcVideoInputDevice.name)
}

// -------------------------------------------------------------------

// RtcVideoInputDeviceList

// repeated .ServerData.RtcVideoInputDevice devices = 1;
inline int RtcVideoInputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcVideoInputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcVideoInputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >*
RtcVideoInputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcVideoInputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcVideoInputDevice& RtcVideoInputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcVideoInputDevice& RtcVideoInputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::add_devices() {
  ::ServerData::RtcVideoInputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcVideoInputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >&
RtcVideoInputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcVideoInputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// CavrnusRemoteContent

// string id = 1;
inline void CavrnusRemoteContent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::id() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.id)
}
inline std::string* CavrnusRemoteContent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.id)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CavrnusRemoteContent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.id)
  return _impl_.id_.Release();
}
inline void CavrnusRemoteContent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.id)
}

// string name = 2;
inline void CavrnusRemoteContent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::name() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.name)
}
inline std::string* CavrnusRemoteContent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.name)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CavrnusRemoteContent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.name)
  return _impl_.name_.Release();
}
inline void CavrnusRemoteContent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.name)
}

// string fileName = 3;
inline void CavrnusRemoteContent::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::filename() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.fileName)
}
inline std::string* CavrnusRemoteContent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.fileName)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void CavrnusRemoteContent::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_filename() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.fileName)
  return _impl_.filename_.Release();
}
inline void CavrnusRemoteContent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.fileName)
}

// string thumbnailUrl = 4;
inline void CavrnusRemoteContent::clear_thumbnailurl() {
  _impl_.thumbnailurl_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::thumbnailurl() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _internal_thumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_thumbnailurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.thumbnailUrl)
}
inline std::string* CavrnusRemoteContent::mutable_thumbnailurl() {
  std::string* _s = _internal_mutable_thumbnailurl();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_thumbnailurl() const {
  return _impl_.thumbnailurl_.Get();
}
inline void CavrnusRemoteContent::_internal_set_thumbnailurl(const std::string& value) {
  
  _impl_.thumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_thumbnailurl() {
  
  return _impl_.thumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_thumbnailurl() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _impl_.thumbnailurl_.Release();
}
inline void CavrnusRemoteContent::set_allocated_thumbnailurl(std::string* thumbnailurl) {
  if (thumbnailurl != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnailurl_.SetAllocated(thumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.thumbnailUrl)
}

// repeated string tagKeys = 10;
inline int CavrnusRemoteContent::_internal_tagkeys_size() const {
  return _impl_.tagkeys_.size();
}
inline int CavrnusRemoteContent::tagkeys_size() const {
  return _internal_tagkeys_size();
}
inline void CavrnusRemoteContent::clear_tagkeys() {
  _impl_.tagkeys_.Clear();
}
inline std::string* CavrnusRemoteContent::add_tagkeys() {
  std::string* _s = _internal_add_tagkeys();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusRemoteContent.tagKeys)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_tagkeys(int index) const {
  return _impl_.tagkeys_.Get(index);
}
inline const std::string& CavrnusRemoteContent::tagkeys(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.tagKeys)
  return _internal_tagkeys(index);
}
inline std::string* CavrnusRemoteContent::mutable_tagkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.tagKeys)
  return _impl_.tagkeys_.Mutable(index);
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const std::string& value) {
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, std::string&& value) {
  _impl_.tagkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const char* value, size_t size) {
  _impl_.tagkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusRemoteContent.tagKeys)
}
inline std::string* CavrnusRemoteContent::_internal_add_tagkeys() {
  return _impl_.tagkeys_.Add();
}
inline void CavrnusRemoteContent::add_tagkeys(const std::string& value) {
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(std::string&& value) {
  _impl_.tagkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(const char* value, size_t size) {
  _impl_.tagkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusRemoteContent.tagKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusRemoteContent::tagkeys() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusRemoteContent.tagKeys)
  return _impl_.tagkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusRemoteContent::mutable_tagkeys() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusRemoteContent.tagKeys)
  return &_impl_.tagkeys_;
}

// repeated string tagValues = 11;
inline int CavrnusRemoteContent::_internal_tagvalues_size() const {
  return _impl_.tagvalues_.size();
}
inline int CavrnusRemoteContent::tagvalues_size() const {
  return _internal_tagvalues_size();
}
inline void CavrnusRemoteContent::clear_tagvalues() {
  _impl_.tagvalues_.Clear();
}
inline std::string* CavrnusRemoteContent::add_tagvalues() {
  std::string* _s = _internal_add_tagvalues();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusRemoteContent.tagValues)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_tagvalues(int index) const {
  return _impl_.tagvalues_.Get(index);
}
inline const std::string& CavrnusRemoteContent::tagvalues(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.tagValues)
  return _internal_tagvalues(index);
}
inline std::string* CavrnusRemoteContent::mutable_tagvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.tagValues)
  return _impl_.tagvalues_.Mutable(index);
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const std::string& value) {
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, std::string&& value) {
  _impl_.tagvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const char* value, size_t size) {
  _impl_.tagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusRemoteContent.tagValues)
}
inline std::string* CavrnusRemoteContent::_internal_add_tagvalues() {
  return _impl_.tagvalues_.Add();
}
inline void CavrnusRemoteContent::add_tagvalues(const std::string& value) {
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(std::string&& value) {
  _impl_.tagvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(const char* value, size_t size) {
  _impl_.tagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusRemoteContent.tagValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusRemoteContent::tagvalues() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusRemoteContent.tagValues)
  return _impl_.tagvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusRemoteContent::mutable_tagvalues() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusRemoteContent.tagValues)
  return &_impl_.tagvalues_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerData

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto

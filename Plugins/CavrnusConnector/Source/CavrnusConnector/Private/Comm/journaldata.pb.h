// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: journaldata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_journaldata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_journaldata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_journaldata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_journaldata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_journaldata_2eproto;
namespace JournalData {
class BoardSizeData;
struct BoardSizeDataDefaultTypeInternal;
extern BoardSizeDataDefaultTypeInternal _BoardSizeData_default_instance_;
class BoardState;
struct BoardStateDefaultTypeInternal;
extern BoardStateDefaultTypeInternal _BoardState_default_instance_;
class Image2dPlacementData;
struct Image2dPlacementDataDefaultTypeInternal;
extern Image2dPlacementDataDefaultTypeInternal _Image2dPlacementData_default_instance_;
class ImageContentType;
struct ImageContentTypeDefaultTypeInternal;
extern ImageContentTypeDefaultTypeInternal _ImageContentType_default_instance_;
class LightingEnvironmentContentType;
struct LightingEnvironmentContentTypeDefaultTypeInternal;
extern LightingEnvironmentContentTypeDefaultTypeInternal _LightingEnvironmentContentType_default_instance_;
class ObjectId;
struct ObjectIdDefaultTypeInternal;
extern ObjectIdDefaultTypeInternal _ObjectId_default_instance_;
class ObjectPlacementData;
struct ObjectPlacementDataDefaultTypeInternal;
extern ObjectPlacementDataDefaultTypeInternal _ObjectPlacementData_default_instance_;
class ObjectType;
struct ObjectTypeDefaultTypeInternal;
extern ObjectTypeDefaultTypeInternal _ObjectType_default_instance_;
class ObjectType_ArTrackerObjectType;
struct ObjectType_ArTrackerObjectTypeDefaultTypeInternal;
extern ObjectType_ArTrackerObjectTypeDefaultTypeInternal _ObjectType_ArTrackerObjectType_default_instance_;
class ObjectType_ChatMessageObjectType;
struct ObjectType_ChatMessageObjectTypeDefaultTypeInternal;
extern ObjectType_ChatMessageObjectTypeDefaultTypeInternal _ObjectType_ChatMessageObjectType_default_instance_;
class ObjectType_CustomContentId;
struct ObjectType_CustomContentIdDefaultTypeInternal;
extern ObjectType_CustomContentIdDefaultTypeInternal _ObjectType_CustomContentId_default_instance_;
class ObjectType_StreamBoardObjectType;
struct ObjectType_StreamBoardObjectTypeDefaultTypeInternal;
extern ObjectType_StreamBoardObjectTypeDefaultTypeInternal _ObjectType_StreamBoardObjectType_default_instance_;
class ObjectType_TextBoardObjectType;
struct ObjectType_TextBoardObjectTypeDefaultTypeInternal;
extern ObjectType_TextBoardObjectTypeDefaultTypeInternal _ObjectType_TextBoardObjectType_default_instance_;
class PartHighlightData;
struct PartHighlightDataDefaultTypeInternal;
extern PartHighlightDataDefaultTypeInternal _PartHighlightData_default_instance_;
class Progress;
struct ProgressDefaultTypeInternal;
extern ProgressDefaultTypeInternal _Progress_default_instance_;
class Progress_V1;
struct Progress_V1DefaultTypeInternal;
extern Progress_V1DefaultTypeInternal _Progress_V1_default_instance_;
class Progress_V2;
struct Progress_V2DefaultTypeInternal;
extern Progress_V2DefaultTypeInternal _Progress_V2_default_instance_;
class TagPlacementData;
struct TagPlacementDataDefaultTypeInternal;
extern TagPlacementDataDefaultTypeInternal _TagPlacementData_default_instance_;
}  // namespace JournalData
PROTOBUF_NAMESPACE_OPEN
template<> ::JournalData::BoardSizeData* Arena::CreateMaybeMessage<::JournalData::BoardSizeData>(Arena*);
template<> ::JournalData::BoardState* Arena::CreateMaybeMessage<::JournalData::BoardState>(Arena*);
template<> ::JournalData::Image2dPlacementData* Arena::CreateMaybeMessage<::JournalData::Image2dPlacementData>(Arena*);
template<> ::JournalData::ImageContentType* Arena::CreateMaybeMessage<::JournalData::ImageContentType>(Arena*);
template<> ::JournalData::LightingEnvironmentContentType* Arena::CreateMaybeMessage<::JournalData::LightingEnvironmentContentType>(Arena*);
template<> ::JournalData::ObjectId* Arena::CreateMaybeMessage<::JournalData::ObjectId>(Arena*);
template<> ::JournalData::ObjectPlacementData* Arena::CreateMaybeMessage<::JournalData::ObjectPlacementData>(Arena*);
template<> ::JournalData::ObjectType* Arena::CreateMaybeMessage<::JournalData::ObjectType>(Arena*);
template<> ::JournalData::ObjectType_ArTrackerObjectType* Arena::CreateMaybeMessage<::JournalData::ObjectType_ArTrackerObjectType>(Arena*);
template<> ::JournalData::ObjectType_ChatMessageObjectType* Arena::CreateMaybeMessage<::JournalData::ObjectType_ChatMessageObjectType>(Arena*);
template<> ::JournalData::ObjectType_CustomContentId* Arena::CreateMaybeMessage<::JournalData::ObjectType_CustomContentId>(Arena*);
template<> ::JournalData::ObjectType_StreamBoardObjectType* Arena::CreateMaybeMessage<::JournalData::ObjectType_StreamBoardObjectType>(Arena*);
template<> ::JournalData::ObjectType_TextBoardObjectType* Arena::CreateMaybeMessage<::JournalData::ObjectType_TextBoardObjectType>(Arena*);
template<> ::JournalData::PartHighlightData* Arena::CreateMaybeMessage<::JournalData::PartHighlightData>(Arena*);
template<> ::JournalData::Progress* Arena::CreateMaybeMessage<::JournalData::Progress>(Arena*);
template<> ::JournalData::Progress_V1* Arena::CreateMaybeMessage<::JournalData::Progress_V1>(Arena*);
template<> ::JournalData::Progress_V2* Arena::CreateMaybeMessage<::JournalData::Progress_V2>(Arena*);
template<> ::JournalData::TagPlacementData* Arena::CreateMaybeMessage<::JournalData::TagPlacementData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace JournalData {

enum Progress_V1_ProgressMode : int {
  Progress_V1_ProgressMode_Failed = 0,
  Progress_V1_ProgressMode_Converting = 1,
  Progress_V1_ProgressMode_Uploading = 2,
  Progress_V1_ProgressMode_Downloading = 3,
  Progress_V1_ProgressMode_Decrypting = 4,
  Progress_V1_ProgressMode_Finished = 5,
  Progress_V1_ProgressMode_Waiting = 6,
  Progress_V1_ProgressMode_Processing = 7,
  Progress_V1_ProgressMode_Loading = 8,
  Progress_V1_ProgressMode_Fetching = 9,
  Progress_V1_ProgressMode_Building = 10,
  Progress_V1_ProgressMode_Progress_V1_ProgressMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Progress_V1_ProgressMode_Progress_V1_ProgressMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Progress_V1_ProgressMode_IsValid(int value);
constexpr Progress_V1_ProgressMode Progress_V1_ProgressMode_ProgressMode_MIN = Progress_V1_ProgressMode_Failed;
constexpr Progress_V1_ProgressMode Progress_V1_ProgressMode_ProgressMode_MAX = Progress_V1_ProgressMode_Building;
constexpr int Progress_V1_ProgressMode_ProgressMode_ARRAYSIZE = Progress_V1_ProgressMode_ProgressMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Progress_V1_ProgressMode_descriptor();
template<typename T>
inline const std::string& Progress_V1_ProgressMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Progress_V1_ProgressMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Progress_V1_ProgressMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Progress_V1_ProgressMode_descriptor(), enum_t_value);
}
inline bool Progress_V1_ProgressMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Progress_V1_ProgressMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Progress_V1_ProgressMode>(
    Progress_V1_ProgressMode_descriptor(), name, value);
}
enum ChatMessageSourceTypeEnum : int {
  Chat = 0,
  Transcription = 1,
  ChatMessageSourceTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMessageSourceTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatMessageSourceTypeEnum_IsValid(int value);
constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MIN = Chat;
constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MAX = Transcription;
constexpr int ChatMessageSourceTypeEnum_ARRAYSIZE = ChatMessageSourceTypeEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMessageSourceTypeEnum_descriptor();
template<typename T>
inline const std::string& ChatMessageSourceTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessageSourceTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessageSourceTypeEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMessageSourceTypeEnum_descriptor(), enum_t_value);
}
inline bool ChatMessageSourceTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessageSourceTypeEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMessageSourceTypeEnum>(
    ChatMessageSourceTypeEnum_descriptor(), name, value);
}
// ===================================================================

class ObjectId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectId) */ {
 public:
  inline ObjectId() : ObjectId(nullptr) {}
  ~ObjectId() override;
  explicit PROTOBUF_CONSTEXPR ObjectId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectId(const ObjectId& from);
  ObjectId(ObjectId&& from) noexcept
    : ObjectId() {
    *this = ::std::move(from);
  }

  inline ObjectId& operator=(const ObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectId& operator=(ObjectId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectId* internal_default_instance() {
    return reinterpret_cast<const ObjectId*>(
               &_ObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ObjectId& a, ObjectId& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectId& from) {
    ObjectId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectId";
  }
  protected:
  explicit ObjectId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjIdFieldNumber = 1,
    kComponentFieldNumber = 2,
  };
  // string objId = 1;
  void clear_objid();
  const std::string& objid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_objid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_objid();
  PROTOBUF_NODISCARD std::string* release_objid();
  void set_allocated_objid(std::string* objid);
  private:
  const std::string& _internal_objid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_objid(const std::string& value);
  std::string* _internal_mutable_objid();
  public:

  // string component = 2;
  void clear_component();
  const std::string& component() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component();
  PROTOBUF_NODISCARD std::string* release_component();
  void set_allocated_component(std::string* component);
  private:
  const std::string& _internal_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component(const std::string& value);
  std::string* _internal_mutable_component();
  public:

  // @@protoc_insertion_point(class_scope:JournalData.ObjectId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class BoardState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.BoardState) */ {
 public:
  inline BoardState() : BoardState(nullptr) {}
  ~BoardState() override;
  explicit PROTOBUF_CONSTEXPR BoardState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoardState(const BoardState& from);
  BoardState(BoardState&& from) noexcept
    : BoardState() {
    *this = ::std::move(from);
  }

  inline BoardState& operator=(const BoardState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoardState& operator=(BoardState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoardState& default_instance() {
    return *internal_default_instance();
  }
  enum StateTypeCase {
    kFrame = 1,
    kFrameStart = 2,
    kSource = 3,
    STATETYPE_NOT_SET = 0,
  };

  static inline const BoardState* internal_default_instance() {
    return reinterpret_cast<const BoardState*>(
               &_BoardState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BoardState& a, BoardState& b) {
    a.Swap(&b);
  }
  inline void Swap(BoardState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoardState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoardState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoardState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoardState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoardState& from) {
    BoardState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoardState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.BoardState";
  }
  protected:
  explicit BoardState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
    kFrameStartFieldNumber = 2,
    kSourceFieldNumber = 3,
  };
  // sint32 frame = 1;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  int32_t frame() const;
  void set_frame(int32_t value);
  private:
  int32_t _internal_frame() const;
  void _internal_set_frame(int32_t value);
  public:

  // sint32 frameStart = 2;
  bool has_framestart() const;
  private:
  bool _internal_has_framestart() const;
  public:
  void clear_framestart();
  int32_t framestart() const;
  void set_framestart(int32_t value);
  private:
  int32_t _internal_framestart() const;
  void _internal_set_framestart(int32_t value);
  public:

  // string source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  void clear_StateType();
  StateTypeCase StateType_case() const;
  // @@protoc_insertion_point(class_scope:JournalData.BoardState)
 private:
  class _Internal;
  void set_has_frame();
  void set_has_framestart();
  void set_has_source();

  inline bool has_StateType() const;
  inline void clear_has_StateType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StateTypeUnion {
      constexpr StateTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t frame_;
      int32_t framestart_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    } StateType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class Progress_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.Progress.V1) */ {
 public:
  inline Progress_V1() : Progress_V1(nullptr) {}
  ~Progress_V1() override;
  explicit PROTOBUF_CONSTEXPR Progress_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Progress_V1(const Progress_V1& from);
  Progress_V1(Progress_V1&& from) noexcept
    : Progress_V1() {
    *this = ::std::move(from);
  }

  inline Progress_V1& operator=(const Progress_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline Progress_V1& operator=(Progress_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Progress_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const Progress_V1* internal_default_instance() {
    return reinterpret_cast<const Progress_V1*>(
               &_Progress_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Progress_V1& a, Progress_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(Progress_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Progress_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Progress_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Progress_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Progress_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Progress_V1& from) {
    Progress_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Progress_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.Progress.V1";
  }
  protected:
  explicit Progress_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Progress_V1_ProgressMode ProgressMode;
  static constexpr ProgressMode Failed =
    Progress_V1_ProgressMode_Failed;
  static constexpr ProgressMode Converting =
    Progress_V1_ProgressMode_Converting;
  static constexpr ProgressMode Uploading =
    Progress_V1_ProgressMode_Uploading;
  static constexpr ProgressMode Downloading =
    Progress_V1_ProgressMode_Downloading;
  static constexpr ProgressMode Decrypting =
    Progress_V1_ProgressMode_Decrypting;
  static constexpr ProgressMode Finished =
    Progress_V1_ProgressMode_Finished;
  static constexpr ProgressMode Waiting =
    Progress_V1_ProgressMode_Waiting;
  static constexpr ProgressMode Processing =
    Progress_V1_ProgressMode_Processing;
  static constexpr ProgressMode Loading =
    Progress_V1_ProgressMode_Loading;
  static constexpr ProgressMode Fetching =
    Progress_V1_ProgressMode_Fetching;
  static constexpr ProgressMode Building =
    Progress_V1_ProgressMode_Building;
  static inline bool ProgressMode_IsValid(int value) {
    return Progress_V1_ProgressMode_IsValid(value);
  }
  static constexpr ProgressMode ProgressMode_MIN =
    Progress_V1_ProgressMode_ProgressMode_MIN;
  static constexpr ProgressMode ProgressMode_MAX =
    Progress_V1_ProgressMode_ProgressMode_MAX;
  static constexpr int ProgressMode_ARRAYSIZE =
    Progress_V1_ProgressMode_ProgressMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProgressMode_descriptor() {
    return Progress_V1_ProgressMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ProgressMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProgressMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProgressMode_Name.");
    return Progress_V1_ProgressMode_Name(enum_t_value);
  }
  static inline bool ProgressMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProgressMode* value) {
    return Progress_V1_ProgressMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProgressModeFieldNumber = 1,
    kProgressPercentageFieldNumber = 2,
  };
  // .JournalData.Progress.V1.ProgressMode progressMode = 1;
  void clear_progressmode();
  ::JournalData::Progress_V1_ProgressMode progressmode() const;
  void set_progressmode(::JournalData::Progress_V1_ProgressMode value);
  private:
  ::JournalData::Progress_V1_ProgressMode _internal_progressmode() const;
  void _internal_set_progressmode(::JournalData::Progress_V1_ProgressMode value);
  public:

  // float progressPercentage = 2;
  void clear_progresspercentage();
  float progresspercentage() const;
  void set_progresspercentage(float value);
  private:
  float _internal_progresspercentage() const;
  void _internal_set_progresspercentage(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.Progress.V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int progressmode_;
    float progresspercentage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class Progress_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.Progress.V2) */ {
 public:
  inline Progress_V2() : Progress_V2(nullptr) {}
  ~Progress_V2() override;
  explicit PROTOBUF_CONSTEXPR Progress_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Progress_V2(const Progress_V2& from);
  Progress_V2(Progress_V2&& from) noexcept
    : Progress_V2() {
    *this = ::std::move(from);
  }

  inline Progress_V2& operator=(const Progress_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Progress_V2& operator=(Progress_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Progress_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Progress_V2* internal_default_instance() {
    return reinterpret_cast<const Progress_V2*>(
               &_Progress_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Progress_V2& a, Progress_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(Progress_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Progress_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Progress_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Progress_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Progress_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Progress_V2& from) {
    Progress_V2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Progress_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.Progress.V2";
  }
  protected:
  explicit Progress_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStackFieldNumber = 1,
    kCurrentDescriptionFieldNumber = 2,
    kTaskProgressFieldNumber = 3,
    kOverallProgressFieldNumber = 4,
  };
  // repeated string taskStack = 1;
  int taskstack_size() const;
  private:
  int _internal_taskstack_size() const;
  public:
  void clear_taskstack();
  const std::string& taskstack(int index) const;
  std::string* mutable_taskstack(int index);
  void set_taskstack(int index, const std::string& value);
  void set_taskstack(int index, std::string&& value);
  void set_taskstack(int index, const char* value);
  void set_taskstack(int index, const char* value, size_t size);
  std::string* add_taskstack();
  void add_taskstack(const std::string& value);
  void add_taskstack(std::string&& value);
  void add_taskstack(const char* value);
  void add_taskstack(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& taskstack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_taskstack();
  private:
  const std::string& _internal_taskstack(int index) const;
  std::string* _internal_add_taskstack();
  public:

  // string currentDescription = 2;
  void clear_currentdescription();
  const std::string& currentdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currentdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currentdescription();
  PROTOBUF_NODISCARD std::string* release_currentdescription();
  void set_allocated_currentdescription(std::string* currentdescription);
  private:
  const std::string& _internal_currentdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currentdescription(const std::string& value);
  std::string* _internal_mutable_currentdescription();
  public:

  // float taskProgress = 3;
  void clear_taskprogress();
  float taskprogress() const;
  void set_taskprogress(float value);
  private:
  float _internal_taskprogress() const;
  void _internal_set_taskprogress(float value);
  public:

  // float overallProgress = 4;
  void clear_overallprogress();
  float overallprogress() const;
  void set_overallprogress(float value);
  private:
  float _internal_overallprogress() const;
  void _internal_set_overallprogress(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.Progress.V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> taskstack_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currentdescription_;
    float taskprogress_;
    float overallprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class Progress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.Progress) */ {
 public:
  inline Progress() : Progress(nullptr) {}
  ~Progress() override;
  explicit PROTOBUF_CONSTEXPR Progress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Progress(const Progress& from);
  Progress(Progress&& from) noexcept
    : Progress() {
    *this = ::std::move(from);
  }

  inline Progress& operator=(const Progress& from) {
    CopyFrom(from);
    return *this;
  }
  inline Progress& operator=(Progress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Progress& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    kV2 = 2,
    V_NOT_SET = 0,
  };

  static inline const Progress* internal_default_instance() {
    return reinterpret_cast<const Progress*>(
               &_Progress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Progress& a, Progress& b) {
    a.Swap(&b);
  }
  inline void Swap(Progress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Progress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Progress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Progress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Progress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Progress& from) {
    Progress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Progress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.Progress";
  }
  protected:
  explicit Progress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Progress_V1 V1;
  typedef Progress_V2 V2;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
    kV2FieldNumber = 2,
  };
  // .JournalData.Progress.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::JournalData::Progress_V1& v1() const;
  PROTOBUF_NODISCARD ::JournalData::Progress_V1* release_v1();
  ::JournalData::Progress_V1* mutable_v1();
  void set_allocated_v1(::JournalData::Progress_V1* v1);
  private:
  const ::JournalData::Progress_V1& _internal_v1() const;
  ::JournalData::Progress_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::JournalData::Progress_V1* v1);
  ::JournalData::Progress_V1* unsafe_arena_release_v1();

  // .JournalData.Progress.V2 v2 = 2;
  bool has_v2() const;
  private:
  bool _internal_has_v2() const;
  public:
  void clear_v2();
  const ::JournalData::Progress_V2& v2() const;
  PROTOBUF_NODISCARD ::JournalData::Progress_V2* release_v2();
  ::JournalData::Progress_V2* mutable_v2();
  void set_allocated_v2(::JournalData::Progress_V2* v2);
  private:
  const ::JournalData::Progress_V2& _internal_v2() const;
  ::JournalData::Progress_V2* _internal_mutable_v2();
  public:
  void unsafe_arena_set_allocated_v2(
      ::JournalData::Progress_V2* v2);
  ::JournalData::Progress_V2* unsafe_arena_release_v2();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:JournalData.Progress)
 private:
  class _Internal;
  void set_has_v1();
  void set_has_v2();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::JournalData::Progress_V1* v1_;
      ::JournalData::Progress_V2* v2_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType_StreamBoardObjectType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType.StreamBoardObjectType) */ {
 public:
  inline ObjectType_StreamBoardObjectType() : ObjectType_StreamBoardObjectType(nullptr) {}
  ~ObjectType_StreamBoardObjectType() override;
  explicit PROTOBUF_CONSTEXPR ObjectType_StreamBoardObjectType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType_StreamBoardObjectType(const ObjectType_StreamBoardObjectType& from);
  ObjectType_StreamBoardObjectType(ObjectType_StreamBoardObjectType&& from) noexcept
    : ObjectType_StreamBoardObjectType() {
    *this = ::std::move(from);
  }

  inline ObjectType_StreamBoardObjectType& operator=(const ObjectType_StreamBoardObjectType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType_StreamBoardObjectType& operator=(ObjectType_StreamBoardObjectType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType_StreamBoardObjectType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectType_StreamBoardObjectType* internal_default_instance() {
    return reinterpret_cast<const ObjectType_StreamBoardObjectType*>(
               &_ObjectType_StreamBoardObjectType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ObjectType_StreamBoardObjectType& a, ObjectType_StreamBoardObjectType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType_StreamBoardObjectType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType_StreamBoardObjectType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType_StreamBoardObjectType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType_StreamBoardObjectType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType_StreamBoardObjectType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType_StreamBoardObjectType& from) {
    ObjectType_StreamBoardObjectType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType_StreamBoardObjectType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType.StreamBoardObjectType";
  }
  protected:
  explicit ObjectType_StreamBoardObjectType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string connectionId = 1;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:JournalData.ObjectType.StreamBoardObjectType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType_TextBoardObjectType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType.TextBoardObjectType) */ {
 public:
  inline ObjectType_TextBoardObjectType() : ObjectType_TextBoardObjectType(nullptr) {}
  ~ObjectType_TextBoardObjectType() override;
  explicit PROTOBUF_CONSTEXPR ObjectType_TextBoardObjectType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType_TextBoardObjectType(const ObjectType_TextBoardObjectType& from);
  ObjectType_TextBoardObjectType(ObjectType_TextBoardObjectType&& from) noexcept
    : ObjectType_TextBoardObjectType() {
    *this = ::std::move(from);
  }

  inline ObjectType_TextBoardObjectType& operator=(const ObjectType_TextBoardObjectType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType_TextBoardObjectType& operator=(ObjectType_TextBoardObjectType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType_TextBoardObjectType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectType_TextBoardObjectType* internal_default_instance() {
    return reinterpret_cast<const ObjectType_TextBoardObjectType*>(
               &_ObjectType_TextBoardObjectType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ObjectType_TextBoardObjectType& a, ObjectType_TextBoardObjectType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType_TextBoardObjectType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType_TextBoardObjectType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType_TextBoardObjectType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType_TextBoardObjectType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType_TextBoardObjectType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType_TextBoardObjectType& from) {
    ObjectType_TextBoardObjectType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType_TextBoardObjectType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType.TextBoardObjectType";
  }
  protected:
  explicit ObjectType_TextBoardObjectType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialTextFieldNumber = 1,
    kTextboardFieldNumber = 2,
  };
  // string initialText = 1;
  void clear_initialtext();
  const std::string& initialtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initialtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initialtext();
  PROTOBUF_NODISCARD std::string* release_initialtext();
  void set_allocated_initialtext(std::string* initialtext);
  private:
  const std::string& _internal_initialtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initialtext(const std::string& value);
  std::string* _internal_mutable_initialtext();
  public:

  // .JournalData.BoardSizeData textboard = 2;
  bool has_textboard() const;
  private:
  bool _internal_has_textboard() const;
  public:
  void clear_textboard();
  const ::JournalData::BoardSizeData& textboard() const;
  PROTOBUF_NODISCARD ::JournalData::BoardSizeData* release_textboard();
  ::JournalData::BoardSizeData* mutable_textboard();
  void set_allocated_textboard(::JournalData::BoardSizeData* textboard);
  private:
  const ::JournalData::BoardSizeData& _internal_textboard() const;
  ::JournalData::BoardSizeData* _internal_mutable_textboard();
  public:
  void unsafe_arena_set_allocated_textboard(
      ::JournalData::BoardSizeData* textboard);
  ::JournalData::BoardSizeData* unsafe_arena_release_textboard();

  // @@protoc_insertion_point(class_scope:JournalData.ObjectType.TextBoardObjectType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initialtext_;
    ::JournalData::BoardSizeData* textboard_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType_ArTrackerObjectType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType.ArTrackerObjectType) */ {
 public:
  inline ObjectType_ArTrackerObjectType() : ObjectType_ArTrackerObjectType(nullptr) {}
  ~ObjectType_ArTrackerObjectType() override;
  explicit PROTOBUF_CONSTEXPR ObjectType_ArTrackerObjectType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType_ArTrackerObjectType(const ObjectType_ArTrackerObjectType& from);
  ObjectType_ArTrackerObjectType(ObjectType_ArTrackerObjectType&& from) noexcept
    : ObjectType_ArTrackerObjectType() {
    *this = ::std::move(from);
  }

  inline ObjectType_ArTrackerObjectType& operator=(const ObjectType_ArTrackerObjectType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType_ArTrackerObjectType& operator=(ObjectType_ArTrackerObjectType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType_ArTrackerObjectType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectType_ArTrackerObjectType* internal_default_instance() {
    return reinterpret_cast<const ObjectType_ArTrackerObjectType*>(
               &_ObjectType_ArTrackerObjectType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ObjectType_ArTrackerObjectType& a, ObjectType_ArTrackerObjectType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType_ArTrackerObjectType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType_ArTrackerObjectType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType_ArTrackerObjectType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType_ArTrackerObjectType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType_ArTrackerObjectType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType_ArTrackerObjectType& from) {
    ObjectType_ArTrackerObjectType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType_ArTrackerObjectType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType.ArTrackerObjectType";
  }
  protected:
  explicit ObjectType_ArTrackerObjectType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // @@protoc_insertion_point(class_scope:JournalData.ObjectType.ArTrackerObjectType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType_CustomContentId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType.CustomContentId) */ {
 public:
  inline ObjectType_CustomContentId() : ObjectType_CustomContentId(nullptr) {}
  ~ObjectType_CustomContentId() override;
  explicit PROTOBUF_CONSTEXPR ObjectType_CustomContentId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType_CustomContentId(const ObjectType_CustomContentId& from);
  ObjectType_CustomContentId(ObjectType_CustomContentId&& from) noexcept
    : ObjectType_CustomContentId() {
    *this = ::std::move(from);
  }

  inline ObjectType_CustomContentId& operator=(const ObjectType_CustomContentId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType_CustomContentId& operator=(ObjectType_CustomContentId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType_CustomContentId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectType_CustomContentId* internal_default_instance() {
    return reinterpret_cast<const ObjectType_CustomContentId*>(
               &_ObjectType_CustomContentId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObjectType_CustomContentId& a, ObjectType_CustomContentId& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType_CustomContentId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType_CustomContentId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType_CustomContentId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType_CustomContentId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType_CustomContentId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType_CustomContentId& from) {
    ObjectType_CustomContentId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType_CustomContentId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType.CustomContentId";
  }
  protected:
  explicit ObjectType_CustomContentId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomSourceIdFieldNumber = 1,
    kCustomContentIdFieldNumber = 2,
  };
  // string customSourceId = 1;
  void clear_customsourceid();
  const std::string& customsourceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customsourceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customsourceid();
  PROTOBUF_NODISCARD std::string* release_customsourceid();
  void set_allocated_customsourceid(std::string* customsourceid);
  private:
  const std::string& _internal_customsourceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customsourceid(const std::string& value);
  std::string* _internal_mutable_customsourceid();
  public:

  // string customContentId = 2;
  void clear_customcontentid();
  const std::string& customcontentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customcontentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customcontentid();
  PROTOBUF_NODISCARD std::string* release_customcontentid();
  void set_allocated_customcontentid(std::string* customcontentid);
  private:
  const std::string& _internal_customcontentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customcontentid(const std::string& value);
  std::string* _internal_mutable_customcontentid();
  public:

  // @@protoc_insertion_point(class_scope:JournalData.ObjectType.CustomContentId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customsourceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customcontentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType_ChatMessageObjectType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType.ChatMessageObjectType) */ {
 public:
  inline ObjectType_ChatMessageObjectType() : ObjectType_ChatMessageObjectType(nullptr) {}
  ~ObjectType_ChatMessageObjectType() override;
  explicit PROTOBUF_CONSTEXPR ObjectType_ChatMessageObjectType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType_ChatMessageObjectType(const ObjectType_ChatMessageObjectType& from);
  ObjectType_ChatMessageObjectType(ObjectType_ChatMessageObjectType&& from) noexcept
    : ObjectType_ChatMessageObjectType() {
    *this = ::std::move(from);
  }

  inline ObjectType_ChatMessageObjectType& operator=(const ObjectType_ChatMessageObjectType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType_ChatMessageObjectType& operator=(ObjectType_ChatMessageObjectType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType_ChatMessageObjectType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectType_ChatMessageObjectType* internal_default_instance() {
    return reinterpret_cast<const ObjectType_ChatMessageObjectType*>(
               &_ObjectType_ChatMessageObjectType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObjectType_ChatMessageObjectType& a, ObjectType_ChatMessageObjectType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType_ChatMessageObjectType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType_ChatMessageObjectType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType_ChatMessageObjectType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType_ChatMessageObjectType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType_ChatMessageObjectType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType_ChatMessageObjectType& from) {
    ObjectType_ChatMessageObjectType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType_ChatMessageObjectType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType.ChatMessageObjectType";
  }
  protected:
  explicit ObjectType_ChatMessageObjectType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialTextFieldNumber = 1,
    kCreatorIdFieldNumber = 3,
    kTimeCreatedFieldNumber = 2,
    kSourceTypeFieldNumber = 4,
  };
  // string initialText = 1;
  void clear_initialtext();
  const std::string& initialtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initialtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initialtext();
  PROTOBUF_NODISCARD std::string* release_initialtext();
  void set_allocated_initialtext(std::string* initialtext);
  private:
  const std::string& _internal_initialtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initialtext(const std::string& value);
  std::string* _internal_mutable_initialtext();
  public:

  // optional string creatorId = 3;
  bool has_creatorid() const;
  private:
  bool _internal_has_creatorid() const;
  public:
  void clear_creatorid();
  const std::string& creatorid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorid();
  PROTOBUF_NODISCARD std::string* release_creatorid();
  void set_allocated_creatorid(std::string* creatorid);
  private:
  const std::string& _internal_creatorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorid(const std::string& value);
  std::string* _internal_mutable_creatorid();
  public:

  // .google.protobuf.Timestamp timeCreated = 2;
  bool has_timecreated() const;
  private:
  bool _internal_has_timecreated() const;
  public:
  void clear_timecreated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timecreated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timecreated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timecreated();
  void set_allocated_timecreated(::PROTOBUF_NAMESPACE_ID::Timestamp* timecreated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timecreated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timecreated();
  public:
  void unsafe_arena_set_allocated_timecreated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timecreated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timecreated();

  // optional .JournalData.ChatMessageSourceTypeEnum sourceType = 4;
  bool has_sourcetype() const;
  private:
  bool _internal_has_sourcetype() const;
  public:
  void clear_sourcetype();
  ::JournalData::ChatMessageSourceTypeEnum sourcetype() const;
  void set_sourcetype(::JournalData::ChatMessageSourceTypeEnum value);
  private:
  ::JournalData::ChatMessageSourceTypeEnum _internal_sourcetype() const;
  void _internal_set_sourcetype(::JournalData::ChatMessageSourceTypeEnum value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.ObjectType.ChatMessageObjectType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initialtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timecreated_;
    int sourcetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectType) */ {
 public:
  inline ObjectType() : ObjectType(nullptr) {}
  ~ObjectType() override;
  explicit PROTOBUF_CONSTEXPR ObjectType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectType(const ObjectType& from);
  ObjectType(ObjectType&& from) noexcept
    : ObjectType() {
    *this = ::std::move(from);
  }

  inline ObjectType& operator=(const ObjectType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectType& operator=(ObjectType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectType& default_instance() {
    return *internal_default_instance();
  }
  enum ObCase {
    kContentId = 1,
    kWhiteboard = 2,
    kStreamBoardOwner = 3,
    kUserBoard = 6,
    kObjectProgress = 7,
    kBoardProgress = 8,
    kTextboard = 10,
    kArTracker = 15,
    kContentIdAsset = 20,
    kCustomContentId = 21,
    kChatMessage = 50,
    kBlankMaterial = 100,
    kWellKnownObjectId = 500,
    kUrl = 501,
    OB_NOT_SET = 0,
  };

  static inline const ObjectType* internal_default_instance() {
    return reinterpret_cast<const ObjectType*>(
               &_ObjectType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObjectType& a, ObjectType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectType& from) {
    ObjectType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectType";
  }
  protected:
  explicit ObjectType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectType_StreamBoardObjectType StreamBoardObjectType;
  typedef ObjectType_TextBoardObjectType TextBoardObjectType;
  typedef ObjectType_ArTrackerObjectType ArTrackerObjectType;
  typedef ObjectType_CustomContentId CustomContentId;
  typedef ObjectType_ChatMessageObjectType ChatMessageObjectType;

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kWhiteboardFieldNumber = 2,
    kStreamBoardOwnerFieldNumber = 3,
    kUserBoardFieldNumber = 6,
    kObjectProgressFieldNumber = 7,
    kBoardProgressFieldNumber = 8,
    kTextboardFieldNumber = 10,
    kArTrackerFieldNumber = 15,
    kContentIdAssetFieldNumber = 20,
    kCustomContentIdFieldNumber = 21,
    kChatMessageFieldNumber = 50,
    kBlankMaterialFieldNumber = 100,
    kWellKnownObjectIdFieldNumber = 500,
    kUrlFieldNumber = 501,
  };
  // string contentId = 1;
  bool has_contentid() const;
  private:
  bool _internal_has_contentid() const;
  public:
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // .JournalData.BoardSizeData whiteboard = 2;
  bool has_whiteboard() const;
  private:
  bool _internal_has_whiteboard() const;
  public:
  void clear_whiteboard();
  const ::JournalData::BoardSizeData& whiteboard() const;
  PROTOBUF_NODISCARD ::JournalData::BoardSizeData* release_whiteboard();
  ::JournalData::BoardSizeData* mutable_whiteboard();
  void set_allocated_whiteboard(::JournalData::BoardSizeData* whiteboard);
  private:
  const ::JournalData::BoardSizeData& _internal_whiteboard() const;
  ::JournalData::BoardSizeData* _internal_mutable_whiteboard();
  public:
  void unsafe_arena_set_allocated_whiteboard(
      ::JournalData::BoardSizeData* whiteboard);
  ::JournalData::BoardSizeData* unsafe_arena_release_whiteboard();

  // .JournalData.ObjectType.StreamBoardObjectType streamBoardOwner = 3;
  bool has_streamboardowner() const;
  private:
  bool _internal_has_streamboardowner() const;
  public:
  void clear_streamboardowner();
  const ::JournalData::ObjectType_StreamBoardObjectType& streamboardowner() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectType_StreamBoardObjectType* release_streamboardowner();
  ::JournalData::ObjectType_StreamBoardObjectType* mutable_streamboardowner();
  void set_allocated_streamboardowner(::JournalData::ObjectType_StreamBoardObjectType* streamboardowner);
  private:
  const ::JournalData::ObjectType_StreamBoardObjectType& _internal_streamboardowner() const;
  ::JournalData::ObjectType_StreamBoardObjectType* _internal_mutable_streamboardowner();
  public:
  void unsafe_arena_set_allocated_streamboardowner(
      ::JournalData::ObjectType_StreamBoardObjectType* streamboardowner);
  ::JournalData::ObjectType_StreamBoardObjectType* unsafe_arena_release_streamboardowner();

  // bool userBoard = 6;
  bool has_userboard() const;
  private:
  bool _internal_has_userboard() const;
  public:
  void clear_userboard();
  bool userboard() const;
  void set_userboard(bool value);
  private:
  bool _internal_userboard() const;
  void _internal_set_userboard(bool value);
  public:

  // .JournalData.Progress objectProgress = 7;
  bool has_objectprogress() const;
  private:
  bool _internal_has_objectprogress() const;
  public:
  void clear_objectprogress();
  const ::JournalData::Progress& objectprogress() const;
  PROTOBUF_NODISCARD ::JournalData::Progress* release_objectprogress();
  ::JournalData::Progress* mutable_objectprogress();
  void set_allocated_objectprogress(::JournalData::Progress* objectprogress);
  private:
  const ::JournalData::Progress& _internal_objectprogress() const;
  ::JournalData::Progress* _internal_mutable_objectprogress();
  public:
  void unsafe_arena_set_allocated_objectprogress(
      ::JournalData::Progress* objectprogress);
  ::JournalData::Progress* unsafe_arena_release_objectprogress();

  // .JournalData.Progress boardProgress = 8;
  bool has_boardprogress() const;
  private:
  bool _internal_has_boardprogress() const;
  public:
  void clear_boardprogress();
  const ::JournalData::Progress& boardprogress() const;
  PROTOBUF_NODISCARD ::JournalData::Progress* release_boardprogress();
  ::JournalData::Progress* mutable_boardprogress();
  void set_allocated_boardprogress(::JournalData::Progress* boardprogress);
  private:
  const ::JournalData::Progress& _internal_boardprogress() const;
  ::JournalData::Progress* _internal_mutable_boardprogress();
  public:
  void unsafe_arena_set_allocated_boardprogress(
      ::JournalData::Progress* boardprogress);
  ::JournalData::Progress* unsafe_arena_release_boardprogress();

  // .JournalData.ObjectType.TextBoardObjectType textboard = 10;
  bool has_textboard() const;
  private:
  bool _internal_has_textboard() const;
  public:
  void clear_textboard();
  const ::JournalData::ObjectType_TextBoardObjectType& textboard() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectType_TextBoardObjectType* release_textboard();
  ::JournalData::ObjectType_TextBoardObjectType* mutable_textboard();
  void set_allocated_textboard(::JournalData::ObjectType_TextBoardObjectType* textboard);
  private:
  const ::JournalData::ObjectType_TextBoardObjectType& _internal_textboard() const;
  ::JournalData::ObjectType_TextBoardObjectType* _internal_mutable_textboard();
  public:
  void unsafe_arena_set_allocated_textboard(
      ::JournalData::ObjectType_TextBoardObjectType* textboard);
  ::JournalData::ObjectType_TextBoardObjectType* unsafe_arena_release_textboard();

  // .JournalData.ObjectType.ArTrackerObjectType arTracker = 15;
  bool has_artracker() const;
  private:
  bool _internal_has_artracker() const;
  public:
  void clear_artracker();
  const ::JournalData::ObjectType_ArTrackerObjectType& artracker() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectType_ArTrackerObjectType* release_artracker();
  ::JournalData::ObjectType_ArTrackerObjectType* mutable_artracker();
  void set_allocated_artracker(::JournalData::ObjectType_ArTrackerObjectType* artracker);
  private:
  const ::JournalData::ObjectType_ArTrackerObjectType& _internal_artracker() const;
  ::JournalData::ObjectType_ArTrackerObjectType* _internal_mutable_artracker();
  public:
  void unsafe_arena_set_allocated_artracker(
      ::JournalData::ObjectType_ArTrackerObjectType* artracker);
  ::JournalData::ObjectType_ArTrackerObjectType* unsafe_arena_release_artracker();

  // string contentIdAsset = 20;
  bool has_contentidasset() const;
  private:
  bool _internal_has_contentidasset() const;
  public:
  void clear_contentidasset();
  const std::string& contentidasset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentidasset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentidasset();
  PROTOBUF_NODISCARD std::string* release_contentidasset();
  void set_allocated_contentidasset(std::string* contentidasset);
  private:
  const std::string& _internal_contentidasset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentidasset(const std::string& value);
  std::string* _internal_mutable_contentidasset();
  public:

  // .JournalData.ObjectType.CustomContentId customContentId = 21;
  bool has_customcontentid() const;
  private:
  bool _internal_has_customcontentid() const;
  public:
  void clear_customcontentid();
  const ::JournalData::ObjectType_CustomContentId& customcontentid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectType_CustomContentId* release_customcontentid();
  ::JournalData::ObjectType_CustomContentId* mutable_customcontentid();
  void set_allocated_customcontentid(::JournalData::ObjectType_CustomContentId* customcontentid);
  private:
  const ::JournalData::ObjectType_CustomContentId& _internal_customcontentid() const;
  ::JournalData::ObjectType_CustomContentId* _internal_mutable_customcontentid();
  public:
  void unsafe_arena_set_allocated_customcontentid(
      ::JournalData::ObjectType_CustomContentId* customcontentid);
  ::JournalData::ObjectType_CustomContentId* unsafe_arena_release_customcontentid();

  // .JournalData.ObjectType.ChatMessageObjectType chatMessage = 50;
  bool has_chatmessage() const;
  private:
  bool _internal_has_chatmessage() const;
  public:
  void clear_chatmessage();
  const ::JournalData::ObjectType_ChatMessageObjectType& chatmessage() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectType_ChatMessageObjectType* release_chatmessage();
  ::JournalData::ObjectType_ChatMessageObjectType* mutable_chatmessage();
  void set_allocated_chatmessage(::JournalData::ObjectType_ChatMessageObjectType* chatmessage);
  private:
  const ::JournalData::ObjectType_ChatMessageObjectType& _internal_chatmessage() const;
  ::JournalData::ObjectType_ChatMessageObjectType* _internal_mutable_chatmessage();
  public:
  void unsafe_arena_set_allocated_chatmessage(
      ::JournalData::ObjectType_ChatMessageObjectType* chatmessage);
  ::JournalData::ObjectType_ChatMessageObjectType* unsafe_arena_release_chatmessage();

  // bool blankMaterial = 100;
  bool has_blankmaterial() const;
  private:
  bool _internal_has_blankmaterial() const;
  public:
  void clear_blankmaterial();
  bool blankmaterial() const;
  void set_blankmaterial(bool value);
  private:
  bool _internal_blankmaterial() const;
  void _internal_set_blankmaterial(bool value);
  public:

  // string wellKnownObjectId = 500;
  bool has_wellknownobjectid() const;
  private:
  bool _internal_has_wellknownobjectid() const;
  public:
  void clear_wellknownobjectid();
  const std::string& wellknownobjectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wellknownobjectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wellknownobjectid();
  PROTOBUF_NODISCARD std::string* release_wellknownobjectid();
  void set_allocated_wellknownobjectid(std::string* wellknownobjectid);
  private:
  const std::string& _internal_wellknownobjectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wellknownobjectid(const std::string& value);
  std::string* _internal_mutable_wellknownobjectid();
  public:

  // string url = 501;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  void clear_Ob();
  ObCase Ob_case() const;
  // @@protoc_insertion_point(class_scope:JournalData.ObjectType)
 private:
  class _Internal;
  void set_has_contentid();
  void set_has_whiteboard();
  void set_has_streamboardowner();
  void set_has_userboard();
  void set_has_objectprogress();
  void set_has_boardprogress();
  void set_has_textboard();
  void set_has_artracker();
  void set_has_contentidasset();
  void set_has_customcontentid();
  void set_has_chatmessage();
  void set_has_blankmaterial();
  void set_has_wellknownobjectid();
  void set_has_url();

  inline bool has_Ob() const;
  inline void clear_has_Ob();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ObUnion {
      constexpr ObUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
      ::JournalData::BoardSizeData* whiteboard_;
      ::JournalData::ObjectType_StreamBoardObjectType* streamboardowner_;
      bool userboard_;
      ::JournalData::Progress* objectprogress_;
      ::JournalData::Progress* boardprogress_;
      ::JournalData::ObjectType_TextBoardObjectType* textboard_;
      ::JournalData::ObjectType_ArTrackerObjectType* artracker_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentidasset_;
      ::JournalData::ObjectType_CustomContentId* customcontentid_;
      ::JournalData::ObjectType_ChatMessageObjectType* chatmessage_;
      bool blankmaterial_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wellknownobjectid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    } Ob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class BoardSizeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.BoardSizeData) */ {
 public:
  inline BoardSizeData() : BoardSizeData(nullptr) {}
  ~BoardSizeData() override;
  explicit PROTOBUF_CONSTEXPR BoardSizeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoardSizeData(const BoardSizeData& from);
  BoardSizeData(BoardSizeData&& from) noexcept
    : BoardSizeData() {
    *this = ::std::move(from);
  }

  inline BoardSizeData& operator=(const BoardSizeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoardSizeData& operator=(BoardSizeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoardSizeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoardSizeData* internal_default_instance() {
    return reinterpret_cast<const BoardSizeData*>(
               &_BoardSizeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BoardSizeData& a, BoardSizeData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoardSizeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoardSizeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoardSizeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoardSizeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoardSizeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoardSizeData& from) {
    BoardSizeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoardSizeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.BoardSizeData";
  }
  protected:
  explicit BoardSizeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAspectRatioFieldNumber = 1,
    kBoardSizeScalerFieldNumber = 2,
  };
  // .Common.Float2 aspectRatio = 1;
  bool has_aspectratio() const;
  private:
  bool _internal_has_aspectratio() const;
  public:
  void clear_aspectratio();
  const ::Common::Float2& aspectratio() const;
  PROTOBUF_NODISCARD ::Common::Float2* release_aspectratio();
  ::Common::Float2* mutable_aspectratio();
  void set_allocated_aspectratio(::Common::Float2* aspectratio);
  private:
  const ::Common::Float2& _internal_aspectratio() const;
  ::Common::Float2* _internal_mutable_aspectratio();
  public:
  void unsafe_arena_set_allocated_aspectratio(
      ::Common::Float2* aspectratio);
  ::Common::Float2* unsafe_arena_release_aspectratio();

  // float boardSizeScaler = 2;
  void clear_boardsizescaler();
  float boardsizescaler() const;
  void set_boardsizescaler(float value);
  private:
  float _internal_boardsizescaler() const;
  void _internal_set_boardsizescaler(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.BoardSizeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float2* aspectratio_;
    float boardsizescaler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ImageContentType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ImageContentType) */ {
 public:
  inline ImageContentType() : ImageContentType(nullptr) {}
  ~ImageContentType() override;
  explicit PROTOBUF_CONSTEXPR ImageContentType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageContentType(const ImageContentType& from);
  ImageContentType(ImageContentType&& from) noexcept
    : ImageContentType() {
    *this = ::std::move(from);
  }

  inline ImageContentType& operator=(const ImageContentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageContentType& operator=(ImageContentType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageContentType& default_instance() {
    return *internal_default_instance();
  }
  enum ImCase {
    kContentId = 1,
    kImageProgress = 2,
    IM_NOT_SET = 0,
  };

  static inline const ImageContentType* internal_default_instance() {
    return reinterpret_cast<const ImageContentType*>(
               &_ImageContentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ImageContentType& a, ImageContentType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageContentType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageContentType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageContentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageContentType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageContentType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageContentType& from) {
    ImageContentType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageContentType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ImageContentType";
  }
  protected:
  explicit ImageContentType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kImageProgressFieldNumber = 2,
  };
  // string contentId = 1;
  bool has_contentid() const;
  private:
  bool _internal_has_contentid() const;
  public:
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // .JournalData.Progress imageProgress = 2;
  bool has_imageprogress() const;
  private:
  bool _internal_has_imageprogress() const;
  public:
  void clear_imageprogress();
  const ::JournalData::Progress& imageprogress() const;
  PROTOBUF_NODISCARD ::JournalData::Progress* release_imageprogress();
  ::JournalData::Progress* mutable_imageprogress();
  void set_allocated_imageprogress(::JournalData::Progress* imageprogress);
  private:
  const ::JournalData::Progress& _internal_imageprogress() const;
  ::JournalData::Progress* _internal_mutable_imageprogress();
  public:
  void unsafe_arena_set_allocated_imageprogress(
      ::JournalData::Progress* imageprogress);
  ::JournalData::Progress* unsafe_arena_release_imageprogress();

  void clear_Im();
  ImCase Im_case() const;
  // @@protoc_insertion_point(class_scope:JournalData.ImageContentType)
 private:
  class _Internal;
  void set_has_contentid();
  void set_has_imageprogress();

  inline bool has_Im() const;
  inline void clear_has_Im();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ImUnion {
      constexpr ImUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
      ::JournalData::Progress* imageprogress_;
    } Im_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class Image2dPlacementData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.Image2dPlacementData) */ {
 public:
  inline Image2dPlacementData() : Image2dPlacementData(nullptr) {}
  ~Image2dPlacementData() override;
  explicit PROTOBUF_CONSTEXPR Image2dPlacementData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image2dPlacementData(const Image2dPlacementData& from);
  Image2dPlacementData(Image2dPlacementData&& from) noexcept
    : Image2dPlacementData() {
    *this = ::std::move(from);
  }

  inline Image2dPlacementData& operator=(const Image2dPlacementData& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image2dPlacementData& operator=(Image2dPlacementData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image2dPlacementData& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image2dPlacementData* internal_default_instance() {
    return reinterpret_cast<const Image2dPlacementData*>(
               &_Image2dPlacementData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Image2dPlacementData& a, Image2dPlacementData& b) {
    a.Swap(&b);
  }
  inline void Swap(Image2dPlacementData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image2dPlacementData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image2dPlacementData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image2dPlacementData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image2dPlacementData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image2dPlacementData& from) {
    Image2dPlacementData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image2dPlacementData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.Image2dPlacementData";
  }
  protected:
  explicit Image2dPlacementData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kVisibleWithinStateFieldNumber = 2,
    kPointFieldNumber = 3,
    kHeightFieldNumber = 4,
    kRotationFieldNumber = 5,
  };
  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .JournalData.BoardState visibleWithinState = 2;
  bool has_visiblewithinstate() const;
  private:
  bool _internal_has_visiblewithinstate() const;
  public:
  void clear_visiblewithinstate();
  const ::JournalData::BoardState& visiblewithinstate() const;
  PROTOBUF_NODISCARD ::JournalData::BoardState* release_visiblewithinstate();
  ::JournalData::BoardState* mutable_visiblewithinstate();
  void set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate);
  private:
  const ::JournalData::BoardState& _internal_visiblewithinstate() const;
  ::JournalData::BoardState* _internal_mutable_visiblewithinstate();
  public:
  void unsafe_arena_set_allocated_visiblewithinstate(
      ::JournalData::BoardState* visiblewithinstate);
  ::JournalData::BoardState* unsafe_arena_release_visiblewithinstate();

  // .Common.Float2 point = 3;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::Common::Float2& point() const;
  PROTOBUF_NODISCARD ::Common::Float2* release_point();
  ::Common::Float2* mutable_point();
  void set_allocated_point(::Common::Float2* point);
  private:
  const ::Common::Float2& _internal_point() const;
  ::Common::Float2* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::Common::Float2* point);
  ::Common::Float2* unsafe_arena_release_point();

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float rotation = 5;
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.Image2dPlacementData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::JournalData::ObjectId* objectid_;
    ::JournalData::BoardState* visiblewithinstate_;
    ::Common::Float2* point_;
    float height_;
    float rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class TagPlacementData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.TagPlacementData) */ {
 public:
  inline TagPlacementData() : TagPlacementData(nullptr) {}
  ~TagPlacementData() override;
  explicit PROTOBUF_CONSTEXPR TagPlacementData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagPlacementData(const TagPlacementData& from);
  TagPlacementData(TagPlacementData&& from) noexcept
    : TagPlacementData() {
    *this = ::std::move(from);
  }

  inline TagPlacementData& operator=(const TagPlacementData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagPlacementData& operator=(TagPlacementData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagPlacementData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagPlacementData* internal_default_instance() {
    return reinterpret_cast<const TagPlacementData*>(
               &_TagPlacementData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TagPlacementData& a, TagPlacementData& b) {
    a.Swap(&b);
  }
  inline void Swap(TagPlacementData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagPlacementData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagPlacementData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagPlacementData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagPlacementData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TagPlacementData& from) {
    TagPlacementData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagPlacementData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.TagPlacementData";
  }
  protected:
  explicit TagPlacementData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAnchorPosFieldNumber = 2,
    kTagOffsetFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // .JournalData.ObjectId objectId = 1;
  bool has_objectid() const;
  private:
  bool _internal_has_objectid() const;
  public:
  void clear_objectid();
  const ::JournalData::ObjectId& objectid() const;
  PROTOBUF_NODISCARD ::JournalData::ObjectId* release_objectid();
  ::JournalData::ObjectId* mutable_objectid();
  void set_allocated_objectid(::JournalData::ObjectId* objectid);
  private:
  const ::JournalData::ObjectId& _internal_objectid() const;
  ::JournalData::ObjectId* _internal_mutable_objectid();
  public:
  void unsafe_arena_set_allocated_objectid(
      ::JournalData::ObjectId* objectid);
  ::JournalData::ObjectId* unsafe_arena_release_objectid();

  // .Common.Float3 anchorPos = 2;
  bool has_anchorpos() const;
  private:
  bool _internal_has_anchorpos() const;
  public:
  void clear_anchorpos();
  const ::Common::Float3& anchorpos() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_anchorpos();
  ::Common::Float3* mutable_anchorpos();
  void set_allocated_anchorpos(::Common::Float3* anchorpos);
  private:
  const ::Common::Float3& _internal_anchorpos() const;
  ::Common::Float3* _internal_mutable_anchorpos();
  public:
  void unsafe_arena_set_allocated_anchorpos(
      ::Common::Float3* anchorpos);
  ::Common::Float3* unsafe_arena_release_anchorpos();

  // .Common.Float3 tagOffset = 3;
  bool has_tagoffset() const;
  private:
  bool _internal_has_tagoffset() const;
  public:
  void clear_tagoffset();
  const ::Common::Float3& tagoffset() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_tagoffset();
  ::Common::Float3* mutable_tagoffset();
  void set_allocated_tagoffset(::Common::Float3* tagoffset);
  private:
  const ::Common::Float3& _internal_tagoffset() const;
  ::Common::Float3* _internal_mutable_tagoffset();
  public:
  void unsafe_arena_set_allocated_tagoffset(
      ::Common::Float3* tagoffset);
  ::Common::Float3* unsafe_arena_release_tagoffset();

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.TagPlacementData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::JournalData::ObjectId* objectid_;
    ::Common::Float3* anchorpos_;
    ::Common::Float3* tagoffset_;
    float height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class ObjectPlacementData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.ObjectPlacementData) */ {
 public:
  inline ObjectPlacementData() : ObjectPlacementData(nullptr) {}
  ~ObjectPlacementData() override;
  explicit PROTOBUF_CONSTEXPR ObjectPlacementData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectPlacementData(const ObjectPlacementData& from);
  ObjectPlacementData(ObjectPlacementData&& from) noexcept
    : ObjectPlacementData() {
    *this = ::std::move(from);
  }

  inline ObjectPlacementData& operator=(const ObjectPlacementData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectPlacementData& operator=(ObjectPlacementData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectPlacementData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectPlacementData* internal_default_instance() {
    return reinterpret_cast<const ObjectPlacementData*>(
               &_ObjectPlacementData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ObjectPlacementData& a, ObjectPlacementData& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectPlacementData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectPlacementData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectPlacementData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectPlacementData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectPlacementData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectPlacementData& from) {
    ObjectPlacementData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectPlacementData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.ObjectPlacementData";
  }
  protected:
  explicit ObjectPlacementData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kScaleFieldNumber = 3,
  };
  // .Common.Float3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Common::Float3& position() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_position();
  ::Common::Float3* mutable_position();
  void set_allocated_position(::Common::Float3* position);
  private:
  const ::Common::Float3& _internal_position() const;
  ::Common::Float3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Common::Float3* position);
  ::Common::Float3* unsafe_arena_release_position();

  // .Common.Float3 rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Common::Float3& rotation() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_rotation();
  ::Common::Float3* mutable_rotation();
  void set_allocated_rotation(::Common::Float3* rotation);
  private:
  const ::Common::Float3& _internal_rotation() const;
  ::Common::Float3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Common::Float3* rotation);
  ::Common::Float3* unsafe_arena_release_rotation();

  // .Common.Float3 scale = 3;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::Common::Float3& scale() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_scale();
  ::Common::Float3* mutable_scale();
  void set_allocated_scale(::Common::Float3* scale);
  private:
  const ::Common::Float3& _internal_scale() const;
  ::Common::Float3* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::Common::Float3* scale);
  ::Common::Float3* unsafe_arena_release_scale();

  // @@protoc_insertion_point(class_scope:JournalData.ObjectPlacementData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float3* position_;
    ::Common::Float3* rotation_;
    ::Common::Float3* scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class PartHighlightData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.PartHighlightData) */ {
 public:
  inline PartHighlightData() : PartHighlightData(nullptr) {}
  ~PartHighlightData() override;
  explicit PROTOBUF_CONSTEXPR PartHighlightData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartHighlightData(const PartHighlightData& from);
  PartHighlightData(PartHighlightData&& from) noexcept
    : PartHighlightData() {
    *this = ::std::move(from);
  }

  inline PartHighlightData& operator=(const PartHighlightData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartHighlightData& operator=(PartHighlightData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartHighlightData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartHighlightData* internal_default_instance() {
    return reinterpret_cast<const PartHighlightData*>(
               &_PartHighlightData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PartHighlightData& a, PartHighlightData& b) {
    a.Swap(&b);
  }
  inline void Swap(PartHighlightData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartHighlightData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartHighlightData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartHighlightData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartHighlightData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartHighlightData& from) {
    PartHighlightData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartHighlightData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.PartHighlightData";
  }
  protected:
  explicit PartHighlightData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimaryColorFieldNumber = 3,
    kSecondaryColorFieldNumber = 4,
    kSpreadFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kCoverageFieldNumber = 7,
    kEdgingFieldNumber = 8,
    kRiseTimeFieldNumber = 9,
    kHoldTimeFieldNumber = 10,
    kFallTimeFieldNumber = 11,
  };
  // .Common.Color4 primaryColor = 3;
  bool has_primarycolor() const;
  private:
  bool _internal_has_primarycolor() const;
  public:
  void clear_primarycolor();
  const ::Common::Color4& primarycolor() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_primarycolor();
  ::Common::Color4* mutable_primarycolor();
  void set_allocated_primarycolor(::Common::Color4* primarycolor);
  private:
  const ::Common::Color4& _internal_primarycolor() const;
  ::Common::Color4* _internal_mutable_primarycolor();
  public:
  void unsafe_arena_set_allocated_primarycolor(
      ::Common::Color4* primarycolor);
  ::Common::Color4* unsafe_arena_release_primarycolor();

  // .Common.Color4 secondaryColor = 4;
  bool has_secondarycolor() const;
  private:
  bool _internal_has_secondarycolor() const;
  public:
  void clear_secondarycolor();
  const ::Common::Color4& secondarycolor() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_secondarycolor();
  ::Common::Color4* mutable_secondarycolor();
  void set_allocated_secondarycolor(::Common::Color4* secondarycolor);
  private:
  const ::Common::Color4& _internal_secondarycolor() const;
  ::Common::Color4* _internal_mutable_secondarycolor();
  public:
  void unsafe_arena_set_allocated_secondarycolor(
      ::Common::Color4* secondarycolor);
  ::Common::Color4* unsafe_arena_release_secondarycolor();

  // float spread = 5;
  void clear_spread();
  float spread() const;
  void set_spread(float value);
  private:
  float _internal_spread() const;
  void _internal_set_spread(float value);
  public:

  // float speed = 6;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float coverage = 7;
  void clear_coverage();
  float coverage() const;
  void set_coverage(float value);
  private:
  float _internal_coverage() const;
  void _internal_set_coverage(float value);
  public:

  // float edging = 8;
  void clear_edging();
  float edging() const;
  void set_edging(float value);
  private:
  float _internal_edging() const;
  void _internal_set_edging(float value);
  public:

  // float riseTime = 9;
  void clear_risetime();
  float risetime() const;
  void set_risetime(float value);
  private:
  float _internal_risetime() const;
  void _internal_set_risetime(float value);
  public:

  // float holdTime = 10;
  void clear_holdtime();
  float holdtime() const;
  void set_holdtime(float value);
  private:
  float _internal_holdtime() const;
  void _internal_set_holdtime(float value);
  public:

  // float fallTime = 11;
  void clear_falltime();
  float falltime() const;
  void set_falltime(float value);
  private:
  float _internal_falltime() const;
  void _internal_set_falltime(float value);
  public:

  // @@protoc_insertion_point(class_scope:JournalData.PartHighlightData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Color4* primarycolor_;
    ::Common::Color4* secondarycolor_;
    float spread_;
    float speed_;
    float coverage_;
    float edging_;
    float risetime_;
    float holdtime_;
    float falltime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// -------------------------------------------------------------------

class LightingEnvironmentContentType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JournalData.LightingEnvironmentContentType) */ {
 public:
  inline LightingEnvironmentContentType() : LightingEnvironmentContentType(nullptr) {}
  ~LightingEnvironmentContentType() override;
  explicit PROTOBUF_CONSTEXPR LightingEnvironmentContentType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightingEnvironmentContentType(const LightingEnvironmentContentType& from);
  LightingEnvironmentContentType(LightingEnvironmentContentType&& from) noexcept
    : LightingEnvironmentContentType() {
    *this = ::std::move(from);
  }

  inline LightingEnvironmentContentType& operator=(const LightingEnvironmentContentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightingEnvironmentContentType& operator=(LightingEnvironmentContentType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LightingEnvironmentContentType& default_instance() {
    return *internal_default_instance();
  }
  enum ImCase {
    kContentId = 1,
    kImageProgress = 2,
    IM_NOT_SET = 0,
  };

  static inline const LightingEnvironmentContentType* internal_default_instance() {
    return reinterpret_cast<const LightingEnvironmentContentType*>(
               &_LightingEnvironmentContentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LightingEnvironmentContentType& a, LightingEnvironmentContentType& b) {
    a.Swap(&b);
  }
  inline void Swap(LightingEnvironmentContentType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightingEnvironmentContentType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LightingEnvironmentContentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LightingEnvironmentContentType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LightingEnvironmentContentType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LightingEnvironmentContentType& from) {
    LightingEnvironmentContentType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightingEnvironmentContentType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JournalData.LightingEnvironmentContentType";
  }
  protected:
  explicit LightingEnvironmentContentType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kImageProgressFieldNumber = 2,
  };
  // string contentId = 1;
  bool has_contentid() const;
  private:
  bool _internal_has_contentid() const;
  public:
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // .JournalData.Progress imageProgress = 2;
  bool has_imageprogress() const;
  private:
  bool _internal_has_imageprogress() const;
  public:
  void clear_imageprogress();
  const ::JournalData::Progress& imageprogress() const;
  PROTOBUF_NODISCARD ::JournalData::Progress* release_imageprogress();
  ::JournalData::Progress* mutable_imageprogress();
  void set_allocated_imageprogress(::JournalData::Progress* imageprogress);
  private:
  const ::JournalData::Progress& _internal_imageprogress() const;
  ::JournalData::Progress* _internal_mutable_imageprogress();
  public:
  void unsafe_arena_set_allocated_imageprogress(
      ::JournalData::Progress* imageprogress);
  ::JournalData::Progress* unsafe_arena_release_imageprogress();

  void clear_Im();
  ImCase Im_case() const;
  // @@protoc_insertion_point(class_scope:JournalData.LightingEnvironmentContentType)
 private:
  class _Internal;
  void set_has_contentid();
  void set_has_imageprogress();

  inline bool has_Im() const;
  inline void clear_has_Im();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ImUnion {
      constexpr ImUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
      ::JournalData::Progress* imageprogress_;
    } Im_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_journaldata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObjectId

// string objId = 1;
inline void ObjectId::clear_objid() {
  _impl_.objid_.ClearToEmpty();
}
inline const std::string& ObjectId::objid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectId.objId)
  return _internal_objid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectId::set_objid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.objid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectId.objId)
}
inline std::string* ObjectId::mutable_objid() {
  std::string* _s = _internal_mutable_objid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectId.objId)
  return _s;
}
inline const std::string& ObjectId::_internal_objid() const {
  return _impl_.objid_.Get();
}
inline void ObjectId::_internal_set_objid(const std::string& value) {
  
  _impl_.objid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectId::_internal_mutable_objid() {
  
  return _impl_.objid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectId::release_objid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectId.objId)
  return _impl_.objid_.Release();
}
inline void ObjectId::set_allocated_objid(std::string* objid) {
  if (objid != nullptr) {
    
  } else {
    
  }
  _impl_.objid_.SetAllocated(objid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.objid_.IsDefault()) {
    _impl_.objid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectId.objId)
}

// string component = 2;
inline void ObjectId::clear_component() {
  _impl_.component_.ClearToEmpty();
}
inline const std::string& ObjectId::component() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectId.component)
  return _internal_component();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectId::set_component(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectId.component)
}
inline std::string* ObjectId::mutable_component() {
  std::string* _s = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectId.component)
  return _s;
}
inline const std::string& ObjectId::_internal_component() const {
  return _impl_.component_.Get();
}
inline void ObjectId::_internal_set_component(const std::string& value) {
  
  _impl_.component_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectId::_internal_mutable_component() {
  
  return _impl_.component_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectId::release_component() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectId.component)
  return _impl_.component_.Release();
}
inline void ObjectId::set_allocated_component(std::string* component) {
  if (component != nullptr) {
    
  } else {
    
  }
  _impl_.component_.SetAllocated(component, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_.IsDefault()) {
    _impl_.component_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectId.component)
}

// -------------------------------------------------------------------

// BoardState

// sint32 frame = 1;
inline bool BoardState::_internal_has_frame() const {
  return StateType_case() == kFrame;
}
inline bool BoardState::has_frame() const {
  return _internal_has_frame();
}
inline void BoardState::set_has_frame() {
  _impl_._oneof_case_[0] = kFrame;
}
inline void BoardState::clear_frame() {
  if (_internal_has_frame()) {
    _impl_.StateType_.frame_ = 0;
    clear_has_StateType();
  }
}
inline int32_t BoardState::_internal_frame() const {
  if (_internal_has_frame()) {
    return _impl_.StateType_.frame_;
  }
  return 0;
}
inline void BoardState::_internal_set_frame(int32_t value) {
  if (!_internal_has_frame()) {
    clear_StateType();
    set_has_frame();
  }
  _impl_.StateType_.frame_ = value;
}
inline int32_t BoardState::frame() const {
  // @@protoc_insertion_point(field_get:JournalData.BoardState.frame)
  return _internal_frame();
}
inline void BoardState::set_frame(int32_t value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:JournalData.BoardState.frame)
}

// sint32 frameStart = 2;
inline bool BoardState::_internal_has_framestart() const {
  return StateType_case() == kFrameStart;
}
inline bool BoardState::has_framestart() const {
  return _internal_has_framestart();
}
inline void BoardState::set_has_framestart() {
  _impl_._oneof_case_[0] = kFrameStart;
}
inline void BoardState::clear_framestart() {
  if (_internal_has_framestart()) {
    _impl_.StateType_.framestart_ = 0;
    clear_has_StateType();
  }
}
inline int32_t BoardState::_internal_framestart() const {
  if (_internal_has_framestart()) {
    return _impl_.StateType_.framestart_;
  }
  return 0;
}
inline void BoardState::_internal_set_framestart(int32_t value) {
  if (!_internal_has_framestart()) {
    clear_StateType();
    set_has_framestart();
  }
  _impl_.StateType_.framestart_ = value;
}
inline int32_t BoardState::framestart() const {
  // @@protoc_insertion_point(field_get:JournalData.BoardState.frameStart)
  return _internal_framestart();
}
inline void BoardState::set_framestart(int32_t value) {
  _internal_set_framestart(value);
  // @@protoc_insertion_point(field_set:JournalData.BoardState.frameStart)
}

// string source = 3;
inline bool BoardState::_internal_has_source() const {
  return StateType_case() == kSource;
}
inline bool BoardState::has_source() const {
  return _internal_has_source();
}
inline void BoardState::set_has_source() {
  _impl_._oneof_case_[0] = kSource;
}
inline void BoardState::clear_source() {
  if (_internal_has_source()) {
    _impl_.StateType_.source_.Destroy();
    clear_has_StateType();
  }
}
inline const std::string& BoardState::source() const {
  // @@protoc_insertion_point(field_get:JournalData.BoardState.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline void BoardState::set_source(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_source()) {
    clear_StateType();
    set_has_source();
    _impl_.StateType_.source_.InitDefault();
  }
  _impl_.StateType_.source_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.BoardState.source)
}
inline std::string* BoardState::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:JournalData.BoardState.source)
  return _s;
}
inline const std::string& BoardState::_internal_source() const {
  if (_internal_has_source()) {
    return _impl_.StateType_.source_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void BoardState::_internal_set_source(const std::string& value) {
  if (!_internal_has_source()) {
    clear_StateType();
    set_has_source();
    _impl_.StateType_.source_.InitDefault();
  }
  _impl_.StateType_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* BoardState::_internal_mutable_source() {
  if (!_internal_has_source()) {
    clear_StateType();
    set_has_source();
    _impl_.StateType_.source_.InitDefault();
  }
  return _impl_.StateType_.source_.Mutable(      GetArenaForAllocation());
}
inline std::string* BoardState::release_source() {
  // @@protoc_insertion_point(field_release:JournalData.BoardState.source)
  if (_internal_has_source()) {
    clear_has_StateType();
    return _impl_.StateType_.source_.Release();
  } else {
    return nullptr;
  }
}
inline void BoardState::set_allocated_source(std::string* source) {
  if (has_StateType()) {
    clear_StateType();
  }
  if (source != nullptr) {
    set_has_source();
    _impl_.StateType_.source_.InitAllocated(source, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.BoardState.source)
}

inline bool BoardState::has_StateType() const {
  return StateType_case() != STATETYPE_NOT_SET;
}
inline void BoardState::clear_has_StateType() {
  _impl_._oneof_case_[0] = STATETYPE_NOT_SET;
}
inline BoardState::StateTypeCase BoardState::StateType_case() const {
  return BoardState::StateTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Progress_V1

// .JournalData.Progress.V1.ProgressMode progressMode = 1;
inline void Progress_V1::clear_progressmode() {
  _impl_.progressmode_ = 0;
}
inline ::JournalData::Progress_V1_ProgressMode Progress_V1::_internal_progressmode() const {
  return static_cast< ::JournalData::Progress_V1_ProgressMode >(_impl_.progressmode_);
}
inline ::JournalData::Progress_V1_ProgressMode Progress_V1::progressmode() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V1.progressMode)
  return _internal_progressmode();
}
inline void Progress_V1::_internal_set_progressmode(::JournalData::Progress_V1_ProgressMode value) {
  
  _impl_.progressmode_ = value;
}
inline void Progress_V1::set_progressmode(::JournalData::Progress_V1_ProgressMode value) {
  _internal_set_progressmode(value);
  // @@protoc_insertion_point(field_set:JournalData.Progress.V1.progressMode)
}

// float progressPercentage = 2;
inline void Progress_V1::clear_progresspercentage() {
  _impl_.progresspercentage_ = 0;
}
inline float Progress_V1::_internal_progresspercentage() const {
  return _impl_.progresspercentage_;
}
inline float Progress_V1::progresspercentage() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V1.progressPercentage)
  return _internal_progresspercentage();
}
inline void Progress_V1::_internal_set_progresspercentage(float value) {
  
  _impl_.progresspercentage_ = value;
}
inline void Progress_V1::set_progresspercentage(float value) {
  _internal_set_progresspercentage(value);
  // @@protoc_insertion_point(field_set:JournalData.Progress.V1.progressPercentage)
}

// -------------------------------------------------------------------

// Progress_V2

// repeated string taskStack = 1;
inline int Progress_V2::_internal_taskstack_size() const {
  return _impl_.taskstack_.size();
}
inline int Progress_V2::taskstack_size() const {
  return _internal_taskstack_size();
}
inline void Progress_V2::clear_taskstack() {
  _impl_.taskstack_.Clear();
}
inline std::string* Progress_V2::add_taskstack() {
  std::string* _s = _internal_add_taskstack();
  // @@protoc_insertion_point(field_add_mutable:JournalData.Progress.V2.taskStack)
  return _s;
}
inline const std::string& Progress_V2::_internal_taskstack(int index) const {
  return _impl_.taskstack_.Get(index);
}
inline const std::string& Progress_V2::taskstack(int index) const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V2.taskStack)
  return _internal_taskstack(index);
}
inline std::string* Progress_V2::mutable_taskstack(int index) {
  // @@protoc_insertion_point(field_mutable:JournalData.Progress.V2.taskStack)
  return _impl_.taskstack_.Mutable(index);
}
inline void Progress_V2::set_taskstack(int index, const std::string& value) {
  _impl_.taskstack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::set_taskstack(int index, std::string&& value) {
  _impl_.taskstack_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::set_taskstack(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.taskstack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::set_taskstack(int index, const char* value, size_t size) {
  _impl_.taskstack_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JournalData.Progress.V2.taskStack)
}
inline std::string* Progress_V2::_internal_add_taskstack() {
  return _impl_.taskstack_.Add();
}
inline void Progress_V2::add_taskstack(const std::string& value) {
  _impl_.taskstack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::add_taskstack(std::string&& value) {
  _impl_.taskstack_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::add_taskstack(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.taskstack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:JournalData.Progress.V2.taskStack)
}
inline void Progress_V2::add_taskstack(const char* value, size_t size) {
  _impl_.taskstack_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:JournalData.Progress.V2.taskStack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Progress_V2::taskstack() const {
  // @@protoc_insertion_point(field_list:JournalData.Progress.V2.taskStack)
  return _impl_.taskstack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Progress_V2::mutable_taskstack() {
  // @@protoc_insertion_point(field_mutable_list:JournalData.Progress.V2.taskStack)
  return &_impl_.taskstack_;
}

// string currentDescription = 2;
inline void Progress_V2::clear_currentdescription() {
  _impl_.currentdescription_.ClearToEmpty();
}
inline const std::string& Progress_V2::currentdescription() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V2.currentDescription)
  return _internal_currentdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Progress_V2::set_currentdescription(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currentdescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.Progress.V2.currentDescription)
}
inline std::string* Progress_V2::mutable_currentdescription() {
  std::string* _s = _internal_mutable_currentdescription();
  // @@protoc_insertion_point(field_mutable:JournalData.Progress.V2.currentDescription)
  return _s;
}
inline const std::string& Progress_V2::_internal_currentdescription() const {
  return _impl_.currentdescription_.Get();
}
inline void Progress_V2::_internal_set_currentdescription(const std::string& value) {
  
  _impl_.currentdescription_.Set(value, GetArenaForAllocation());
}
inline std::string* Progress_V2::_internal_mutable_currentdescription() {
  
  return _impl_.currentdescription_.Mutable(GetArenaForAllocation());
}
inline std::string* Progress_V2::release_currentdescription() {
  // @@protoc_insertion_point(field_release:JournalData.Progress.V2.currentDescription)
  return _impl_.currentdescription_.Release();
}
inline void Progress_V2::set_allocated_currentdescription(std::string* currentdescription) {
  if (currentdescription != nullptr) {
    
  } else {
    
  }
  _impl_.currentdescription_.SetAllocated(currentdescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentdescription_.IsDefault()) {
    _impl_.currentdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.Progress.V2.currentDescription)
}

// float taskProgress = 3;
inline void Progress_V2::clear_taskprogress() {
  _impl_.taskprogress_ = 0;
}
inline float Progress_V2::_internal_taskprogress() const {
  return _impl_.taskprogress_;
}
inline float Progress_V2::taskprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V2.taskProgress)
  return _internal_taskprogress();
}
inline void Progress_V2::_internal_set_taskprogress(float value) {
  
  _impl_.taskprogress_ = value;
}
inline void Progress_V2::set_taskprogress(float value) {
  _internal_set_taskprogress(value);
  // @@protoc_insertion_point(field_set:JournalData.Progress.V2.taskProgress)
}

// float overallProgress = 4;
inline void Progress_V2::clear_overallprogress() {
  _impl_.overallprogress_ = 0;
}
inline float Progress_V2::_internal_overallprogress() const {
  return _impl_.overallprogress_;
}
inline float Progress_V2::overallprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.V2.overallProgress)
  return _internal_overallprogress();
}
inline void Progress_V2::_internal_set_overallprogress(float value) {
  
  _impl_.overallprogress_ = value;
}
inline void Progress_V2::set_overallprogress(float value) {
  _internal_set_overallprogress(value);
  // @@protoc_insertion_point(field_set:JournalData.Progress.V2.overallProgress)
}

// -------------------------------------------------------------------

// Progress

// .JournalData.Progress.V1 v1 = 1;
inline bool Progress::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool Progress::has_v1() const {
  return _internal_has_v1();
}
inline void Progress::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void Progress::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::JournalData::Progress_V1* Progress::release_v1() {
  // @@protoc_insertion_point(field_release:JournalData.Progress.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::JournalData::Progress_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress_V1& Progress::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::JournalData::Progress_V1&>(::JournalData::_Progress_V1_default_instance_);
}
inline const ::JournalData::Progress_V1& Progress::v1() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.v1)
  return _internal_v1();
}
inline ::JournalData::Progress_V1* Progress::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.Progress.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::JournalData::Progress_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Progress::unsafe_arena_set_allocated_v1(::JournalData::Progress_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.Progress.v1)
}
inline ::JournalData::Progress_V1* Progress::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::JournalData::Progress_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::JournalData::Progress_V1* Progress::mutable_v1() {
  ::JournalData::Progress_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:JournalData.Progress.v1)
  return _msg;
}

// .JournalData.Progress.V2 v2 = 2;
inline bool Progress::_internal_has_v2() const {
  return V_case() == kV2;
}
inline bool Progress::has_v2() const {
  return _internal_has_v2();
}
inline void Progress::set_has_v2() {
  _impl_._oneof_case_[0] = kV2;
}
inline void Progress::clear_v2() {
  if (_internal_has_v2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v2_;
    }
    clear_has_V();
  }
}
inline ::JournalData::Progress_V2* Progress::release_v2() {
  // @@protoc_insertion_point(field_release:JournalData.Progress.v2)
  if (_internal_has_v2()) {
    clear_has_V();
    ::JournalData::Progress_V2* temp = _impl_.V_.v2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress_V2& Progress::_internal_v2() const {
  return _internal_has_v2()
      ? *_impl_.V_.v2_
      : reinterpret_cast< ::JournalData::Progress_V2&>(::JournalData::_Progress_V2_default_instance_);
}
inline const ::JournalData::Progress_V2& Progress::v2() const {
  // @@protoc_insertion_point(field_get:JournalData.Progress.v2)
  return _internal_v2();
}
inline ::JournalData::Progress_V2* Progress::unsafe_arena_release_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.Progress.v2)
  if (_internal_has_v2()) {
    clear_has_V();
    ::JournalData::Progress_V2* temp = _impl_.V_.v2_;
    _impl_.V_.v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Progress::unsafe_arena_set_allocated_v2(::JournalData::Progress_V2* v2) {
  clear_V();
  if (v2) {
    set_has_v2();
    _impl_.V_.v2_ = v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.Progress.v2)
}
inline ::JournalData::Progress_V2* Progress::_internal_mutable_v2() {
  if (!_internal_has_v2()) {
    clear_V();
    set_has_v2();
    _impl_.V_.v2_ = CreateMaybeMessage< ::JournalData::Progress_V2 >(GetArenaForAllocation());
  }
  return _impl_.V_.v2_;
}
inline ::JournalData::Progress_V2* Progress::mutable_v2() {
  ::JournalData::Progress_V2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:JournalData.Progress.v2)
  return _msg;
}

inline bool Progress::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void Progress::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline Progress::VCase Progress::V_case() const {
  return Progress::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectType_StreamBoardObjectType

// string connectionId = 1;
inline void ObjectType_StreamBoardObjectType::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& ObjectType_StreamBoardObjectType::connectionid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.StreamBoardObjectType.connectionId)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_StreamBoardObjectType::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.StreamBoardObjectType.connectionId)
}
inline std::string* ObjectType_StreamBoardObjectType::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.StreamBoardObjectType.connectionId)
  return _s;
}
inline const std::string& ObjectType_StreamBoardObjectType::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void ObjectType_StreamBoardObjectType::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_StreamBoardObjectType::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_StreamBoardObjectType::release_connectionid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.StreamBoardObjectType.connectionId)
  return _impl_.connectionid_.Release();
}
inline void ObjectType_StreamBoardObjectType::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.StreamBoardObjectType.connectionId)
}

// string userId = 2;
inline void ObjectType_StreamBoardObjectType::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ObjectType_StreamBoardObjectType::userid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.StreamBoardObjectType.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_StreamBoardObjectType::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.StreamBoardObjectType.userId)
}
inline std::string* ObjectType_StreamBoardObjectType::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.StreamBoardObjectType.userId)
  return _s;
}
inline const std::string& ObjectType_StreamBoardObjectType::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ObjectType_StreamBoardObjectType::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_StreamBoardObjectType::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_StreamBoardObjectType::release_userid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.StreamBoardObjectType.userId)
  return _impl_.userid_.Release();
}
inline void ObjectType_StreamBoardObjectType::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.StreamBoardObjectType.userId)
}

// -------------------------------------------------------------------

// ObjectType_TextBoardObjectType

// string initialText = 1;
inline void ObjectType_TextBoardObjectType::clear_initialtext() {
  _impl_.initialtext_.ClearToEmpty();
}
inline const std::string& ObjectType_TextBoardObjectType::initialtext() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.TextBoardObjectType.initialText)
  return _internal_initialtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_TextBoardObjectType::set_initialtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initialtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.TextBoardObjectType.initialText)
}
inline std::string* ObjectType_TextBoardObjectType::mutable_initialtext() {
  std::string* _s = _internal_mutable_initialtext();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.TextBoardObjectType.initialText)
  return _s;
}
inline const std::string& ObjectType_TextBoardObjectType::_internal_initialtext() const {
  return _impl_.initialtext_.Get();
}
inline void ObjectType_TextBoardObjectType::_internal_set_initialtext(const std::string& value) {
  
  _impl_.initialtext_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_TextBoardObjectType::_internal_mutable_initialtext() {
  
  return _impl_.initialtext_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_TextBoardObjectType::release_initialtext() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.TextBoardObjectType.initialText)
  return _impl_.initialtext_.Release();
}
inline void ObjectType_TextBoardObjectType::set_allocated_initialtext(std::string* initialtext) {
  if (initialtext != nullptr) {
    
  } else {
    
  }
  _impl_.initialtext_.SetAllocated(initialtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initialtext_.IsDefault()) {
    _impl_.initialtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.TextBoardObjectType.initialText)
}

// .JournalData.BoardSizeData textboard = 2;
inline bool ObjectType_TextBoardObjectType::_internal_has_textboard() const {
  return this != internal_default_instance() && _impl_.textboard_ != nullptr;
}
inline bool ObjectType_TextBoardObjectType::has_textboard() const {
  return _internal_has_textboard();
}
inline void ObjectType_TextBoardObjectType::clear_textboard() {
  if (GetArenaForAllocation() == nullptr && _impl_.textboard_ != nullptr) {
    delete _impl_.textboard_;
  }
  _impl_.textboard_ = nullptr;
}
inline const ::JournalData::BoardSizeData& ObjectType_TextBoardObjectType::_internal_textboard() const {
  const ::JournalData::BoardSizeData* p = _impl_.textboard_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::BoardSizeData&>(
      ::JournalData::_BoardSizeData_default_instance_);
}
inline const ::JournalData::BoardSizeData& ObjectType_TextBoardObjectType::textboard() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.TextBoardObjectType.textboard)
  return _internal_textboard();
}
inline void ObjectType_TextBoardObjectType::unsafe_arena_set_allocated_textboard(
    ::JournalData::BoardSizeData* textboard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.textboard_);
  }
  _impl_.textboard_ = textboard;
  if (textboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.TextBoardObjectType.textboard)
}
inline ::JournalData::BoardSizeData* ObjectType_TextBoardObjectType::release_textboard() {
  
  ::JournalData::BoardSizeData* temp = _impl_.textboard_;
  _impl_.textboard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::BoardSizeData* ObjectType_TextBoardObjectType::unsafe_arena_release_textboard() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.TextBoardObjectType.textboard)
  
  ::JournalData::BoardSizeData* temp = _impl_.textboard_;
  _impl_.textboard_ = nullptr;
  return temp;
}
inline ::JournalData::BoardSizeData* ObjectType_TextBoardObjectType::_internal_mutable_textboard() {
  
  if (_impl_.textboard_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::BoardSizeData>(GetArenaForAllocation());
    _impl_.textboard_ = p;
  }
  return _impl_.textboard_;
}
inline ::JournalData::BoardSizeData* ObjectType_TextBoardObjectType::mutable_textboard() {
  ::JournalData::BoardSizeData* _msg = _internal_mutable_textboard();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.TextBoardObjectType.textboard)
  return _msg;
}
inline void ObjectType_TextBoardObjectType::set_allocated_textboard(::JournalData::BoardSizeData* textboard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.textboard_;
  }
  if (textboard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(textboard);
    if (message_arena != submessage_arena) {
      textboard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textboard, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.textboard_ = textboard;
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.TextBoardObjectType.textboard)
}

// -------------------------------------------------------------------

// ObjectType_ArTrackerObjectType

// string contentId = 1;
inline void ObjectType_ArTrackerObjectType::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& ObjectType_ArTrackerObjectType::contentid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.ArTrackerObjectType.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_ArTrackerObjectType::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.ArTrackerObjectType.contentId)
}
inline std::string* ObjectType_ArTrackerObjectType::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.ArTrackerObjectType.contentId)
  return _s;
}
inline const std::string& ObjectType_ArTrackerObjectType::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void ObjectType_ArTrackerObjectType::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_ArTrackerObjectType::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_ArTrackerObjectType::release_contentid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.ArTrackerObjectType.contentId)
  return _impl_.contentid_.Release();
}
inline void ObjectType_ArTrackerObjectType::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.ArTrackerObjectType.contentId)
}

// -------------------------------------------------------------------

// ObjectType_CustomContentId

// string customSourceId = 1;
inline void ObjectType_CustomContentId::clear_customsourceid() {
  _impl_.customsourceid_.ClearToEmpty();
}
inline const std::string& ObjectType_CustomContentId::customsourceid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.CustomContentId.customSourceId)
  return _internal_customsourceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_CustomContentId::set_customsourceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.customsourceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.CustomContentId.customSourceId)
}
inline std::string* ObjectType_CustomContentId::mutable_customsourceid() {
  std::string* _s = _internal_mutable_customsourceid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.CustomContentId.customSourceId)
  return _s;
}
inline const std::string& ObjectType_CustomContentId::_internal_customsourceid() const {
  return _impl_.customsourceid_.Get();
}
inline void ObjectType_CustomContentId::_internal_set_customsourceid(const std::string& value) {
  
  _impl_.customsourceid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_CustomContentId::_internal_mutable_customsourceid() {
  
  return _impl_.customsourceid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_CustomContentId::release_customsourceid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.CustomContentId.customSourceId)
  return _impl_.customsourceid_.Release();
}
inline void ObjectType_CustomContentId::set_allocated_customsourceid(std::string* customsourceid) {
  if (customsourceid != nullptr) {
    
  } else {
    
  }
  _impl_.customsourceid_.SetAllocated(customsourceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.customsourceid_.IsDefault()) {
    _impl_.customsourceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.CustomContentId.customSourceId)
}

// string customContentId = 2;
inline void ObjectType_CustomContentId::clear_customcontentid() {
  _impl_.customcontentid_.ClearToEmpty();
}
inline const std::string& ObjectType_CustomContentId::customcontentid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.CustomContentId.customContentId)
  return _internal_customcontentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_CustomContentId::set_customcontentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.customcontentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.CustomContentId.customContentId)
}
inline std::string* ObjectType_CustomContentId::mutable_customcontentid() {
  std::string* _s = _internal_mutable_customcontentid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.CustomContentId.customContentId)
  return _s;
}
inline const std::string& ObjectType_CustomContentId::_internal_customcontentid() const {
  return _impl_.customcontentid_.Get();
}
inline void ObjectType_CustomContentId::_internal_set_customcontentid(const std::string& value) {
  
  _impl_.customcontentid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_CustomContentId::_internal_mutable_customcontentid() {
  
  return _impl_.customcontentid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_CustomContentId::release_customcontentid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.CustomContentId.customContentId)
  return _impl_.customcontentid_.Release();
}
inline void ObjectType_CustomContentId::set_allocated_customcontentid(std::string* customcontentid) {
  if (customcontentid != nullptr) {
    
  } else {
    
  }
  _impl_.customcontentid_.SetAllocated(customcontentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.customcontentid_.IsDefault()) {
    _impl_.customcontentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.CustomContentId.customContentId)
}

// -------------------------------------------------------------------

// ObjectType_ChatMessageObjectType

// string initialText = 1;
inline void ObjectType_ChatMessageObjectType::clear_initialtext() {
  _impl_.initialtext_.ClearToEmpty();
}
inline const std::string& ObjectType_ChatMessageObjectType::initialtext() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.ChatMessageObjectType.initialText)
  return _internal_initialtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_ChatMessageObjectType::set_initialtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initialtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.ChatMessageObjectType.initialText)
}
inline std::string* ObjectType_ChatMessageObjectType::mutable_initialtext() {
  std::string* _s = _internal_mutable_initialtext();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.ChatMessageObjectType.initialText)
  return _s;
}
inline const std::string& ObjectType_ChatMessageObjectType::_internal_initialtext() const {
  return _impl_.initialtext_.Get();
}
inline void ObjectType_ChatMessageObjectType::_internal_set_initialtext(const std::string& value) {
  
  _impl_.initialtext_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_ChatMessageObjectType::_internal_mutable_initialtext() {
  
  return _impl_.initialtext_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_ChatMessageObjectType::release_initialtext() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.ChatMessageObjectType.initialText)
  return _impl_.initialtext_.Release();
}
inline void ObjectType_ChatMessageObjectType::set_allocated_initialtext(std::string* initialtext) {
  if (initialtext != nullptr) {
    
  } else {
    
  }
  _impl_.initialtext_.SetAllocated(initialtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initialtext_.IsDefault()) {
    _impl_.initialtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.ChatMessageObjectType.initialText)
}

// .google.protobuf.Timestamp timeCreated = 2;
inline bool ObjectType_ChatMessageObjectType::_internal_has_timecreated() const {
  return this != internal_default_instance() && _impl_.timecreated_ != nullptr;
}
inline bool ObjectType_ChatMessageObjectType::has_timecreated() const {
  return _internal_has_timecreated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectType_ChatMessageObjectType::_internal_timecreated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timecreated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectType_ChatMessageObjectType::timecreated() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.ChatMessageObjectType.timeCreated)
  return _internal_timecreated();
}
inline void ObjectType_ChatMessageObjectType::unsafe_arena_set_allocated_timecreated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timecreated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timecreated_);
  }
  _impl_.timecreated_ = timecreated;
  if (timecreated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.ChatMessageObjectType.timeCreated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectType_ChatMessageObjectType::release_timecreated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timecreated_;
  _impl_.timecreated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectType_ChatMessageObjectType::unsafe_arena_release_timecreated() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.ChatMessageObjectType.timeCreated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timecreated_;
  _impl_.timecreated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectType_ChatMessageObjectType::_internal_mutable_timecreated() {
  
  if (_impl_.timecreated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timecreated_ = p;
  }
  return _impl_.timecreated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectType_ChatMessageObjectType::mutable_timecreated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timecreated();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.ChatMessageObjectType.timeCreated)
  return _msg;
}
inline void ObjectType_ChatMessageObjectType::set_allocated_timecreated(::PROTOBUF_NAMESPACE_ID::Timestamp* timecreated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timecreated_);
  }
  if (timecreated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timecreated));
    if (message_arena != submessage_arena) {
      timecreated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timecreated, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timecreated_ = timecreated;
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.ChatMessageObjectType.timeCreated)
}

// optional string creatorId = 3;
inline bool ObjectType_ChatMessageObjectType::_internal_has_creatorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectType_ChatMessageObjectType::has_creatorid() const {
  return _internal_has_creatorid();
}
inline void ObjectType_ChatMessageObjectType::clear_creatorid() {
  _impl_.creatorid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectType_ChatMessageObjectType::creatorid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.ChatMessageObjectType.creatorId)
  return _internal_creatorid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectType_ChatMessageObjectType::set_creatorid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.creatorid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.ChatMessageObjectType.creatorId)
}
inline std::string* ObjectType_ChatMessageObjectType::mutable_creatorid() {
  std::string* _s = _internal_mutable_creatorid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.ChatMessageObjectType.creatorId)
  return _s;
}
inline const std::string& ObjectType_ChatMessageObjectType::_internal_creatorid() const {
  return _impl_.creatorid_.Get();
}
inline void ObjectType_ChatMessageObjectType::_internal_set_creatorid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.creatorid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType_ChatMessageObjectType::_internal_mutable_creatorid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.creatorid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectType_ChatMessageObjectType::release_creatorid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.ChatMessageObjectType.creatorId)
  if (!_internal_has_creatorid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.creatorid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorid_.IsDefault()) {
    _impl_.creatorid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectType_ChatMessageObjectType::set_allocated_creatorid(std::string* creatorid) {
  if (creatorid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.creatorid_.SetAllocated(creatorid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorid_.IsDefault()) {
    _impl_.creatorid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.ChatMessageObjectType.creatorId)
}

// optional .JournalData.ChatMessageSourceTypeEnum sourceType = 4;
inline bool ObjectType_ChatMessageObjectType::_internal_has_sourcetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectType_ChatMessageObjectType::has_sourcetype() const {
  return _internal_has_sourcetype();
}
inline void ObjectType_ChatMessageObjectType::clear_sourcetype() {
  _impl_.sourcetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::JournalData::ChatMessageSourceTypeEnum ObjectType_ChatMessageObjectType::_internal_sourcetype() const {
  return static_cast< ::JournalData::ChatMessageSourceTypeEnum >(_impl_.sourcetype_);
}
inline ::JournalData::ChatMessageSourceTypeEnum ObjectType_ChatMessageObjectType::sourcetype() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.ChatMessageObjectType.sourceType)
  return _internal_sourcetype();
}
inline void ObjectType_ChatMessageObjectType::_internal_set_sourcetype(::JournalData::ChatMessageSourceTypeEnum value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourcetype_ = value;
}
inline void ObjectType_ChatMessageObjectType::set_sourcetype(::JournalData::ChatMessageSourceTypeEnum value) {
  _internal_set_sourcetype(value);
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.ChatMessageObjectType.sourceType)
}

// -------------------------------------------------------------------

// ObjectType

// string contentId = 1;
inline bool ObjectType::_internal_has_contentid() const {
  return Ob_case() == kContentId;
}
inline bool ObjectType::has_contentid() const {
  return _internal_has_contentid();
}
inline void ObjectType::set_has_contentid() {
  _impl_._oneof_case_[0] = kContentId;
}
inline void ObjectType::clear_contentid() {
  if (_internal_has_contentid()) {
    _impl_.Ob_.contentid_.Destroy();
    clear_has_Ob();
  }
}
inline const std::string& ObjectType::contentid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline void ObjectType::set_contentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contentid()) {
    clear_Ob();
    set_has_contentid();
    _impl_.Ob_.contentid_.InitDefault();
  }
  _impl_.Ob_.contentid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.contentId)
}
inline std::string* ObjectType::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.contentId)
  return _s;
}
inline const std::string& ObjectType::_internal_contentid() const {
  if (_internal_has_contentid()) {
    return _impl_.Ob_.contentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ObjectType::_internal_set_contentid(const std::string& value) {
  if (!_internal_has_contentid()) {
    clear_Ob();
    set_has_contentid();
    _impl_.Ob_.contentid_.InitDefault();
  }
  _impl_.Ob_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType::_internal_mutable_contentid() {
  if (!_internal_has_contentid()) {
    clear_Ob();
    set_has_contentid();
    _impl_.Ob_.contentid_.InitDefault();
  }
  return _impl_.Ob_.contentid_.Mutable(      GetArenaForAllocation());
}
inline std::string* ObjectType::release_contentid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.contentId)
  if (_internal_has_contentid()) {
    clear_has_Ob();
    return _impl_.Ob_.contentid_.Release();
  } else {
    return nullptr;
  }
}
inline void ObjectType::set_allocated_contentid(std::string* contentid) {
  if (has_Ob()) {
    clear_Ob();
  }
  if (contentid != nullptr) {
    set_has_contentid();
    _impl_.Ob_.contentid_.InitAllocated(contentid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.contentId)
}

// .JournalData.BoardSizeData whiteboard = 2;
inline bool ObjectType::_internal_has_whiteboard() const {
  return Ob_case() == kWhiteboard;
}
inline bool ObjectType::has_whiteboard() const {
  return _internal_has_whiteboard();
}
inline void ObjectType::set_has_whiteboard() {
  _impl_._oneof_case_[0] = kWhiteboard;
}
inline void ObjectType::clear_whiteboard() {
  if (_internal_has_whiteboard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.whiteboard_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::BoardSizeData* ObjectType::release_whiteboard() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.whiteboard)
  if (_internal_has_whiteboard()) {
    clear_has_Ob();
    ::JournalData::BoardSizeData* temp = _impl_.Ob_.whiteboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.whiteboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::BoardSizeData& ObjectType::_internal_whiteboard() const {
  return _internal_has_whiteboard()
      ? *_impl_.Ob_.whiteboard_
      : reinterpret_cast< ::JournalData::BoardSizeData&>(::JournalData::_BoardSizeData_default_instance_);
}
inline const ::JournalData::BoardSizeData& ObjectType::whiteboard() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.whiteboard)
  return _internal_whiteboard();
}
inline ::JournalData::BoardSizeData* ObjectType::unsafe_arena_release_whiteboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.whiteboard)
  if (_internal_has_whiteboard()) {
    clear_has_Ob();
    ::JournalData::BoardSizeData* temp = _impl_.Ob_.whiteboard_;
    _impl_.Ob_.whiteboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_whiteboard(::JournalData::BoardSizeData* whiteboard) {
  clear_Ob();
  if (whiteboard) {
    set_has_whiteboard();
    _impl_.Ob_.whiteboard_ = whiteboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.whiteboard)
}
inline ::JournalData::BoardSizeData* ObjectType::_internal_mutable_whiteboard() {
  if (!_internal_has_whiteboard()) {
    clear_Ob();
    set_has_whiteboard();
    _impl_.Ob_.whiteboard_ = CreateMaybeMessage< ::JournalData::BoardSizeData >(GetArenaForAllocation());
  }
  return _impl_.Ob_.whiteboard_;
}
inline ::JournalData::BoardSizeData* ObjectType::mutable_whiteboard() {
  ::JournalData::BoardSizeData* _msg = _internal_mutable_whiteboard();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.whiteboard)
  return _msg;
}

// .JournalData.ObjectType.StreamBoardObjectType streamBoardOwner = 3;
inline bool ObjectType::_internal_has_streamboardowner() const {
  return Ob_case() == kStreamBoardOwner;
}
inline bool ObjectType::has_streamboardowner() const {
  return _internal_has_streamboardowner();
}
inline void ObjectType::set_has_streamboardowner() {
  _impl_._oneof_case_[0] = kStreamBoardOwner;
}
inline void ObjectType::clear_streamboardowner() {
  if (_internal_has_streamboardowner()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.streamboardowner_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::ObjectType_StreamBoardObjectType* ObjectType::release_streamboardowner() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.streamBoardOwner)
  if (_internal_has_streamboardowner()) {
    clear_has_Ob();
    ::JournalData::ObjectType_StreamBoardObjectType* temp = _impl_.Ob_.streamboardowner_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.streamboardowner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::ObjectType_StreamBoardObjectType& ObjectType::_internal_streamboardowner() const {
  return _internal_has_streamboardowner()
      ? *_impl_.Ob_.streamboardowner_
      : reinterpret_cast< ::JournalData::ObjectType_StreamBoardObjectType&>(::JournalData::_ObjectType_StreamBoardObjectType_default_instance_);
}
inline const ::JournalData::ObjectType_StreamBoardObjectType& ObjectType::streamboardowner() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.streamBoardOwner)
  return _internal_streamboardowner();
}
inline ::JournalData::ObjectType_StreamBoardObjectType* ObjectType::unsafe_arena_release_streamboardowner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.streamBoardOwner)
  if (_internal_has_streamboardowner()) {
    clear_has_Ob();
    ::JournalData::ObjectType_StreamBoardObjectType* temp = _impl_.Ob_.streamboardowner_;
    _impl_.Ob_.streamboardowner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_streamboardowner(::JournalData::ObjectType_StreamBoardObjectType* streamboardowner) {
  clear_Ob();
  if (streamboardowner) {
    set_has_streamboardowner();
    _impl_.Ob_.streamboardowner_ = streamboardowner;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.streamBoardOwner)
}
inline ::JournalData::ObjectType_StreamBoardObjectType* ObjectType::_internal_mutable_streamboardowner() {
  if (!_internal_has_streamboardowner()) {
    clear_Ob();
    set_has_streamboardowner();
    _impl_.Ob_.streamboardowner_ = CreateMaybeMessage< ::JournalData::ObjectType_StreamBoardObjectType >(GetArenaForAllocation());
  }
  return _impl_.Ob_.streamboardowner_;
}
inline ::JournalData::ObjectType_StreamBoardObjectType* ObjectType::mutable_streamboardowner() {
  ::JournalData::ObjectType_StreamBoardObjectType* _msg = _internal_mutable_streamboardowner();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.streamBoardOwner)
  return _msg;
}

// bool userBoard = 6;
inline bool ObjectType::_internal_has_userboard() const {
  return Ob_case() == kUserBoard;
}
inline bool ObjectType::has_userboard() const {
  return _internal_has_userboard();
}
inline void ObjectType::set_has_userboard() {
  _impl_._oneof_case_[0] = kUserBoard;
}
inline void ObjectType::clear_userboard() {
  if (_internal_has_userboard()) {
    _impl_.Ob_.userboard_ = false;
    clear_has_Ob();
  }
}
inline bool ObjectType::_internal_userboard() const {
  if (_internal_has_userboard()) {
    return _impl_.Ob_.userboard_;
  }
  return false;
}
inline void ObjectType::_internal_set_userboard(bool value) {
  if (!_internal_has_userboard()) {
    clear_Ob();
    set_has_userboard();
  }
  _impl_.Ob_.userboard_ = value;
}
inline bool ObjectType::userboard() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.userBoard)
  return _internal_userboard();
}
inline void ObjectType::set_userboard(bool value) {
  _internal_set_userboard(value);
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.userBoard)
}

// .JournalData.Progress objectProgress = 7;
inline bool ObjectType::_internal_has_objectprogress() const {
  return Ob_case() == kObjectProgress;
}
inline bool ObjectType::has_objectprogress() const {
  return _internal_has_objectprogress();
}
inline void ObjectType::set_has_objectprogress() {
  _impl_._oneof_case_[0] = kObjectProgress;
}
inline void ObjectType::clear_objectprogress() {
  if (_internal_has_objectprogress()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.objectprogress_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::Progress* ObjectType::release_objectprogress() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.objectProgress)
  if (_internal_has_objectprogress()) {
    clear_has_Ob();
    ::JournalData::Progress* temp = _impl_.Ob_.objectprogress_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.objectprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress& ObjectType::_internal_objectprogress() const {
  return _internal_has_objectprogress()
      ? *_impl_.Ob_.objectprogress_
      : reinterpret_cast< ::JournalData::Progress&>(::JournalData::_Progress_default_instance_);
}
inline const ::JournalData::Progress& ObjectType::objectprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.objectProgress)
  return _internal_objectprogress();
}
inline ::JournalData::Progress* ObjectType::unsafe_arena_release_objectprogress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.objectProgress)
  if (_internal_has_objectprogress()) {
    clear_has_Ob();
    ::JournalData::Progress* temp = _impl_.Ob_.objectprogress_;
    _impl_.Ob_.objectprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_objectprogress(::JournalData::Progress* objectprogress) {
  clear_Ob();
  if (objectprogress) {
    set_has_objectprogress();
    _impl_.Ob_.objectprogress_ = objectprogress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.objectProgress)
}
inline ::JournalData::Progress* ObjectType::_internal_mutable_objectprogress() {
  if (!_internal_has_objectprogress()) {
    clear_Ob();
    set_has_objectprogress();
    _impl_.Ob_.objectprogress_ = CreateMaybeMessage< ::JournalData::Progress >(GetArenaForAllocation());
  }
  return _impl_.Ob_.objectprogress_;
}
inline ::JournalData::Progress* ObjectType::mutable_objectprogress() {
  ::JournalData::Progress* _msg = _internal_mutable_objectprogress();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.objectProgress)
  return _msg;
}

// .JournalData.Progress boardProgress = 8;
inline bool ObjectType::_internal_has_boardprogress() const {
  return Ob_case() == kBoardProgress;
}
inline bool ObjectType::has_boardprogress() const {
  return _internal_has_boardprogress();
}
inline void ObjectType::set_has_boardprogress() {
  _impl_._oneof_case_[0] = kBoardProgress;
}
inline void ObjectType::clear_boardprogress() {
  if (_internal_has_boardprogress()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.boardprogress_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::Progress* ObjectType::release_boardprogress() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.boardProgress)
  if (_internal_has_boardprogress()) {
    clear_has_Ob();
    ::JournalData::Progress* temp = _impl_.Ob_.boardprogress_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.boardprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress& ObjectType::_internal_boardprogress() const {
  return _internal_has_boardprogress()
      ? *_impl_.Ob_.boardprogress_
      : reinterpret_cast< ::JournalData::Progress&>(::JournalData::_Progress_default_instance_);
}
inline const ::JournalData::Progress& ObjectType::boardprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.boardProgress)
  return _internal_boardprogress();
}
inline ::JournalData::Progress* ObjectType::unsafe_arena_release_boardprogress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.boardProgress)
  if (_internal_has_boardprogress()) {
    clear_has_Ob();
    ::JournalData::Progress* temp = _impl_.Ob_.boardprogress_;
    _impl_.Ob_.boardprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_boardprogress(::JournalData::Progress* boardprogress) {
  clear_Ob();
  if (boardprogress) {
    set_has_boardprogress();
    _impl_.Ob_.boardprogress_ = boardprogress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.boardProgress)
}
inline ::JournalData::Progress* ObjectType::_internal_mutable_boardprogress() {
  if (!_internal_has_boardprogress()) {
    clear_Ob();
    set_has_boardprogress();
    _impl_.Ob_.boardprogress_ = CreateMaybeMessage< ::JournalData::Progress >(GetArenaForAllocation());
  }
  return _impl_.Ob_.boardprogress_;
}
inline ::JournalData::Progress* ObjectType::mutable_boardprogress() {
  ::JournalData::Progress* _msg = _internal_mutable_boardprogress();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.boardProgress)
  return _msg;
}

// .JournalData.ObjectType.TextBoardObjectType textboard = 10;
inline bool ObjectType::_internal_has_textboard() const {
  return Ob_case() == kTextboard;
}
inline bool ObjectType::has_textboard() const {
  return _internal_has_textboard();
}
inline void ObjectType::set_has_textboard() {
  _impl_._oneof_case_[0] = kTextboard;
}
inline void ObjectType::clear_textboard() {
  if (_internal_has_textboard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.textboard_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::ObjectType_TextBoardObjectType* ObjectType::release_textboard() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.textboard)
  if (_internal_has_textboard()) {
    clear_has_Ob();
    ::JournalData::ObjectType_TextBoardObjectType* temp = _impl_.Ob_.textboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.textboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::ObjectType_TextBoardObjectType& ObjectType::_internal_textboard() const {
  return _internal_has_textboard()
      ? *_impl_.Ob_.textboard_
      : reinterpret_cast< ::JournalData::ObjectType_TextBoardObjectType&>(::JournalData::_ObjectType_TextBoardObjectType_default_instance_);
}
inline const ::JournalData::ObjectType_TextBoardObjectType& ObjectType::textboard() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.textboard)
  return _internal_textboard();
}
inline ::JournalData::ObjectType_TextBoardObjectType* ObjectType::unsafe_arena_release_textboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.textboard)
  if (_internal_has_textboard()) {
    clear_has_Ob();
    ::JournalData::ObjectType_TextBoardObjectType* temp = _impl_.Ob_.textboard_;
    _impl_.Ob_.textboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_textboard(::JournalData::ObjectType_TextBoardObjectType* textboard) {
  clear_Ob();
  if (textboard) {
    set_has_textboard();
    _impl_.Ob_.textboard_ = textboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.textboard)
}
inline ::JournalData::ObjectType_TextBoardObjectType* ObjectType::_internal_mutable_textboard() {
  if (!_internal_has_textboard()) {
    clear_Ob();
    set_has_textboard();
    _impl_.Ob_.textboard_ = CreateMaybeMessage< ::JournalData::ObjectType_TextBoardObjectType >(GetArenaForAllocation());
  }
  return _impl_.Ob_.textboard_;
}
inline ::JournalData::ObjectType_TextBoardObjectType* ObjectType::mutable_textboard() {
  ::JournalData::ObjectType_TextBoardObjectType* _msg = _internal_mutable_textboard();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.textboard)
  return _msg;
}

// .JournalData.ObjectType.ArTrackerObjectType arTracker = 15;
inline bool ObjectType::_internal_has_artracker() const {
  return Ob_case() == kArTracker;
}
inline bool ObjectType::has_artracker() const {
  return _internal_has_artracker();
}
inline void ObjectType::set_has_artracker() {
  _impl_._oneof_case_[0] = kArTracker;
}
inline void ObjectType::clear_artracker() {
  if (_internal_has_artracker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.artracker_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::ObjectType_ArTrackerObjectType* ObjectType::release_artracker() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.arTracker)
  if (_internal_has_artracker()) {
    clear_has_Ob();
    ::JournalData::ObjectType_ArTrackerObjectType* temp = _impl_.Ob_.artracker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.artracker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::ObjectType_ArTrackerObjectType& ObjectType::_internal_artracker() const {
  return _internal_has_artracker()
      ? *_impl_.Ob_.artracker_
      : reinterpret_cast< ::JournalData::ObjectType_ArTrackerObjectType&>(::JournalData::_ObjectType_ArTrackerObjectType_default_instance_);
}
inline const ::JournalData::ObjectType_ArTrackerObjectType& ObjectType::artracker() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.arTracker)
  return _internal_artracker();
}
inline ::JournalData::ObjectType_ArTrackerObjectType* ObjectType::unsafe_arena_release_artracker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.arTracker)
  if (_internal_has_artracker()) {
    clear_has_Ob();
    ::JournalData::ObjectType_ArTrackerObjectType* temp = _impl_.Ob_.artracker_;
    _impl_.Ob_.artracker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_artracker(::JournalData::ObjectType_ArTrackerObjectType* artracker) {
  clear_Ob();
  if (artracker) {
    set_has_artracker();
    _impl_.Ob_.artracker_ = artracker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.arTracker)
}
inline ::JournalData::ObjectType_ArTrackerObjectType* ObjectType::_internal_mutable_artracker() {
  if (!_internal_has_artracker()) {
    clear_Ob();
    set_has_artracker();
    _impl_.Ob_.artracker_ = CreateMaybeMessage< ::JournalData::ObjectType_ArTrackerObjectType >(GetArenaForAllocation());
  }
  return _impl_.Ob_.artracker_;
}
inline ::JournalData::ObjectType_ArTrackerObjectType* ObjectType::mutable_artracker() {
  ::JournalData::ObjectType_ArTrackerObjectType* _msg = _internal_mutable_artracker();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.arTracker)
  return _msg;
}

// string contentIdAsset = 20;
inline bool ObjectType::_internal_has_contentidasset() const {
  return Ob_case() == kContentIdAsset;
}
inline bool ObjectType::has_contentidasset() const {
  return _internal_has_contentidasset();
}
inline void ObjectType::set_has_contentidasset() {
  _impl_._oneof_case_[0] = kContentIdAsset;
}
inline void ObjectType::clear_contentidasset() {
  if (_internal_has_contentidasset()) {
    _impl_.Ob_.contentidasset_.Destroy();
    clear_has_Ob();
  }
}
inline const std::string& ObjectType::contentidasset() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.contentIdAsset)
  return _internal_contentidasset();
}
template <typename ArgT0, typename... ArgT>
inline void ObjectType::set_contentidasset(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contentidasset()) {
    clear_Ob();
    set_has_contentidasset();
    _impl_.Ob_.contentidasset_.InitDefault();
  }
  _impl_.Ob_.contentidasset_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.contentIdAsset)
}
inline std::string* ObjectType::mutable_contentidasset() {
  std::string* _s = _internal_mutable_contentidasset();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.contentIdAsset)
  return _s;
}
inline const std::string& ObjectType::_internal_contentidasset() const {
  if (_internal_has_contentidasset()) {
    return _impl_.Ob_.contentidasset_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ObjectType::_internal_set_contentidasset(const std::string& value) {
  if (!_internal_has_contentidasset()) {
    clear_Ob();
    set_has_contentidasset();
    _impl_.Ob_.contentidasset_.InitDefault();
  }
  _impl_.Ob_.contentidasset_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType::_internal_mutable_contentidasset() {
  if (!_internal_has_contentidasset()) {
    clear_Ob();
    set_has_contentidasset();
    _impl_.Ob_.contentidasset_.InitDefault();
  }
  return _impl_.Ob_.contentidasset_.Mutable(      GetArenaForAllocation());
}
inline std::string* ObjectType::release_contentidasset() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.contentIdAsset)
  if (_internal_has_contentidasset()) {
    clear_has_Ob();
    return _impl_.Ob_.contentidasset_.Release();
  } else {
    return nullptr;
  }
}
inline void ObjectType::set_allocated_contentidasset(std::string* contentidasset) {
  if (has_Ob()) {
    clear_Ob();
  }
  if (contentidasset != nullptr) {
    set_has_contentidasset();
    _impl_.Ob_.contentidasset_.InitAllocated(contentidasset, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.contentIdAsset)
}

// .JournalData.ObjectType.CustomContentId customContentId = 21;
inline bool ObjectType::_internal_has_customcontentid() const {
  return Ob_case() == kCustomContentId;
}
inline bool ObjectType::has_customcontentid() const {
  return _internal_has_customcontentid();
}
inline void ObjectType::set_has_customcontentid() {
  _impl_._oneof_case_[0] = kCustomContentId;
}
inline void ObjectType::clear_customcontentid() {
  if (_internal_has_customcontentid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.customcontentid_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::ObjectType_CustomContentId* ObjectType::release_customcontentid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.customContentId)
  if (_internal_has_customcontentid()) {
    clear_has_Ob();
    ::JournalData::ObjectType_CustomContentId* temp = _impl_.Ob_.customcontentid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.customcontentid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::ObjectType_CustomContentId& ObjectType::_internal_customcontentid() const {
  return _internal_has_customcontentid()
      ? *_impl_.Ob_.customcontentid_
      : reinterpret_cast< ::JournalData::ObjectType_CustomContentId&>(::JournalData::_ObjectType_CustomContentId_default_instance_);
}
inline const ::JournalData::ObjectType_CustomContentId& ObjectType::customcontentid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.customContentId)
  return _internal_customcontentid();
}
inline ::JournalData::ObjectType_CustomContentId* ObjectType::unsafe_arena_release_customcontentid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.customContentId)
  if (_internal_has_customcontentid()) {
    clear_has_Ob();
    ::JournalData::ObjectType_CustomContentId* temp = _impl_.Ob_.customcontentid_;
    _impl_.Ob_.customcontentid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_customcontentid(::JournalData::ObjectType_CustomContentId* customcontentid) {
  clear_Ob();
  if (customcontentid) {
    set_has_customcontentid();
    _impl_.Ob_.customcontentid_ = customcontentid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.customContentId)
}
inline ::JournalData::ObjectType_CustomContentId* ObjectType::_internal_mutable_customcontentid() {
  if (!_internal_has_customcontentid()) {
    clear_Ob();
    set_has_customcontentid();
    _impl_.Ob_.customcontentid_ = CreateMaybeMessage< ::JournalData::ObjectType_CustomContentId >(GetArenaForAllocation());
  }
  return _impl_.Ob_.customcontentid_;
}
inline ::JournalData::ObjectType_CustomContentId* ObjectType::mutable_customcontentid() {
  ::JournalData::ObjectType_CustomContentId* _msg = _internal_mutable_customcontentid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.customContentId)
  return _msg;
}

// .JournalData.ObjectType.ChatMessageObjectType chatMessage = 50;
inline bool ObjectType::_internal_has_chatmessage() const {
  return Ob_case() == kChatMessage;
}
inline bool ObjectType::has_chatmessage() const {
  return _internal_has_chatmessage();
}
inline void ObjectType::set_has_chatmessage() {
  _impl_._oneof_case_[0] = kChatMessage;
}
inline void ObjectType::clear_chatmessage() {
  if (_internal_has_chatmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Ob_.chatmessage_;
    }
    clear_has_Ob();
  }
}
inline ::JournalData::ObjectType_ChatMessageObjectType* ObjectType::release_chatmessage() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.chatMessage)
  if (_internal_has_chatmessage()) {
    clear_has_Ob();
    ::JournalData::ObjectType_ChatMessageObjectType* temp = _impl_.Ob_.chatmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Ob_.chatmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::ObjectType_ChatMessageObjectType& ObjectType::_internal_chatmessage() const {
  return _internal_has_chatmessage()
      ? *_impl_.Ob_.chatmessage_
      : reinterpret_cast< ::JournalData::ObjectType_ChatMessageObjectType&>(::JournalData::_ObjectType_ChatMessageObjectType_default_instance_);
}
inline const ::JournalData::ObjectType_ChatMessageObjectType& ObjectType::chatmessage() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.chatMessage)
  return _internal_chatmessage();
}
inline ::JournalData::ObjectType_ChatMessageObjectType* ObjectType::unsafe_arena_release_chatmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ObjectType.chatMessage)
  if (_internal_has_chatmessage()) {
    clear_has_Ob();
    ::JournalData::ObjectType_ChatMessageObjectType* temp = _impl_.Ob_.chatmessage_;
    _impl_.Ob_.chatmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectType::unsafe_arena_set_allocated_chatmessage(::JournalData::ObjectType_ChatMessageObjectType* chatmessage) {
  clear_Ob();
  if (chatmessage) {
    set_has_chatmessage();
    _impl_.Ob_.chatmessage_ = chatmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectType.chatMessage)
}
inline ::JournalData::ObjectType_ChatMessageObjectType* ObjectType::_internal_mutable_chatmessage() {
  if (!_internal_has_chatmessage()) {
    clear_Ob();
    set_has_chatmessage();
    _impl_.Ob_.chatmessage_ = CreateMaybeMessage< ::JournalData::ObjectType_ChatMessageObjectType >(GetArenaForAllocation());
  }
  return _impl_.Ob_.chatmessage_;
}
inline ::JournalData::ObjectType_ChatMessageObjectType* ObjectType::mutable_chatmessage() {
  ::JournalData::ObjectType_ChatMessageObjectType* _msg = _internal_mutable_chatmessage();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.chatMessage)
  return _msg;
}

// bool blankMaterial = 100;
inline bool ObjectType::_internal_has_blankmaterial() const {
  return Ob_case() == kBlankMaterial;
}
inline bool ObjectType::has_blankmaterial() const {
  return _internal_has_blankmaterial();
}
inline void ObjectType::set_has_blankmaterial() {
  _impl_._oneof_case_[0] = kBlankMaterial;
}
inline void ObjectType::clear_blankmaterial() {
  if (_internal_has_blankmaterial()) {
    _impl_.Ob_.blankmaterial_ = false;
    clear_has_Ob();
  }
}
inline bool ObjectType::_internal_blankmaterial() const {
  if (_internal_has_blankmaterial()) {
    return _impl_.Ob_.blankmaterial_;
  }
  return false;
}
inline void ObjectType::_internal_set_blankmaterial(bool value) {
  if (!_internal_has_blankmaterial()) {
    clear_Ob();
    set_has_blankmaterial();
  }
  _impl_.Ob_.blankmaterial_ = value;
}
inline bool ObjectType::blankmaterial() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.blankMaterial)
  return _internal_blankmaterial();
}
inline void ObjectType::set_blankmaterial(bool value) {
  _internal_set_blankmaterial(value);
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.blankMaterial)
}

// string wellKnownObjectId = 500;
inline bool ObjectType::_internal_has_wellknownobjectid() const {
  return Ob_case() == kWellKnownObjectId;
}
inline bool ObjectType::has_wellknownobjectid() const {
  return _internal_has_wellknownobjectid();
}
inline void ObjectType::set_has_wellknownobjectid() {
  _impl_._oneof_case_[0] = kWellKnownObjectId;
}
inline void ObjectType::clear_wellknownobjectid() {
  if (_internal_has_wellknownobjectid()) {
    _impl_.Ob_.wellknownobjectid_.Destroy();
    clear_has_Ob();
  }
}
inline const std::string& ObjectType::wellknownobjectid() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.wellKnownObjectId)
  return _internal_wellknownobjectid();
}
template <typename ArgT0, typename... ArgT>
inline void ObjectType::set_wellknownobjectid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_wellknownobjectid()) {
    clear_Ob();
    set_has_wellknownobjectid();
    _impl_.Ob_.wellknownobjectid_.InitDefault();
  }
  _impl_.Ob_.wellknownobjectid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.wellKnownObjectId)
}
inline std::string* ObjectType::mutable_wellknownobjectid() {
  std::string* _s = _internal_mutable_wellknownobjectid();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.wellKnownObjectId)
  return _s;
}
inline const std::string& ObjectType::_internal_wellknownobjectid() const {
  if (_internal_has_wellknownobjectid()) {
    return _impl_.Ob_.wellknownobjectid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ObjectType::_internal_set_wellknownobjectid(const std::string& value) {
  if (!_internal_has_wellknownobjectid()) {
    clear_Ob();
    set_has_wellknownobjectid();
    _impl_.Ob_.wellknownobjectid_.InitDefault();
  }
  _impl_.Ob_.wellknownobjectid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType::_internal_mutable_wellknownobjectid() {
  if (!_internal_has_wellknownobjectid()) {
    clear_Ob();
    set_has_wellknownobjectid();
    _impl_.Ob_.wellknownobjectid_.InitDefault();
  }
  return _impl_.Ob_.wellknownobjectid_.Mutable(      GetArenaForAllocation());
}
inline std::string* ObjectType::release_wellknownobjectid() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.wellKnownObjectId)
  if (_internal_has_wellknownobjectid()) {
    clear_has_Ob();
    return _impl_.Ob_.wellknownobjectid_.Release();
  } else {
    return nullptr;
  }
}
inline void ObjectType::set_allocated_wellknownobjectid(std::string* wellknownobjectid) {
  if (has_Ob()) {
    clear_Ob();
  }
  if (wellknownobjectid != nullptr) {
    set_has_wellknownobjectid();
    _impl_.Ob_.wellknownobjectid_.InitAllocated(wellknownobjectid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.wellKnownObjectId)
}

// string url = 501;
inline bool ObjectType::_internal_has_url() const {
  return Ob_case() == kUrl;
}
inline bool ObjectType::has_url() const {
  return _internal_has_url();
}
inline void ObjectType::set_has_url() {
  _impl_._oneof_case_[0] = kUrl;
}
inline void ObjectType::clear_url() {
  if (_internal_has_url()) {
    _impl_.Ob_.url_.Destroy();
    clear_has_Ob();
  }
}
inline const std::string& ObjectType::url() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectType.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline void ObjectType::set_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_url()) {
    clear_Ob();
    set_has_url();
    _impl_.Ob_.url_.InitDefault();
  }
  _impl_.Ob_.url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ObjectType.url)
}
inline std::string* ObjectType::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectType.url)
  return _s;
}
inline const std::string& ObjectType::_internal_url() const {
  if (_internal_has_url()) {
    return _impl_.Ob_.url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ObjectType::_internal_set_url(const std::string& value) {
  if (!_internal_has_url()) {
    clear_Ob();
    set_has_url();
    _impl_.Ob_.url_.InitDefault();
  }
  _impl_.Ob_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectType::_internal_mutable_url() {
  if (!_internal_has_url()) {
    clear_Ob();
    set_has_url();
    _impl_.Ob_.url_.InitDefault();
  }
  return _impl_.Ob_.url_.Mutable(      GetArenaForAllocation());
}
inline std::string* ObjectType::release_url() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectType.url)
  if (_internal_has_url()) {
    clear_has_Ob();
    return _impl_.Ob_.url_.Release();
  } else {
    return nullptr;
  }
}
inline void ObjectType::set_allocated_url(std::string* url) {
  if (has_Ob()) {
    clear_Ob();
  }
  if (url != nullptr) {
    set_has_url();
    _impl_.Ob_.url_.InitAllocated(url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectType.url)
}

inline bool ObjectType::has_Ob() const {
  return Ob_case() != OB_NOT_SET;
}
inline void ObjectType::clear_has_Ob() {
  _impl_._oneof_case_[0] = OB_NOT_SET;
}
inline ObjectType::ObCase ObjectType::Ob_case() const {
  return ObjectType::ObCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BoardSizeData

// .Common.Float2 aspectRatio = 1;
inline bool BoardSizeData::_internal_has_aspectratio() const {
  return this != internal_default_instance() && _impl_.aspectratio_ != nullptr;
}
inline bool BoardSizeData::has_aspectratio() const {
  return _internal_has_aspectratio();
}
inline const ::Common::Float2& BoardSizeData::_internal_aspectratio() const {
  const ::Common::Float2* p = _impl_.aspectratio_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float2&>(
      ::Common::_Float2_default_instance_);
}
inline const ::Common::Float2& BoardSizeData::aspectratio() const {
  // @@protoc_insertion_point(field_get:JournalData.BoardSizeData.aspectRatio)
  return _internal_aspectratio();
}
inline void BoardSizeData::unsafe_arena_set_allocated_aspectratio(
    ::Common::Float2* aspectratio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aspectratio_);
  }
  _impl_.aspectratio_ = aspectratio;
  if (aspectratio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.BoardSizeData.aspectRatio)
}
inline ::Common::Float2* BoardSizeData::release_aspectratio() {
  
  ::Common::Float2* temp = _impl_.aspectratio_;
  _impl_.aspectratio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float2* BoardSizeData::unsafe_arena_release_aspectratio() {
  // @@protoc_insertion_point(field_release:JournalData.BoardSizeData.aspectRatio)
  
  ::Common::Float2* temp = _impl_.aspectratio_;
  _impl_.aspectratio_ = nullptr;
  return temp;
}
inline ::Common::Float2* BoardSizeData::_internal_mutable_aspectratio() {
  
  if (_impl_.aspectratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float2>(GetArenaForAllocation());
    _impl_.aspectratio_ = p;
  }
  return _impl_.aspectratio_;
}
inline ::Common::Float2* BoardSizeData::mutable_aspectratio() {
  ::Common::Float2* _msg = _internal_mutable_aspectratio();
  // @@protoc_insertion_point(field_mutable:JournalData.BoardSizeData.aspectRatio)
  return _msg;
}
inline void BoardSizeData::set_allocated_aspectratio(::Common::Float2* aspectratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aspectratio_);
  }
  if (aspectratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aspectratio));
    if (message_arena != submessage_arena) {
      aspectratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aspectratio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.aspectratio_ = aspectratio;
  // @@protoc_insertion_point(field_set_allocated:JournalData.BoardSizeData.aspectRatio)
}

// float boardSizeScaler = 2;
inline void BoardSizeData::clear_boardsizescaler() {
  _impl_.boardsizescaler_ = 0;
}
inline float BoardSizeData::_internal_boardsizescaler() const {
  return _impl_.boardsizescaler_;
}
inline float BoardSizeData::boardsizescaler() const {
  // @@protoc_insertion_point(field_get:JournalData.BoardSizeData.boardSizeScaler)
  return _internal_boardsizescaler();
}
inline void BoardSizeData::_internal_set_boardsizescaler(float value) {
  
  _impl_.boardsizescaler_ = value;
}
inline void BoardSizeData::set_boardsizescaler(float value) {
  _internal_set_boardsizescaler(value);
  // @@protoc_insertion_point(field_set:JournalData.BoardSizeData.boardSizeScaler)
}

// -------------------------------------------------------------------

// ImageContentType

// string contentId = 1;
inline bool ImageContentType::_internal_has_contentid() const {
  return Im_case() == kContentId;
}
inline bool ImageContentType::has_contentid() const {
  return _internal_has_contentid();
}
inline void ImageContentType::set_has_contentid() {
  _impl_._oneof_case_[0] = kContentId;
}
inline void ImageContentType::clear_contentid() {
  if (_internal_has_contentid()) {
    _impl_.Im_.contentid_.Destroy();
    clear_has_Im();
  }
}
inline const std::string& ImageContentType::contentid() const {
  // @@protoc_insertion_point(field_get:JournalData.ImageContentType.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline void ImageContentType::set_contentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  _impl_.Im_.contentid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.ImageContentType.contentId)
}
inline std::string* ImageContentType::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:JournalData.ImageContentType.contentId)
  return _s;
}
inline const std::string& ImageContentType::_internal_contentid() const {
  if (_internal_has_contentid()) {
    return _impl_.Im_.contentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ImageContentType::_internal_set_contentid(const std::string& value) {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  _impl_.Im_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageContentType::_internal_mutable_contentid() {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  return _impl_.Im_.contentid_.Mutable(      GetArenaForAllocation());
}
inline std::string* ImageContentType::release_contentid() {
  // @@protoc_insertion_point(field_release:JournalData.ImageContentType.contentId)
  if (_internal_has_contentid()) {
    clear_has_Im();
    return _impl_.Im_.contentid_.Release();
  } else {
    return nullptr;
  }
}
inline void ImageContentType::set_allocated_contentid(std::string* contentid) {
  if (has_Im()) {
    clear_Im();
  }
  if (contentid != nullptr) {
    set_has_contentid();
    _impl_.Im_.contentid_.InitAllocated(contentid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.ImageContentType.contentId)
}

// .JournalData.Progress imageProgress = 2;
inline bool ImageContentType::_internal_has_imageprogress() const {
  return Im_case() == kImageProgress;
}
inline bool ImageContentType::has_imageprogress() const {
  return _internal_has_imageprogress();
}
inline void ImageContentType::set_has_imageprogress() {
  _impl_._oneof_case_[0] = kImageProgress;
}
inline void ImageContentType::clear_imageprogress() {
  if (_internal_has_imageprogress()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Im_.imageprogress_;
    }
    clear_has_Im();
  }
}
inline ::JournalData::Progress* ImageContentType::release_imageprogress() {
  // @@protoc_insertion_point(field_release:JournalData.ImageContentType.imageProgress)
  if (_internal_has_imageprogress()) {
    clear_has_Im();
    ::JournalData::Progress* temp = _impl_.Im_.imageprogress_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Im_.imageprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress& ImageContentType::_internal_imageprogress() const {
  return _internal_has_imageprogress()
      ? *_impl_.Im_.imageprogress_
      : reinterpret_cast< ::JournalData::Progress&>(::JournalData::_Progress_default_instance_);
}
inline const ::JournalData::Progress& ImageContentType::imageprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.ImageContentType.imageProgress)
  return _internal_imageprogress();
}
inline ::JournalData::Progress* ImageContentType::unsafe_arena_release_imageprogress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.ImageContentType.imageProgress)
  if (_internal_has_imageprogress()) {
    clear_has_Im();
    ::JournalData::Progress* temp = _impl_.Im_.imageprogress_;
    _impl_.Im_.imageprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageContentType::unsafe_arena_set_allocated_imageprogress(::JournalData::Progress* imageprogress) {
  clear_Im();
  if (imageprogress) {
    set_has_imageprogress();
    _impl_.Im_.imageprogress_ = imageprogress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ImageContentType.imageProgress)
}
inline ::JournalData::Progress* ImageContentType::_internal_mutable_imageprogress() {
  if (!_internal_has_imageprogress()) {
    clear_Im();
    set_has_imageprogress();
    _impl_.Im_.imageprogress_ = CreateMaybeMessage< ::JournalData::Progress >(GetArenaForAllocation());
  }
  return _impl_.Im_.imageprogress_;
}
inline ::JournalData::Progress* ImageContentType::mutable_imageprogress() {
  ::JournalData::Progress* _msg = _internal_mutable_imageprogress();
  // @@protoc_insertion_point(field_mutable:JournalData.ImageContentType.imageProgress)
  return _msg;
}

inline bool ImageContentType::has_Im() const {
  return Im_case() != IM_NOT_SET;
}
inline void ImageContentType::clear_has_Im() {
  _impl_._oneof_case_[0] = IM_NOT_SET;
}
inline ImageContentType::ImCase ImageContentType::Im_case() const {
  return ImageContentType::ImCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Image2dPlacementData

// .JournalData.ObjectId objectId = 1;
inline bool Image2dPlacementData::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool Image2dPlacementData::has_objectid() const {
  return _internal_has_objectid();
}
inline void Image2dPlacementData::clear_objectid() {
  if (GetArenaForAllocation() == nullptr && _impl_.objectid_ != nullptr) {
    delete _impl_.objectid_;
  }
  _impl_.objectid_ = nullptr;
}
inline const ::JournalData::ObjectId& Image2dPlacementData::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& Image2dPlacementData::objectid() const {
  // @@protoc_insertion_point(field_get:JournalData.Image2dPlacementData.objectId)
  return _internal_objectid();
}
inline void Image2dPlacementData::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.Image2dPlacementData.objectId)
}
inline ::JournalData::ObjectId* Image2dPlacementData::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* Image2dPlacementData::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:JournalData.Image2dPlacementData.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* Image2dPlacementData::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* Image2dPlacementData::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:JournalData.Image2dPlacementData.objectId)
  return _msg;
}
inline void Image2dPlacementData::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.objectid_;
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(objectid);
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:JournalData.Image2dPlacementData.objectId)
}

// .JournalData.BoardState visibleWithinState = 2;
inline bool Image2dPlacementData::_internal_has_visiblewithinstate() const {
  return this != internal_default_instance() && _impl_.visiblewithinstate_ != nullptr;
}
inline bool Image2dPlacementData::has_visiblewithinstate() const {
  return _internal_has_visiblewithinstate();
}
inline void Image2dPlacementData::clear_visiblewithinstate() {
  if (GetArenaForAllocation() == nullptr && _impl_.visiblewithinstate_ != nullptr) {
    delete _impl_.visiblewithinstate_;
  }
  _impl_.visiblewithinstate_ = nullptr;
}
inline const ::JournalData::BoardState& Image2dPlacementData::_internal_visiblewithinstate() const {
  const ::JournalData::BoardState* p = _impl_.visiblewithinstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::BoardState&>(
      ::JournalData::_BoardState_default_instance_);
}
inline const ::JournalData::BoardState& Image2dPlacementData::visiblewithinstate() const {
  // @@protoc_insertion_point(field_get:JournalData.Image2dPlacementData.visibleWithinState)
  return _internal_visiblewithinstate();
}
inline void Image2dPlacementData::unsafe_arena_set_allocated_visiblewithinstate(
    ::JournalData::BoardState* visiblewithinstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visiblewithinstate_);
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  if (visiblewithinstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.Image2dPlacementData.visibleWithinState)
}
inline ::JournalData::BoardState* Image2dPlacementData::release_visiblewithinstate() {
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::BoardState* Image2dPlacementData::unsafe_arena_release_visiblewithinstate() {
  // @@protoc_insertion_point(field_release:JournalData.Image2dPlacementData.visibleWithinState)
  
  ::JournalData::BoardState* temp = _impl_.visiblewithinstate_;
  _impl_.visiblewithinstate_ = nullptr;
  return temp;
}
inline ::JournalData::BoardState* Image2dPlacementData::_internal_mutable_visiblewithinstate() {
  
  if (_impl_.visiblewithinstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::BoardState>(GetArenaForAllocation());
    _impl_.visiblewithinstate_ = p;
  }
  return _impl_.visiblewithinstate_;
}
inline ::JournalData::BoardState* Image2dPlacementData::mutable_visiblewithinstate() {
  ::JournalData::BoardState* _msg = _internal_mutable_visiblewithinstate();
  // @@protoc_insertion_point(field_mutable:JournalData.Image2dPlacementData.visibleWithinState)
  return _msg;
}
inline void Image2dPlacementData::set_allocated_visiblewithinstate(::JournalData::BoardState* visiblewithinstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visiblewithinstate_;
  }
  if (visiblewithinstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visiblewithinstate);
    if (message_arena != submessage_arena) {
      visiblewithinstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visiblewithinstate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visiblewithinstate_ = visiblewithinstate;
  // @@protoc_insertion_point(field_set_allocated:JournalData.Image2dPlacementData.visibleWithinState)
}

// .Common.Float2 point = 3;
inline bool Image2dPlacementData::_internal_has_point() const {
  return this != internal_default_instance() && _impl_.point_ != nullptr;
}
inline bool Image2dPlacementData::has_point() const {
  return _internal_has_point();
}
inline const ::Common::Float2& Image2dPlacementData::_internal_point() const {
  const ::Common::Float2* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float2&>(
      ::Common::_Float2_default_instance_);
}
inline const ::Common::Float2& Image2dPlacementData::point() const {
  // @@protoc_insertion_point(field_get:JournalData.Image2dPlacementData.point)
  return _internal_point();
}
inline void Image2dPlacementData::unsafe_arena_set_allocated_point(
    ::Common::Float2* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.Image2dPlacementData.point)
}
inline ::Common::Float2* Image2dPlacementData::release_point() {
  
  ::Common::Float2* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float2* Image2dPlacementData::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:JournalData.Image2dPlacementData.point)
  
  ::Common::Float2* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::Common::Float2* Image2dPlacementData::_internal_mutable_point() {
  
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float2>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::Common::Float2* Image2dPlacementData::mutable_point() {
  ::Common::Float2* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:JournalData.Image2dPlacementData.point)
  return _msg;
}
inline void Image2dPlacementData::set_allocated_point(::Common::Float2* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point));
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:JournalData.Image2dPlacementData.point)
}

// float height = 4;
inline void Image2dPlacementData::clear_height() {
  _impl_.height_ = 0;
}
inline float Image2dPlacementData::_internal_height() const {
  return _impl_.height_;
}
inline float Image2dPlacementData::height() const {
  // @@protoc_insertion_point(field_get:JournalData.Image2dPlacementData.height)
  return _internal_height();
}
inline void Image2dPlacementData::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void Image2dPlacementData::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:JournalData.Image2dPlacementData.height)
}

// float rotation = 5;
inline void Image2dPlacementData::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline float Image2dPlacementData::_internal_rotation() const {
  return _impl_.rotation_;
}
inline float Image2dPlacementData::rotation() const {
  // @@protoc_insertion_point(field_get:JournalData.Image2dPlacementData.rotation)
  return _internal_rotation();
}
inline void Image2dPlacementData::_internal_set_rotation(float value) {
  
  _impl_.rotation_ = value;
}
inline void Image2dPlacementData::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:JournalData.Image2dPlacementData.rotation)
}

// -------------------------------------------------------------------

// TagPlacementData

// .JournalData.ObjectId objectId = 1;
inline bool TagPlacementData::_internal_has_objectid() const {
  return this != internal_default_instance() && _impl_.objectid_ != nullptr;
}
inline bool TagPlacementData::has_objectid() const {
  return _internal_has_objectid();
}
inline void TagPlacementData::clear_objectid() {
  if (GetArenaForAllocation() == nullptr && _impl_.objectid_ != nullptr) {
    delete _impl_.objectid_;
  }
  _impl_.objectid_ = nullptr;
}
inline const ::JournalData::ObjectId& TagPlacementData::_internal_objectid() const {
  const ::JournalData::ObjectId* p = _impl_.objectid_;
  return p != nullptr ? *p : reinterpret_cast<const ::JournalData::ObjectId&>(
      ::JournalData::_ObjectId_default_instance_);
}
inline const ::JournalData::ObjectId& TagPlacementData::objectid() const {
  // @@protoc_insertion_point(field_get:JournalData.TagPlacementData.objectId)
  return _internal_objectid();
}
inline void TagPlacementData::unsafe_arena_set_allocated_objectid(
    ::JournalData::ObjectId* objectid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectid_);
  }
  _impl_.objectid_ = objectid;
  if (objectid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.TagPlacementData.objectId)
}
inline ::JournalData::ObjectId* TagPlacementData::release_objectid() {
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JournalData::ObjectId* TagPlacementData::unsafe_arena_release_objectid() {
  // @@protoc_insertion_point(field_release:JournalData.TagPlacementData.objectId)
  
  ::JournalData::ObjectId* temp = _impl_.objectid_;
  _impl_.objectid_ = nullptr;
  return temp;
}
inline ::JournalData::ObjectId* TagPlacementData::_internal_mutable_objectid() {
  
  if (_impl_.objectid_ == nullptr) {
    auto* p = CreateMaybeMessage<::JournalData::ObjectId>(GetArenaForAllocation());
    _impl_.objectid_ = p;
  }
  return _impl_.objectid_;
}
inline ::JournalData::ObjectId* TagPlacementData::mutable_objectid() {
  ::JournalData::ObjectId* _msg = _internal_mutable_objectid();
  // @@protoc_insertion_point(field_mutable:JournalData.TagPlacementData.objectId)
  return _msg;
}
inline void TagPlacementData::set_allocated_objectid(::JournalData::ObjectId* objectid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.objectid_;
  }
  if (objectid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(objectid);
    if (message_arena != submessage_arena) {
      objectid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectid_ = objectid;
  // @@protoc_insertion_point(field_set_allocated:JournalData.TagPlacementData.objectId)
}

// .Common.Float3 anchorPos = 2;
inline bool TagPlacementData::_internal_has_anchorpos() const {
  return this != internal_default_instance() && _impl_.anchorpos_ != nullptr;
}
inline bool TagPlacementData::has_anchorpos() const {
  return _internal_has_anchorpos();
}
inline const ::Common::Float3& TagPlacementData::_internal_anchorpos() const {
  const ::Common::Float3* p = _impl_.anchorpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TagPlacementData::anchorpos() const {
  // @@protoc_insertion_point(field_get:JournalData.TagPlacementData.anchorPos)
  return _internal_anchorpos();
}
inline void TagPlacementData::unsafe_arena_set_allocated_anchorpos(
    ::Common::Float3* anchorpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.anchorpos_);
  }
  _impl_.anchorpos_ = anchorpos;
  if (anchorpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.TagPlacementData.anchorPos)
}
inline ::Common::Float3* TagPlacementData::release_anchorpos() {
  
  ::Common::Float3* temp = _impl_.anchorpos_;
  _impl_.anchorpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TagPlacementData::unsafe_arena_release_anchorpos() {
  // @@protoc_insertion_point(field_release:JournalData.TagPlacementData.anchorPos)
  
  ::Common::Float3* temp = _impl_.anchorpos_;
  _impl_.anchorpos_ = nullptr;
  return temp;
}
inline ::Common::Float3* TagPlacementData::_internal_mutable_anchorpos() {
  
  if (_impl_.anchorpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.anchorpos_ = p;
  }
  return _impl_.anchorpos_;
}
inline ::Common::Float3* TagPlacementData::mutable_anchorpos() {
  ::Common::Float3* _msg = _internal_mutable_anchorpos();
  // @@protoc_insertion_point(field_mutable:JournalData.TagPlacementData.anchorPos)
  return _msg;
}
inline void TagPlacementData::set_allocated_anchorpos(::Common::Float3* anchorpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.anchorpos_);
  }
  if (anchorpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(anchorpos));
    if (message_arena != submessage_arena) {
      anchorpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anchorpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.anchorpos_ = anchorpos;
  // @@protoc_insertion_point(field_set_allocated:JournalData.TagPlacementData.anchorPos)
}

// .Common.Float3 tagOffset = 3;
inline bool TagPlacementData::_internal_has_tagoffset() const {
  return this != internal_default_instance() && _impl_.tagoffset_ != nullptr;
}
inline bool TagPlacementData::has_tagoffset() const {
  return _internal_has_tagoffset();
}
inline const ::Common::Float3& TagPlacementData::_internal_tagoffset() const {
  const ::Common::Float3* p = _impl_.tagoffset_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TagPlacementData::tagoffset() const {
  // @@protoc_insertion_point(field_get:JournalData.TagPlacementData.tagOffset)
  return _internal_tagoffset();
}
inline void TagPlacementData::unsafe_arena_set_allocated_tagoffset(
    ::Common::Float3* tagoffset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tagoffset_);
  }
  _impl_.tagoffset_ = tagoffset;
  if (tagoffset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.TagPlacementData.tagOffset)
}
inline ::Common::Float3* TagPlacementData::release_tagoffset() {
  
  ::Common::Float3* temp = _impl_.tagoffset_;
  _impl_.tagoffset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TagPlacementData::unsafe_arena_release_tagoffset() {
  // @@protoc_insertion_point(field_release:JournalData.TagPlacementData.tagOffset)
  
  ::Common::Float3* temp = _impl_.tagoffset_;
  _impl_.tagoffset_ = nullptr;
  return temp;
}
inline ::Common::Float3* TagPlacementData::_internal_mutable_tagoffset() {
  
  if (_impl_.tagoffset_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.tagoffset_ = p;
  }
  return _impl_.tagoffset_;
}
inline ::Common::Float3* TagPlacementData::mutable_tagoffset() {
  ::Common::Float3* _msg = _internal_mutable_tagoffset();
  // @@protoc_insertion_point(field_mutable:JournalData.TagPlacementData.tagOffset)
  return _msg;
}
inline void TagPlacementData::set_allocated_tagoffset(::Common::Float3* tagoffset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tagoffset_);
  }
  if (tagoffset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tagoffset));
    if (message_arena != submessage_arena) {
      tagoffset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tagoffset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tagoffset_ = tagoffset;
  // @@protoc_insertion_point(field_set_allocated:JournalData.TagPlacementData.tagOffset)
}

// float height = 4;
inline void TagPlacementData::clear_height() {
  _impl_.height_ = 0;
}
inline float TagPlacementData::_internal_height() const {
  return _impl_.height_;
}
inline float TagPlacementData::height() const {
  // @@protoc_insertion_point(field_get:JournalData.TagPlacementData.height)
  return _internal_height();
}
inline void TagPlacementData::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void TagPlacementData::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:JournalData.TagPlacementData.height)
}

// -------------------------------------------------------------------

// ObjectPlacementData

// .Common.Float3 position = 1;
inline bool ObjectPlacementData::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool ObjectPlacementData::has_position() const {
  return _internal_has_position();
}
inline const ::Common::Float3& ObjectPlacementData::_internal_position() const {
  const ::Common::Float3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& ObjectPlacementData::position() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectPlacementData.position)
  return _internal_position();
}
inline void ObjectPlacementData::unsafe_arena_set_allocated_position(
    ::Common::Float3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectPlacementData.position)
}
inline ::Common::Float3* ObjectPlacementData::release_position() {
  
  ::Common::Float3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectPlacementData.position)
  
  ::Common::Float3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::Common::Float3* ObjectPlacementData::mutable_position() {
  ::Common::Float3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectPlacementData.position)
  return _msg;
}
inline void ObjectPlacementData::set_allocated_position(::Common::Float3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectPlacementData.position)
}

// .Common.Float3 rotation = 2;
inline bool ObjectPlacementData::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool ObjectPlacementData::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::Common::Float3& ObjectPlacementData::_internal_rotation() const {
  const ::Common::Float3* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& ObjectPlacementData::rotation() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectPlacementData.rotation)
  return _internal_rotation();
}
inline void ObjectPlacementData::unsafe_arena_set_allocated_rotation(
    ::Common::Float3* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectPlacementData.rotation)
}
inline ::Common::Float3* ObjectPlacementData::release_rotation() {
  
  ::Common::Float3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectPlacementData.rotation)
  
  ::Common::Float3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::Common::Float3* ObjectPlacementData::mutable_rotation() {
  ::Common::Float3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectPlacementData.rotation)
  return _msg;
}
inline void ObjectPlacementData::set_allocated_rotation(::Common::Float3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectPlacementData.rotation)
}

// .Common.Float3 scale = 3;
inline bool ObjectPlacementData::_internal_has_scale() const {
  return this != internal_default_instance() && _impl_.scale_ != nullptr;
}
inline bool ObjectPlacementData::has_scale() const {
  return _internal_has_scale();
}
inline const ::Common::Float3& ObjectPlacementData::_internal_scale() const {
  const ::Common::Float3* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& ObjectPlacementData::scale() const {
  // @@protoc_insertion_point(field_get:JournalData.ObjectPlacementData.scale)
  return _internal_scale();
}
inline void ObjectPlacementData::unsafe_arena_set_allocated_scale(
    ::Common::Float3* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.ObjectPlacementData.scale)
}
inline ::Common::Float3* ObjectPlacementData::release_scale() {
  
  ::Common::Float3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:JournalData.ObjectPlacementData.scale)
  
  ::Common::Float3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::Common::Float3* ObjectPlacementData::_internal_mutable_scale() {
  
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::Common::Float3* ObjectPlacementData::mutable_scale() {
  ::Common::Float3* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:JournalData.ObjectPlacementData.scale)
  return _msg;
}
inline void ObjectPlacementData::set_allocated_scale(::Common::Float3* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale));
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:JournalData.ObjectPlacementData.scale)
}

// -------------------------------------------------------------------

// PartHighlightData

// .Common.Color4 primaryColor = 3;
inline bool PartHighlightData::_internal_has_primarycolor() const {
  return this != internal_default_instance() && _impl_.primarycolor_ != nullptr;
}
inline bool PartHighlightData::has_primarycolor() const {
  return _internal_has_primarycolor();
}
inline const ::Common::Color4& PartHighlightData::_internal_primarycolor() const {
  const ::Common::Color4* p = _impl_.primarycolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& PartHighlightData::primarycolor() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.primaryColor)
  return _internal_primarycolor();
}
inline void PartHighlightData::unsafe_arena_set_allocated_primarycolor(
    ::Common::Color4* primarycolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.primarycolor_);
  }
  _impl_.primarycolor_ = primarycolor;
  if (primarycolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.PartHighlightData.primaryColor)
}
inline ::Common::Color4* PartHighlightData::release_primarycolor() {
  
  ::Common::Color4* temp = _impl_.primarycolor_;
  _impl_.primarycolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* PartHighlightData::unsafe_arena_release_primarycolor() {
  // @@protoc_insertion_point(field_release:JournalData.PartHighlightData.primaryColor)
  
  ::Common::Color4* temp = _impl_.primarycolor_;
  _impl_.primarycolor_ = nullptr;
  return temp;
}
inline ::Common::Color4* PartHighlightData::_internal_mutable_primarycolor() {
  
  if (_impl_.primarycolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.primarycolor_ = p;
  }
  return _impl_.primarycolor_;
}
inline ::Common::Color4* PartHighlightData::mutable_primarycolor() {
  ::Common::Color4* _msg = _internal_mutable_primarycolor();
  // @@protoc_insertion_point(field_mutable:JournalData.PartHighlightData.primaryColor)
  return _msg;
}
inline void PartHighlightData::set_allocated_primarycolor(::Common::Color4* primarycolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.primarycolor_);
  }
  if (primarycolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primarycolor));
    if (message_arena != submessage_arena) {
      primarycolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primarycolor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.primarycolor_ = primarycolor;
  // @@protoc_insertion_point(field_set_allocated:JournalData.PartHighlightData.primaryColor)
}

// .Common.Color4 secondaryColor = 4;
inline bool PartHighlightData::_internal_has_secondarycolor() const {
  return this != internal_default_instance() && _impl_.secondarycolor_ != nullptr;
}
inline bool PartHighlightData::has_secondarycolor() const {
  return _internal_has_secondarycolor();
}
inline const ::Common::Color4& PartHighlightData::_internal_secondarycolor() const {
  const ::Common::Color4* p = _impl_.secondarycolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Color4&>(
      ::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& PartHighlightData::secondarycolor() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.secondaryColor)
  return _internal_secondarycolor();
}
inline void PartHighlightData::unsafe_arena_set_allocated_secondarycolor(
    ::Common::Color4* secondarycolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.secondarycolor_);
  }
  _impl_.secondarycolor_ = secondarycolor;
  if (secondarycolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.PartHighlightData.secondaryColor)
}
inline ::Common::Color4* PartHighlightData::release_secondarycolor() {
  
  ::Common::Color4* temp = _impl_.secondarycolor_;
  _impl_.secondarycolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Color4* PartHighlightData::unsafe_arena_release_secondarycolor() {
  // @@protoc_insertion_point(field_release:JournalData.PartHighlightData.secondaryColor)
  
  ::Common::Color4* temp = _impl_.secondarycolor_;
  _impl_.secondarycolor_ = nullptr;
  return temp;
}
inline ::Common::Color4* PartHighlightData::_internal_mutable_secondarycolor() {
  
  if (_impl_.secondarycolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Color4>(GetArenaForAllocation());
    _impl_.secondarycolor_ = p;
  }
  return _impl_.secondarycolor_;
}
inline ::Common::Color4* PartHighlightData::mutable_secondarycolor() {
  ::Common::Color4* _msg = _internal_mutable_secondarycolor();
  // @@protoc_insertion_point(field_mutable:JournalData.PartHighlightData.secondaryColor)
  return _msg;
}
inline void PartHighlightData::set_allocated_secondarycolor(::Common::Color4* secondarycolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.secondarycolor_);
  }
  if (secondarycolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(secondarycolor));
    if (message_arena != submessage_arena) {
      secondarycolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, secondarycolor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.secondarycolor_ = secondarycolor;
  // @@protoc_insertion_point(field_set_allocated:JournalData.PartHighlightData.secondaryColor)
}

// float spread = 5;
inline void PartHighlightData::clear_spread() {
  _impl_.spread_ = 0;
}
inline float PartHighlightData::_internal_spread() const {
  return _impl_.spread_;
}
inline float PartHighlightData::spread() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.spread)
  return _internal_spread();
}
inline void PartHighlightData::_internal_set_spread(float value) {
  
  _impl_.spread_ = value;
}
inline void PartHighlightData::set_spread(float value) {
  _internal_set_spread(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.spread)
}

// float speed = 6;
inline void PartHighlightData::clear_speed() {
  _impl_.speed_ = 0;
}
inline float PartHighlightData::_internal_speed() const {
  return _impl_.speed_;
}
inline float PartHighlightData::speed() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.speed)
  return _internal_speed();
}
inline void PartHighlightData::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void PartHighlightData::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.speed)
}

// float coverage = 7;
inline void PartHighlightData::clear_coverage() {
  _impl_.coverage_ = 0;
}
inline float PartHighlightData::_internal_coverage() const {
  return _impl_.coverage_;
}
inline float PartHighlightData::coverage() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.coverage)
  return _internal_coverage();
}
inline void PartHighlightData::_internal_set_coverage(float value) {
  
  _impl_.coverage_ = value;
}
inline void PartHighlightData::set_coverage(float value) {
  _internal_set_coverage(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.coverage)
}

// float edging = 8;
inline void PartHighlightData::clear_edging() {
  _impl_.edging_ = 0;
}
inline float PartHighlightData::_internal_edging() const {
  return _impl_.edging_;
}
inline float PartHighlightData::edging() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.edging)
  return _internal_edging();
}
inline void PartHighlightData::_internal_set_edging(float value) {
  
  _impl_.edging_ = value;
}
inline void PartHighlightData::set_edging(float value) {
  _internal_set_edging(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.edging)
}

// float riseTime = 9;
inline void PartHighlightData::clear_risetime() {
  _impl_.risetime_ = 0;
}
inline float PartHighlightData::_internal_risetime() const {
  return _impl_.risetime_;
}
inline float PartHighlightData::risetime() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.riseTime)
  return _internal_risetime();
}
inline void PartHighlightData::_internal_set_risetime(float value) {
  
  _impl_.risetime_ = value;
}
inline void PartHighlightData::set_risetime(float value) {
  _internal_set_risetime(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.riseTime)
}

// float holdTime = 10;
inline void PartHighlightData::clear_holdtime() {
  _impl_.holdtime_ = 0;
}
inline float PartHighlightData::_internal_holdtime() const {
  return _impl_.holdtime_;
}
inline float PartHighlightData::holdtime() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.holdTime)
  return _internal_holdtime();
}
inline void PartHighlightData::_internal_set_holdtime(float value) {
  
  _impl_.holdtime_ = value;
}
inline void PartHighlightData::set_holdtime(float value) {
  _internal_set_holdtime(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.holdTime)
}

// float fallTime = 11;
inline void PartHighlightData::clear_falltime() {
  _impl_.falltime_ = 0;
}
inline float PartHighlightData::_internal_falltime() const {
  return _impl_.falltime_;
}
inline float PartHighlightData::falltime() const {
  // @@protoc_insertion_point(field_get:JournalData.PartHighlightData.fallTime)
  return _internal_falltime();
}
inline void PartHighlightData::_internal_set_falltime(float value) {
  
  _impl_.falltime_ = value;
}
inline void PartHighlightData::set_falltime(float value) {
  _internal_set_falltime(value);
  // @@protoc_insertion_point(field_set:JournalData.PartHighlightData.fallTime)
}

// -------------------------------------------------------------------

// LightingEnvironmentContentType

// string contentId = 1;
inline bool LightingEnvironmentContentType::_internal_has_contentid() const {
  return Im_case() == kContentId;
}
inline bool LightingEnvironmentContentType::has_contentid() const {
  return _internal_has_contentid();
}
inline void LightingEnvironmentContentType::set_has_contentid() {
  _impl_._oneof_case_[0] = kContentId;
}
inline void LightingEnvironmentContentType::clear_contentid() {
  if (_internal_has_contentid()) {
    _impl_.Im_.contentid_.Destroy();
    clear_has_Im();
  }
}
inline const std::string& LightingEnvironmentContentType::contentid() const {
  // @@protoc_insertion_point(field_get:JournalData.LightingEnvironmentContentType.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline void LightingEnvironmentContentType::set_contentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  _impl_.Im_.contentid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JournalData.LightingEnvironmentContentType.contentId)
}
inline std::string* LightingEnvironmentContentType::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:JournalData.LightingEnvironmentContentType.contentId)
  return _s;
}
inline const std::string& LightingEnvironmentContentType::_internal_contentid() const {
  if (_internal_has_contentid()) {
    return _impl_.Im_.contentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LightingEnvironmentContentType::_internal_set_contentid(const std::string& value) {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  _impl_.Im_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* LightingEnvironmentContentType::_internal_mutable_contentid() {
  if (!_internal_has_contentid()) {
    clear_Im();
    set_has_contentid();
    _impl_.Im_.contentid_.InitDefault();
  }
  return _impl_.Im_.contentid_.Mutable(      GetArenaForAllocation());
}
inline std::string* LightingEnvironmentContentType::release_contentid() {
  // @@protoc_insertion_point(field_release:JournalData.LightingEnvironmentContentType.contentId)
  if (_internal_has_contentid()) {
    clear_has_Im();
    return _impl_.Im_.contentid_.Release();
  } else {
    return nullptr;
  }
}
inline void LightingEnvironmentContentType::set_allocated_contentid(std::string* contentid) {
  if (has_Im()) {
    clear_Im();
  }
  if (contentid != nullptr) {
    set_has_contentid();
    _impl_.Im_.contentid_.InitAllocated(contentid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:JournalData.LightingEnvironmentContentType.contentId)
}

// .JournalData.Progress imageProgress = 2;
inline bool LightingEnvironmentContentType::_internal_has_imageprogress() const {
  return Im_case() == kImageProgress;
}
inline bool LightingEnvironmentContentType::has_imageprogress() const {
  return _internal_has_imageprogress();
}
inline void LightingEnvironmentContentType::set_has_imageprogress() {
  _impl_._oneof_case_[0] = kImageProgress;
}
inline void LightingEnvironmentContentType::clear_imageprogress() {
  if (_internal_has_imageprogress()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Im_.imageprogress_;
    }
    clear_has_Im();
  }
}
inline ::JournalData::Progress* LightingEnvironmentContentType::release_imageprogress() {
  // @@protoc_insertion_point(field_release:JournalData.LightingEnvironmentContentType.imageProgress)
  if (_internal_has_imageprogress()) {
    clear_has_Im();
    ::JournalData::Progress* temp = _impl_.Im_.imageprogress_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Im_.imageprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JournalData::Progress& LightingEnvironmentContentType::_internal_imageprogress() const {
  return _internal_has_imageprogress()
      ? *_impl_.Im_.imageprogress_
      : reinterpret_cast< ::JournalData::Progress&>(::JournalData::_Progress_default_instance_);
}
inline const ::JournalData::Progress& LightingEnvironmentContentType::imageprogress() const {
  // @@protoc_insertion_point(field_get:JournalData.LightingEnvironmentContentType.imageProgress)
  return _internal_imageprogress();
}
inline ::JournalData::Progress* LightingEnvironmentContentType::unsafe_arena_release_imageprogress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:JournalData.LightingEnvironmentContentType.imageProgress)
  if (_internal_has_imageprogress()) {
    clear_has_Im();
    ::JournalData::Progress* temp = _impl_.Im_.imageprogress_;
    _impl_.Im_.imageprogress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LightingEnvironmentContentType::unsafe_arena_set_allocated_imageprogress(::JournalData::Progress* imageprogress) {
  clear_Im();
  if (imageprogress) {
    set_has_imageprogress();
    _impl_.Im_.imageprogress_ = imageprogress;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JournalData.LightingEnvironmentContentType.imageProgress)
}
inline ::JournalData::Progress* LightingEnvironmentContentType::_internal_mutable_imageprogress() {
  if (!_internal_has_imageprogress()) {
    clear_Im();
    set_has_imageprogress();
    _impl_.Im_.imageprogress_ = CreateMaybeMessage< ::JournalData::Progress >(GetArenaForAllocation());
  }
  return _impl_.Im_.imageprogress_;
}
inline ::JournalData::Progress* LightingEnvironmentContentType::mutable_imageprogress() {
  ::JournalData::Progress* _msg = _internal_mutable_imageprogress();
  // @@protoc_insertion_point(field_mutable:JournalData.LightingEnvironmentContentType.imageProgress)
  return _msg;
}

inline bool LightingEnvironmentContentType::has_Im() const {
  return Im_case() != IM_NOT_SET;
}
inline void LightingEnvironmentContentType::clear_has_Im() {
  _impl_._oneof_case_[0] = IM_NOT_SET;
}
inline LightingEnvironmentContentType::ImCase LightingEnvironmentContentType::Im_case() const {
  return LightingEnvironmentContentType::ImCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace JournalData

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::JournalData::Progress_V1_ProgressMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JournalData::Progress_V1_ProgressMode>() {
  return ::JournalData::Progress_V1_ProgressMode_descriptor();
}
template <> struct is_proto_enum< ::JournalData::ChatMessageSourceTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JournalData::ChatMessageSourceTypeEnum>() {
  return ::JournalData::ChatMessageSourceTypeEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_journaldata_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transient_events_client.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transient_5fevents_5fclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transient_5fevents_5fclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "journal_operations_client.pb.h"
#include "journal_operations_common.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transient_5fevents_5fclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transient_5fevents_5fclient_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transient_5fevents_5fclient_2eproto;
namespace Transient {
class AvatarControllerV3;
struct AvatarControllerV3DefaultTypeInternal;
extern AvatarControllerV3DefaultTypeInternal _AvatarControllerV3_default_instance_;
class AvatarPositionV3;
struct AvatarPositionV3DefaultTypeInternal;
extern AvatarPositionV3DefaultTypeInternal _AvatarPositionV3_default_instance_;
class AvatarRootV3;
struct AvatarRootV3DefaultTypeInternal;
extern AvatarRootV3DefaultTypeInternal _AvatarRootV3_default_instance_;
class EvCopresence;
struct EvCopresenceDefaultTypeInternal;
extern EvCopresenceDefaultTypeInternal _EvCopresence_default_instance_;
class EvCopresence_V3;
struct EvCopresence_V3DefaultTypeInternal;
extern EvCopresence_V3DefaultTypeInternal _EvCopresence_V3_default_instance_;
class EvTransientJournalUpdate;
struct EvTransientJournalUpdateDefaultTypeInternal;
extern EvTransientJournalUpdateDefaultTypeInternal _EvTransientJournalUpdate_default_instance_;
class EvTransientJournalUpdate_V1;
struct EvTransientJournalUpdate_V1DefaultTypeInternal;
extern EvTransientJournalUpdate_V1DefaultTypeInternal _EvTransientJournalUpdate_V1_default_instance_;
}  // namespace Transient
PROTOBUF_NAMESPACE_OPEN
template<> ::Transient::AvatarControllerV3* Arena::CreateMaybeMessage<::Transient::AvatarControllerV3>(Arena*);
template<> ::Transient::AvatarPositionV3* Arena::CreateMaybeMessage<::Transient::AvatarPositionV3>(Arena*);
template<> ::Transient::AvatarRootV3* Arena::CreateMaybeMessage<::Transient::AvatarRootV3>(Arena*);
template<> ::Transient::EvCopresence* Arena::CreateMaybeMessage<::Transient::EvCopresence>(Arena*);
template<> ::Transient::EvCopresence_V3* Arena::CreateMaybeMessage<::Transient::EvCopresence_V3>(Arena*);
template<> ::Transient::EvTransientJournalUpdate* Arena::CreateMaybeMessage<::Transient::EvTransientJournalUpdate>(Arena*);
template<> ::Transient::EvTransientJournalUpdate_V1* Arena::CreateMaybeMessage<::Transient::EvTransientJournalUpdate_V1>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Transient {

enum AvatarRootV3_AvatarMovementStateEnum : int {
  AvatarRootV3_AvatarMovementStateEnum_None = 0,
  AvatarRootV3_AvatarMovementStateEnum_Jump = 1,
  AvatarRootV3_AvatarMovementStateEnum_Crouch = 2,
  AvatarRootV3_AvatarMovementStateEnum_Fly = 3,
  AvatarRootV3_AvatarMovementStateEnum_Custom = 4,
  AvatarRootV3_AvatarMovementStateEnum_AvatarRootV3_AvatarMovementStateEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AvatarRootV3_AvatarMovementStateEnum_AvatarRootV3_AvatarMovementStateEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AvatarRootV3_AvatarMovementStateEnum_IsValid(int value);
constexpr AvatarRootV3_AvatarMovementStateEnum AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_MIN = AvatarRootV3_AvatarMovementStateEnum_None;
constexpr AvatarRootV3_AvatarMovementStateEnum AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_MAX = AvatarRootV3_AvatarMovementStateEnum_Custom;
constexpr int AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_ARRAYSIZE = AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AvatarRootV3_AvatarMovementStateEnum_descriptor();
template<typename T>
inline const std::string& AvatarRootV3_AvatarMovementStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AvatarRootV3_AvatarMovementStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AvatarRootV3_AvatarMovementStateEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AvatarRootV3_AvatarMovementStateEnum_descriptor(), enum_t_value);
}
inline bool AvatarRootV3_AvatarMovementStateEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AvatarRootV3_AvatarMovementStateEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AvatarRootV3_AvatarMovementStateEnum>(
    AvatarRootV3_AvatarMovementStateEnum_descriptor(), name, value);
}
// ===================================================================

class EvTransientJournalUpdate_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.EvTransientJournalUpdate.V1) */ {
 public:
  inline EvTransientJournalUpdate_V1() : EvTransientJournalUpdate_V1(nullptr) {}
  ~EvTransientJournalUpdate_V1() override;
  explicit PROTOBUF_CONSTEXPR EvTransientJournalUpdate_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvTransientJournalUpdate_V1(const EvTransientJournalUpdate_V1& from);
  EvTransientJournalUpdate_V1(EvTransientJournalUpdate_V1&& from) noexcept
    : EvTransientJournalUpdate_V1() {
    *this = ::std::move(from);
  }

  inline EvTransientJournalUpdate_V1& operator=(const EvTransientJournalUpdate_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvTransientJournalUpdate_V1& operator=(EvTransientJournalUpdate_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvTransientJournalUpdate_V1& default_instance() {
    return *internal_default_instance();
  }
  enum OpCase {
    kLine2D = 10,
    kText2D = 11,
    kImage2D = 12,
    kLine3D = 20,
    kText3D = 21,
    kImage3D = 22,
    kCreateObject = 32,
    kSetPartHighlight = 61,
    kUpdatePropertyValue = 13,
    kDeclareProperty = 14,
    kUserAuthorityData = 16,
    OP_NOT_SET = 0,
  };

  static inline const EvTransientJournalUpdate_V1* internal_default_instance() {
    return reinterpret_cast<const EvTransientJournalUpdate_V1*>(
               &_EvTransientJournalUpdate_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EvTransientJournalUpdate_V1& a, EvTransientJournalUpdate_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(EvTransientJournalUpdate_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvTransientJournalUpdate_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvTransientJournalUpdate_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvTransientJournalUpdate_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvTransientJournalUpdate_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvTransientJournalUpdate_V1& from) {
    EvTransientJournalUpdate_V1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvTransientJournalUpdate_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.EvTransientJournalUpdate.V1";
  }
  protected:
  explicit EvTransientJournalUpdate_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 3,
    kLine2DFieldNumber = 10,
    kText2DFieldNumber = 11,
    kImage2DFieldNumber = 12,
    kLine3DFieldNumber = 20,
    kText3DFieldNumber = 21,
    kImage3DFieldNumber = 22,
    kCreateObjectFieldNumber = 32,
    kSetPartHighlightFieldNumber = 61,
    kUpdatePropertyValueFieldNumber = 13,
    kDeclarePropertyFieldNumber = 14,
    kUserAuthorityDataFieldNumber = 16,
  };
  // string uniqueId = 3;
  void clear_uniqueid();
  const std::string& uniqueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueid();
  PROTOBUF_NODISCARD std::string* release_uniqueid();
  void set_allocated_uniqueid(std::string* uniqueid);
  private:
  const std::string& _internal_uniqueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueid(const std::string& value);
  std::string* _internal_mutable_uniqueid();
  public:

  // .Journal.OpLine2d line2d = 10;
  bool has_line2d() const;
  private:
  bool _internal_has_line2d() const;
  public:
  void clear_line2d();
  const ::Journal::OpLine2d& line2d() const;
  PROTOBUF_NODISCARD ::Journal::OpLine2d* release_line2d();
  ::Journal::OpLine2d* mutable_line2d();
  void set_allocated_line2d(::Journal::OpLine2d* line2d);
  private:
  const ::Journal::OpLine2d& _internal_line2d() const;
  ::Journal::OpLine2d* _internal_mutable_line2d();
  public:
  void unsafe_arena_set_allocated_line2d(
      ::Journal::OpLine2d* line2d);
  ::Journal::OpLine2d* unsafe_arena_release_line2d();

  // .Journal.OpText2d text2d = 11;
  bool has_text2d() const;
  private:
  bool _internal_has_text2d() const;
  public:
  void clear_text2d();
  const ::Journal::OpText2d& text2d() const;
  PROTOBUF_NODISCARD ::Journal::OpText2d* release_text2d();
  ::Journal::OpText2d* mutable_text2d();
  void set_allocated_text2d(::Journal::OpText2d* text2d);
  private:
  const ::Journal::OpText2d& _internal_text2d() const;
  ::Journal::OpText2d* _internal_mutable_text2d();
  public:
  void unsafe_arena_set_allocated_text2d(
      ::Journal::OpText2d* text2d);
  ::Journal::OpText2d* unsafe_arena_release_text2d();

  // .Journal.OpImage2d image2d = 12;
  bool has_image2d() const;
  private:
  bool _internal_has_image2d() const;
  public:
  void clear_image2d();
  const ::Journal::OpImage2d& image2d() const;
  PROTOBUF_NODISCARD ::Journal::OpImage2d* release_image2d();
  ::Journal::OpImage2d* mutable_image2d();
  void set_allocated_image2d(::Journal::OpImage2d* image2d);
  private:
  const ::Journal::OpImage2d& _internal_image2d() const;
  ::Journal::OpImage2d* _internal_mutable_image2d();
  public:
  void unsafe_arena_set_allocated_image2d(
      ::Journal::OpImage2d* image2d);
  ::Journal::OpImage2d* unsafe_arena_release_image2d();

  // .Journal.OpLine3d line3d = 20;
  bool has_line3d() const;
  private:
  bool _internal_has_line3d() const;
  public:
  void clear_line3d();
  const ::Journal::OpLine3d& line3d() const;
  PROTOBUF_NODISCARD ::Journal::OpLine3d* release_line3d();
  ::Journal::OpLine3d* mutable_line3d();
  void set_allocated_line3d(::Journal::OpLine3d* line3d);
  private:
  const ::Journal::OpLine3d& _internal_line3d() const;
  ::Journal::OpLine3d* _internal_mutable_line3d();
  public:
  void unsafe_arena_set_allocated_line3d(
      ::Journal::OpLine3d* line3d);
  ::Journal::OpLine3d* unsafe_arena_release_line3d();

  // .Journal.OpText3d text3d = 21;
  bool has_text3d() const;
  private:
  bool _internal_has_text3d() const;
  public:
  void clear_text3d();
  const ::Journal::OpText3d& text3d() const;
  PROTOBUF_NODISCARD ::Journal::OpText3d* release_text3d();
  ::Journal::OpText3d* mutable_text3d();
  void set_allocated_text3d(::Journal::OpText3d* text3d);
  private:
  const ::Journal::OpText3d& _internal_text3d() const;
  ::Journal::OpText3d* _internal_mutable_text3d();
  public:
  void unsafe_arena_set_allocated_text3d(
      ::Journal::OpText3d* text3d);
  ::Journal::OpText3d* unsafe_arena_release_text3d();

  // .Journal.OpImage3d image3d = 22;
  bool has_image3d() const;
  private:
  bool _internal_has_image3d() const;
  public:
  void clear_image3d();
  const ::Journal::OpImage3d& image3d() const;
  PROTOBUF_NODISCARD ::Journal::OpImage3d* release_image3d();
  ::Journal::OpImage3d* mutable_image3d();
  void set_allocated_image3d(::Journal::OpImage3d* image3d);
  private:
  const ::Journal::OpImage3d& _internal_image3d() const;
  ::Journal::OpImage3d* _internal_mutable_image3d();
  public:
  void unsafe_arena_set_allocated_image3d(
      ::Journal::OpImage3d* image3d);
  ::Journal::OpImage3d* unsafe_arena_release_image3d();

  // .Journal.OpCreateObject createObject = 32;
  bool has_createobject() const;
  private:
  bool _internal_has_createobject() const;
  public:
  void clear_createobject();
  const ::Journal::OpCreateObject& createobject() const;
  PROTOBUF_NODISCARD ::Journal::OpCreateObject* release_createobject();
  ::Journal::OpCreateObject* mutable_createobject();
  void set_allocated_createobject(::Journal::OpCreateObject* createobject);
  private:
  const ::Journal::OpCreateObject& _internal_createobject() const;
  ::Journal::OpCreateObject* _internal_mutable_createobject();
  public:
  void unsafe_arena_set_allocated_createobject(
      ::Journal::OpCreateObject* createobject);
  ::Journal::OpCreateObject* unsafe_arena_release_createobject();

  // .Journal.OpSetPartHighlight setPartHighlight = 61;
  bool has_setparthighlight() const;
  private:
  bool _internal_has_setparthighlight() const;
  public:
  void clear_setparthighlight();
  const ::Journal::OpSetPartHighlight& setparthighlight() const;
  PROTOBUF_NODISCARD ::Journal::OpSetPartHighlight* release_setparthighlight();
  ::Journal::OpSetPartHighlight* mutable_setparthighlight();
  void set_allocated_setparthighlight(::Journal::OpSetPartHighlight* setparthighlight);
  private:
  const ::Journal::OpSetPartHighlight& _internal_setparthighlight() const;
  ::Journal::OpSetPartHighlight* _internal_mutable_setparthighlight();
  public:
  void unsafe_arena_set_allocated_setparthighlight(
      ::Journal::OpSetPartHighlight* setparthighlight);
  ::Journal::OpSetPartHighlight* unsafe_arena_release_setparthighlight();

  // .Journal.OpUpdatePropertyValue updatePropertyValue = 13;
  bool has_updatepropertyvalue() const;
  private:
  bool _internal_has_updatepropertyvalue() const;
  public:
  void clear_updatepropertyvalue();
  const ::Journal::OpUpdatePropertyValue& updatepropertyvalue() const;
  PROTOBUF_NODISCARD ::Journal::OpUpdatePropertyValue* release_updatepropertyvalue();
  ::Journal::OpUpdatePropertyValue* mutable_updatepropertyvalue();
  void set_allocated_updatepropertyvalue(::Journal::OpUpdatePropertyValue* updatepropertyvalue);
  private:
  const ::Journal::OpUpdatePropertyValue& _internal_updatepropertyvalue() const;
  ::Journal::OpUpdatePropertyValue* _internal_mutable_updatepropertyvalue();
  public:
  void unsafe_arena_set_allocated_updatepropertyvalue(
      ::Journal::OpUpdatePropertyValue* updatepropertyvalue);
  ::Journal::OpUpdatePropertyValue* unsafe_arena_release_updatepropertyvalue();

  // .Journal.OpDeclareProperty declareProperty = 14;
  bool has_declareproperty() const;
  private:
  bool _internal_has_declareproperty() const;
  public:
  void clear_declareproperty();
  const ::Journal::OpDeclareProperty& declareproperty() const;
  PROTOBUF_NODISCARD ::Journal::OpDeclareProperty* release_declareproperty();
  ::Journal::OpDeclareProperty* mutable_declareproperty();
  void set_allocated_declareproperty(::Journal::OpDeclareProperty* declareproperty);
  private:
  const ::Journal::OpDeclareProperty& _internal_declareproperty() const;
  ::Journal::OpDeclareProperty* _internal_mutable_declareproperty();
  public:
  void unsafe_arena_set_allocated_declareproperty(
      ::Journal::OpDeclareProperty* declareproperty);
  ::Journal::OpDeclareProperty* unsafe_arena_release_declareproperty();

  // .Journal.OpUserAuthorityData userAuthorityData = 16;
  bool has_userauthoritydata() const;
  private:
  bool _internal_has_userauthoritydata() const;
  public:
  void clear_userauthoritydata();
  const ::Journal::OpUserAuthorityData& userauthoritydata() const;
  PROTOBUF_NODISCARD ::Journal::OpUserAuthorityData* release_userauthoritydata();
  ::Journal::OpUserAuthorityData* mutable_userauthoritydata();
  void set_allocated_userauthoritydata(::Journal::OpUserAuthorityData* userauthoritydata);
  private:
  const ::Journal::OpUserAuthorityData& _internal_userauthoritydata() const;
  ::Journal::OpUserAuthorityData* _internal_mutable_userauthoritydata();
  public:
  void unsafe_arena_set_allocated_userauthoritydata(
      ::Journal::OpUserAuthorityData* userauthoritydata);
  ::Journal::OpUserAuthorityData* unsafe_arena_release_userauthoritydata();

  void clear_Op();
  OpCase Op_case() const;
  // @@protoc_insertion_point(class_scope:Transient.EvTransientJournalUpdate.V1)
 private:
  class _Internal;
  void set_has_line2d();
  void set_has_text2d();
  void set_has_image2d();
  void set_has_line3d();
  void set_has_text3d();
  void set_has_image3d();
  void set_has_createobject();
  void set_has_setparthighlight();
  void set_has_updatepropertyvalue();
  void set_has_declareproperty();
  void set_has_userauthoritydata();

  inline bool has_Op() const;
  inline void clear_has_Op();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueid_;
    union OpUnion {
      constexpr OpUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Journal::OpLine2d* line2d_;
      ::Journal::OpText2d* text2d_;
      ::Journal::OpImage2d* image2d_;
      ::Journal::OpLine3d* line3d_;
      ::Journal::OpText3d* text3d_;
      ::Journal::OpImage3d* image3d_;
      ::Journal::OpCreateObject* createobject_;
      ::Journal::OpSetPartHighlight* setparthighlight_;
      ::Journal::OpUpdatePropertyValue* updatepropertyvalue_;
      ::Journal::OpDeclareProperty* declareproperty_;
      ::Journal::OpUserAuthorityData* userauthoritydata_;
    } Op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class EvTransientJournalUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.EvTransientJournalUpdate) */ {
 public:
  inline EvTransientJournalUpdate() : EvTransientJournalUpdate(nullptr) {}
  ~EvTransientJournalUpdate() override;
  explicit PROTOBUF_CONSTEXPR EvTransientJournalUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvTransientJournalUpdate(const EvTransientJournalUpdate& from);
  EvTransientJournalUpdate(EvTransientJournalUpdate&& from) noexcept
    : EvTransientJournalUpdate() {
    *this = ::std::move(from);
  }

  inline EvTransientJournalUpdate& operator=(const EvTransientJournalUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvTransientJournalUpdate& operator=(EvTransientJournalUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvTransientJournalUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV1 = 1,
    V_NOT_SET = 0,
  };

  static inline const EvTransientJournalUpdate* internal_default_instance() {
    return reinterpret_cast<const EvTransientJournalUpdate*>(
               &_EvTransientJournalUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EvTransientJournalUpdate& a, EvTransientJournalUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EvTransientJournalUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvTransientJournalUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvTransientJournalUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvTransientJournalUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvTransientJournalUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvTransientJournalUpdate& from) {
    EvTransientJournalUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvTransientJournalUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.EvTransientJournalUpdate";
  }
  protected:
  explicit EvTransientJournalUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EvTransientJournalUpdate_V1 V1;

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
  };
  // .Transient.EvTransientJournalUpdate.V1 v1 = 1;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::Transient::EvTransientJournalUpdate_V1& v1() const;
  PROTOBUF_NODISCARD ::Transient::EvTransientJournalUpdate_V1* release_v1();
  ::Transient::EvTransientJournalUpdate_V1* mutable_v1();
  void set_allocated_v1(::Transient::EvTransientJournalUpdate_V1* v1);
  private:
  const ::Transient::EvTransientJournalUpdate_V1& _internal_v1() const;
  ::Transient::EvTransientJournalUpdate_V1* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::Transient::EvTransientJournalUpdate_V1* v1);
  ::Transient::EvTransientJournalUpdate_V1* unsafe_arena_release_v1();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Transient.EvTransientJournalUpdate)
 private:
  class _Internal;
  void set_has_v1();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Transient::EvTransientJournalUpdate_V1* v1_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class EvCopresence_V3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.EvCopresence.V3) */ {
 public:
  inline EvCopresence_V3() : EvCopresence_V3(nullptr) {}
  ~EvCopresence_V3() override;
  explicit PROTOBUF_CONSTEXPR EvCopresence_V3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvCopresence_V3(const EvCopresence_V3& from);
  EvCopresence_V3(EvCopresence_V3&& from) noexcept
    : EvCopresence_V3() {
    *this = ::std::move(from);
  }

  inline EvCopresence_V3& operator=(const EvCopresence_V3& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvCopresence_V3& operator=(EvCopresence_V3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvCopresence_V3& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvCopresence_V3* internal_default_instance() {
    return reinterpret_cast<const EvCopresence_V3*>(
               &_EvCopresence_V3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EvCopresence_V3& a, EvCopresence_V3& b) {
    a.Swap(&b);
  }
  inline void Swap(EvCopresence_V3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvCopresence_V3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvCopresence_V3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvCopresence_V3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvCopresence_V3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvCopresence_V3& from) {
    EvCopresence_V3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvCopresence_V3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.EvCopresence.V3";
  }
  protected:
  explicit EvCopresence_V3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromConnectionIdFieldNumber = 1,
    kFollowingConnectionIdFieldNumber = 2,
    kRootFieldNumber = 8,
    kLeftControllerFieldNumber = 9,
    kRightControllerFieldNumber = 10,
    kViewFieldNumber = 11,
    kHeadFieldNumber = 12,
    kScaleFieldNumber = 3,
  };
  // string fromConnectionId = 1;
  void clear_fromconnectionid();
  const std::string& fromconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromconnectionid();
  PROTOBUF_NODISCARD std::string* release_fromconnectionid();
  void set_allocated_fromconnectionid(std::string* fromconnectionid);
  private:
  const std::string& _internal_fromconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromconnectionid(const std::string& value);
  std::string* _internal_mutable_fromconnectionid();
  public:

  // optional string followingConnectionId = 2;
  bool has_followingconnectionid() const;
  private:
  bool _internal_has_followingconnectionid() const;
  public:
  void clear_followingconnectionid();
  const std::string& followingconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_followingconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_followingconnectionid();
  PROTOBUF_NODISCARD std::string* release_followingconnectionid();
  void set_allocated_followingconnectionid(std::string* followingconnectionid);
  private:
  const std::string& _internal_followingconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_followingconnectionid(const std::string& value);
  std::string* _internal_mutable_followingconnectionid();
  public:

  // optional .Transient.AvatarRootV3 root = 8;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::Transient::AvatarRootV3& root() const;
  PROTOBUF_NODISCARD ::Transient::AvatarRootV3* release_root();
  ::Transient::AvatarRootV3* mutable_root();
  void set_allocated_root(::Transient::AvatarRootV3* root);
  private:
  const ::Transient::AvatarRootV3& _internal_root() const;
  ::Transient::AvatarRootV3* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::Transient::AvatarRootV3* root);
  ::Transient::AvatarRootV3* unsafe_arena_release_root();

  // optional .Transient.AvatarControllerV3 leftController = 9;
  bool has_leftcontroller() const;
  private:
  bool _internal_has_leftcontroller() const;
  public:
  void clear_leftcontroller();
  const ::Transient::AvatarControllerV3& leftcontroller() const;
  PROTOBUF_NODISCARD ::Transient::AvatarControllerV3* release_leftcontroller();
  ::Transient::AvatarControllerV3* mutable_leftcontroller();
  void set_allocated_leftcontroller(::Transient::AvatarControllerV3* leftcontroller);
  private:
  const ::Transient::AvatarControllerV3& _internal_leftcontroller() const;
  ::Transient::AvatarControllerV3* _internal_mutable_leftcontroller();
  public:
  void unsafe_arena_set_allocated_leftcontroller(
      ::Transient::AvatarControllerV3* leftcontroller);
  ::Transient::AvatarControllerV3* unsafe_arena_release_leftcontroller();

  // optional .Transient.AvatarControllerV3 rightController = 10;
  bool has_rightcontroller() const;
  private:
  bool _internal_has_rightcontroller() const;
  public:
  void clear_rightcontroller();
  const ::Transient::AvatarControllerV3& rightcontroller() const;
  PROTOBUF_NODISCARD ::Transient::AvatarControllerV3* release_rightcontroller();
  ::Transient::AvatarControllerV3* mutable_rightcontroller();
  void set_allocated_rightcontroller(::Transient::AvatarControllerV3* rightcontroller);
  private:
  const ::Transient::AvatarControllerV3& _internal_rightcontroller() const;
  ::Transient::AvatarControllerV3* _internal_mutable_rightcontroller();
  public:
  void unsafe_arena_set_allocated_rightcontroller(
      ::Transient::AvatarControllerV3* rightcontroller);
  ::Transient::AvatarControllerV3* unsafe_arena_release_rightcontroller();

  // optional .Transient.AvatarPositionV3 view = 11;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  const ::Transient::AvatarPositionV3& view() const;
  PROTOBUF_NODISCARD ::Transient::AvatarPositionV3* release_view();
  ::Transient::AvatarPositionV3* mutable_view();
  void set_allocated_view(::Transient::AvatarPositionV3* view);
  private:
  const ::Transient::AvatarPositionV3& _internal_view() const;
  ::Transient::AvatarPositionV3* _internal_mutable_view();
  public:
  void unsafe_arena_set_allocated_view(
      ::Transient::AvatarPositionV3* view);
  ::Transient::AvatarPositionV3* unsafe_arena_release_view();

  // optional .Transient.AvatarPositionV3 head = 12;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::Transient::AvatarPositionV3& head() const;
  PROTOBUF_NODISCARD ::Transient::AvatarPositionV3* release_head();
  ::Transient::AvatarPositionV3* mutable_head();
  void set_allocated_head(::Transient::AvatarPositionV3* head);
  private:
  const ::Transient::AvatarPositionV3& _internal_head() const;
  ::Transient::AvatarPositionV3* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::Transient::AvatarPositionV3* head);
  ::Transient::AvatarPositionV3* unsafe_arena_release_head();

  // optional float scale = 3;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  float scale() const;
  void set_scale(float value);
  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);
  public:

  // @@protoc_insertion_point(class_scope:Transient.EvCopresence.V3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromconnectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr followingconnectionid_;
    ::Transient::AvatarRootV3* root_;
    ::Transient::AvatarControllerV3* leftcontroller_;
    ::Transient::AvatarControllerV3* rightcontroller_;
    ::Transient::AvatarPositionV3* view_;
    ::Transient::AvatarPositionV3* head_;
    float scale_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class EvCopresence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.EvCopresence) */ {
 public:
  inline EvCopresence() : EvCopresence(nullptr) {}
  ~EvCopresence() override;
  explicit PROTOBUF_CONSTEXPR EvCopresence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvCopresence(const EvCopresence& from);
  EvCopresence(EvCopresence&& from) noexcept
    : EvCopresence() {
    *this = ::std::move(from);
  }

  inline EvCopresence& operator=(const EvCopresence& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvCopresence& operator=(EvCopresence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvCopresence& default_instance() {
    return *internal_default_instance();
  }
  enum VCase {
    kV3 = 3,
    V_NOT_SET = 0,
  };

  static inline const EvCopresence* internal_default_instance() {
    return reinterpret_cast<const EvCopresence*>(
               &_EvCopresence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EvCopresence& a, EvCopresence& b) {
    a.Swap(&b);
  }
  inline void Swap(EvCopresence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvCopresence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvCopresence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvCopresence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvCopresence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvCopresence& from) {
    EvCopresence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvCopresence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.EvCopresence";
  }
  protected:
  explicit EvCopresence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EvCopresence_V3 V3;

  // accessors -------------------------------------------------------

  enum : int {
    kV3FieldNumber = 3,
  };
  // .Transient.EvCopresence.V3 v3 = 3;
  bool has_v3() const;
  private:
  bool _internal_has_v3() const;
  public:
  void clear_v3();
  const ::Transient::EvCopresence_V3& v3() const;
  PROTOBUF_NODISCARD ::Transient::EvCopresence_V3* release_v3();
  ::Transient::EvCopresence_V3* mutable_v3();
  void set_allocated_v3(::Transient::EvCopresence_V3* v3);
  private:
  const ::Transient::EvCopresence_V3& _internal_v3() const;
  ::Transient::EvCopresence_V3* _internal_mutable_v3();
  public:
  void unsafe_arena_set_allocated_v3(
      ::Transient::EvCopresence_V3* v3);
  ::Transient::EvCopresence_V3* unsafe_arena_release_v3();

  void clear_V();
  VCase V_case() const;
  // @@protoc_insertion_point(class_scope:Transient.EvCopresence)
 private:
  class _Internal;
  void set_has_v3();

  inline bool has_V() const;
  inline void clear_has_V();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VUnion {
      constexpr VUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Transient::EvCopresence_V3* v3_;
    } V_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class AvatarPositionV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.AvatarPositionV3) */ {
 public:
  inline AvatarPositionV3() : AvatarPositionV3(nullptr) {}
  ~AvatarPositionV3() override;
  explicit PROTOBUF_CONSTEXPR AvatarPositionV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarPositionV3(const AvatarPositionV3& from);
  AvatarPositionV3(AvatarPositionV3&& from) noexcept
    : AvatarPositionV3() {
    *this = ::std::move(from);
  }

  inline AvatarPositionV3& operator=(const AvatarPositionV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarPositionV3& operator=(AvatarPositionV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvatarPositionV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarPositionV3* internal_default_instance() {
    return reinterpret_cast<const AvatarPositionV3*>(
               &_AvatarPositionV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AvatarPositionV3& a, AvatarPositionV3& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarPositionV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarPositionV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarPositionV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarPositionV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvatarPositionV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvatarPositionV3& from) {
    AvatarPositionV3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvatarPositionV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.AvatarPositionV3";
  }
  protected:
  explicit AvatarPositionV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .Common.Float3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Common::Float3& position() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_position();
  ::Common::Float3* mutable_position();
  void set_allocated_position(::Common::Float3* position);
  private:
  const ::Common::Float3& _internal_position() const;
  ::Common::Float3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Common::Float3* position);
  ::Common::Float3* unsafe_arena_release_position();

  // .Common.Float3 rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Common::Float3& rotation() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_rotation();
  ::Common::Float3* mutable_rotation();
  void set_allocated_rotation(::Common::Float3* rotation);
  private:
  const ::Common::Float3& _internal_rotation() const;
  ::Common::Float3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Common::Float3* rotation);
  ::Common::Float3* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:Transient.AvatarPositionV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float3* position_;
    ::Common::Float3* rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class AvatarControllerV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.AvatarControllerV3) */ {
 public:
  inline AvatarControllerV3() : AvatarControllerV3(nullptr) {}
  ~AvatarControllerV3() override;
  explicit PROTOBUF_CONSTEXPR AvatarControllerV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarControllerV3(const AvatarControllerV3& from);
  AvatarControllerV3(AvatarControllerV3&& from) noexcept
    : AvatarControllerV3() {
    *this = ::std::move(from);
  }

  inline AvatarControllerV3& operator=(const AvatarControllerV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarControllerV3& operator=(AvatarControllerV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvatarControllerV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarControllerV3* internal_default_instance() {
    return reinterpret_cast<const AvatarControllerV3*>(
               &_AvatarControllerV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AvatarControllerV3& a, AvatarControllerV3& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarControllerV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarControllerV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarControllerV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarControllerV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvatarControllerV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvatarControllerV3& from) {
    AvatarControllerV3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvatarControllerV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.AvatarControllerV3";
  }
  protected:
  explicit AvatarControllerV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kBeamTargetFieldNumber = 2,
  };
  // .Transient.AvatarPositionV3 location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::Transient::AvatarPositionV3& location() const;
  PROTOBUF_NODISCARD ::Transient::AvatarPositionV3* release_location();
  ::Transient::AvatarPositionV3* mutable_location();
  void set_allocated_location(::Transient::AvatarPositionV3* location);
  private:
  const ::Transient::AvatarPositionV3& _internal_location() const;
  ::Transient::AvatarPositionV3* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::Transient::AvatarPositionV3* location);
  ::Transient::AvatarPositionV3* unsafe_arena_release_location();

  // optional .Common.Float3 beamTarget = 2;
  bool has_beamtarget() const;
  private:
  bool _internal_has_beamtarget() const;
  public:
  void clear_beamtarget();
  const ::Common::Float3& beamtarget() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_beamtarget();
  ::Common::Float3* mutable_beamtarget();
  void set_allocated_beamtarget(::Common::Float3* beamtarget);
  private:
  const ::Common::Float3& _internal_beamtarget() const;
  ::Common::Float3* _internal_mutable_beamtarget();
  public:
  void unsafe_arena_set_allocated_beamtarget(
      ::Common::Float3* beamtarget);
  ::Common::Float3* unsafe_arena_release_beamtarget();

  // @@protoc_insertion_point(class_scope:Transient.AvatarControllerV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Transient::AvatarPositionV3* location_;
    ::Common::Float3* beamtarget_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// -------------------------------------------------------------------

class AvatarRootV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transient.AvatarRootV3) */ {
 public:
  inline AvatarRootV3() : AvatarRootV3(nullptr) {}
  ~AvatarRootV3() override;
  explicit PROTOBUF_CONSTEXPR AvatarRootV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarRootV3(const AvatarRootV3& from);
  AvatarRootV3(AvatarRootV3&& from) noexcept
    : AvatarRootV3() {
    *this = ::std::move(from);
  }

  inline AvatarRootV3& operator=(const AvatarRootV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarRootV3& operator=(AvatarRootV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvatarRootV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarRootV3* internal_default_instance() {
    return reinterpret_cast<const AvatarRootV3*>(
               &_AvatarRootV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AvatarRootV3& a, AvatarRootV3& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarRootV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarRootV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarRootV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarRootV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvatarRootV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvatarRootV3& from) {
    AvatarRootV3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvatarRootV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transient.AvatarRootV3";
  }
  protected:
  explicit AvatarRootV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AvatarRootV3_AvatarMovementStateEnum AvatarMovementStateEnum;
  static constexpr AvatarMovementStateEnum None =
    AvatarRootV3_AvatarMovementStateEnum_None;
  static constexpr AvatarMovementStateEnum Jump =
    AvatarRootV3_AvatarMovementStateEnum_Jump;
  static constexpr AvatarMovementStateEnum Crouch =
    AvatarRootV3_AvatarMovementStateEnum_Crouch;
  static constexpr AvatarMovementStateEnum Fly =
    AvatarRootV3_AvatarMovementStateEnum_Fly;
  static constexpr AvatarMovementStateEnum Custom =
    AvatarRootV3_AvatarMovementStateEnum_Custom;
  static inline bool AvatarMovementStateEnum_IsValid(int value) {
    return AvatarRootV3_AvatarMovementStateEnum_IsValid(value);
  }
  static constexpr AvatarMovementStateEnum AvatarMovementStateEnum_MIN =
    AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_MIN;
  static constexpr AvatarMovementStateEnum AvatarMovementStateEnum_MAX =
    AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_MAX;
  static constexpr int AvatarMovementStateEnum_ARRAYSIZE =
    AvatarRootV3_AvatarMovementStateEnum_AvatarMovementStateEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AvatarMovementStateEnum_descriptor() {
    return AvatarRootV3_AvatarMovementStateEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& AvatarMovementStateEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AvatarMovementStateEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AvatarMovementStateEnum_Name.");
    return AvatarRootV3_AvatarMovementStateEnum_Name(enum_t_value);
  }
  static inline bool AvatarMovementStateEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AvatarMovementStateEnum* value) {
    return AvatarRootV3_AvatarMovementStateEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationStateCustomFieldNumber = 3,
    kLocationFieldNumber = 1,
    kAnimationStateFieldNumber = 2,
  };
  // optional string animationStateCustom = 3;
  bool has_animationstatecustom() const;
  private:
  bool _internal_has_animationstatecustom() const;
  public:
  void clear_animationstatecustom();
  const std::string& animationstatecustom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animationstatecustom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animationstatecustom();
  PROTOBUF_NODISCARD std::string* release_animationstatecustom();
  void set_allocated_animationstatecustom(std::string* animationstatecustom);
  private:
  const std::string& _internal_animationstatecustom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animationstatecustom(const std::string& value);
  std::string* _internal_mutable_animationstatecustom();
  public:

  // .Transient.AvatarPositionV3 location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::Transient::AvatarPositionV3& location() const;
  PROTOBUF_NODISCARD ::Transient::AvatarPositionV3* release_location();
  ::Transient::AvatarPositionV3* mutable_location();
  void set_allocated_location(::Transient::AvatarPositionV3* location);
  private:
  const ::Transient::AvatarPositionV3& _internal_location() const;
  ::Transient::AvatarPositionV3* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::Transient::AvatarPositionV3* location);
  ::Transient::AvatarPositionV3* unsafe_arena_release_location();

  // optional .Transient.AvatarRootV3.AvatarMovementStateEnum animationState = 2;
  bool has_animationstate() const;
  private:
  bool _internal_has_animationstate() const;
  public:
  void clear_animationstate();
  ::Transient::AvatarRootV3_AvatarMovementStateEnum animationstate() const;
  void set_animationstate(::Transient::AvatarRootV3_AvatarMovementStateEnum value);
  private:
  ::Transient::AvatarRootV3_AvatarMovementStateEnum _internal_animationstate() const;
  void _internal_set_animationstate(::Transient::AvatarRootV3_AvatarMovementStateEnum value);
  public:

  // @@protoc_insertion_point(class_scope:Transient.AvatarRootV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animationstatecustom_;
    ::Transient::AvatarPositionV3* location_;
    int animationstate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transient_5fevents_5fclient_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EvTransientJournalUpdate_V1

// string uniqueId = 3;
inline void EvTransientJournalUpdate_V1::clear_uniqueid() {
  _impl_.uniqueid_.ClearToEmpty();
}
inline const std::string& EvTransientJournalUpdate_V1::uniqueid() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.uniqueId)
  return _internal_uniqueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvTransientJournalUpdate_V1::set_uniqueid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Transient.EvTransientJournalUpdate.V1.uniqueId)
}
inline std::string* EvTransientJournalUpdate_V1::mutable_uniqueid() {
  std::string* _s = _internal_mutable_uniqueid();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.uniqueId)
  return _s;
}
inline const std::string& EvTransientJournalUpdate_V1::_internal_uniqueid() const {
  return _impl_.uniqueid_.Get();
}
inline void EvTransientJournalUpdate_V1::_internal_set_uniqueid(const std::string& value) {
  
  _impl_.uniqueid_.Set(value, GetArenaForAllocation());
}
inline std::string* EvTransientJournalUpdate_V1::_internal_mutable_uniqueid() {
  
  return _impl_.uniqueid_.Mutable(GetArenaForAllocation());
}
inline std::string* EvTransientJournalUpdate_V1::release_uniqueid() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.uniqueId)
  return _impl_.uniqueid_.Release();
}
inline void EvTransientJournalUpdate_V1::set_allocated_uniqueid(std::string* uniqueid) {
  if (uniqueid != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueid_.SetAllocated(uniqueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Transient.EvTransientJournalUpdate.V1.uniqueId)
}

// .Journal.OpLine2d line2d = 10;
inline bool EvTransientJournalUpdate_V1::_internal_has_line2d() const {
  return Op_case() == kLine2D;
}
inline bool EvTransientJournalUpdate_V1::has_line2d() const {
  return _internal_has_line2d();
}
inline void EvTransientJournalUpdate_V1::set_has_line2d() {
  _impl_._oneof_case_[0] = kLine2D;
}
inline ::Journal::OpLine2d* EvTransientJournalUpdate_V1::release_line2d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.line2d)
  if (_internal_has_line2d()) {
    clear_has_Op();
    ::Journal::OpLine2d* temp = _impl_.Op_.line2d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.line2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpLine2d& EvTransientJournalUpdate_V1::_internal_line2d() const {
  return _internal_has_line2d()
      ? *_impl_.Op_.line2d_
      : reinterpret_cast< ::Journal::OpLine2d&>(::Journal::_OpLine2d_default_instance_);
}
inline const ::Journal::OpLine2d& EvTransientJournalUpdate_V1::line2d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.line2d)
  return _internal_line2d();
}
inline ::Journal::OpLine2d* EvTransientJournalUpdate_V1::unsafe_arena_release_line2d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.line2d)
  if (_internal_has_line2d()) {
    clear_has_Op();
    ::Journal::OpLine2d* temp = _impl_.Op_.line2d_;
    _impl_.Op_.line2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_line2d(::Journal::OpLine2d* line2d) {
  clear_Op();
  if (line2d) {
    set_has_line2d();
    _impl_.Op_.line2d_ = line2d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.line2d)
}
inline ::Journal::OpLine2d* EvTransientJournalUpdate_V1::_internal_mutable_line2d() {
  if (!_internal_has_line2d()) {
    clear_Op();
    set_has_line2d();
    _impl_.Op_.line2d_ = CreateMaybeMessage< ::Journal::OpLine2d >(GetArenaForAllocation());
  }
  return _impl_.Op_.line2d_;
}
inline ::Journal::OpLine2d* EvTransientJournalUpdate_V1::mutable_line2d() {
  ::Journal::OpLine2d* _msg = _internal_mutable_line2d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.line2d)
  return _msg;
}

// .Journal.OpText2d text2d = 11;
inline bool EvTransientJournalUpdate_V1::_internal_has_text2d() const {
  return Op_case() == kText2D;
}
inline bool EvTransientJournalUpdate_V1::has_text2d() const {
  return _internal_has_text2d();
}
inline void EvTransientJournalUpdate_V1::set_has_text2d() {
  _impl_._oneof_case_[0] = kText2D;
}
inline ::Journal::OpText2d* EvTransientJournalUpdate_V1::release_text2d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.text2d)
  if (_internal_has_text2d()) {
    clear_has_Op();
    ::Journal::OpText2d* temp = _impl_.Op_.text2d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.text2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText2d& EvTransientJournalUpdate_V1::_internal_text2d() const {
  return _internal_has_text2d()
      ? *_impl_.Op_.text2d_
      : reinterpret_cast< ::Journal::OpText2d&>(::Journal::_OpText2d_default_instance_);
}
inline const ::Journal::OpText2d& EvTransientJournalUpdate_V1::text2d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.text2d)
  return _internal_text2d();
}
inline ::Journal::OpText2d* EvTransientJournalUpdate_V1::unsafe_arena_release_text2d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.text2d)
  if (_internal_has_text2d()) {
    clear_has_Op();
    ::Journal::OpText2d* temp = _impl_.Op_.text2d_;
    _impl_.Op_.text2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_text2d(::Journal::OpText2d* text2d) {
  clear_Op();
  if (text2d) {
    set_has_text2d();
    _impl_.Op_.text2d_ = text2d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.text2d)
}
inline ::Journal::OpText2d* EvTransientJournalUpdate_V1::_internal_mutable_text2d() {
  if (!_internal_has_text2d()) {
    clear_Op();
    set_has_text2d();
    _impl_.Op_.text2d_ = CreateMaybeMessage< ::Journal::OpText2d >(GetArenaForAllocation());
  }
  return _impl_.Op_.text2d_;
}
inline ::Journal::OpText2d* EvTransientJournalUpdate_V1::mutable_text2d() {
  ::Journal::OpText2d* _msg = _internal_mutable_text2d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.text2d)
  return _msg;
}

// .Journal.OpImage2d image2d = 12;
inline bool EvTransientJournalUpdate_V1::_internal_has_image2d() const {
  return Op_case() == kImage2D;
}
inline bool EvTransientJournalUpdate_V1::has_image2d() const {
  return _internal_has_image2d();
}
inline void EvTransientJournalUpdate_V1::set_has_image2d() {
  _impl_._oneof_case_[0] = kImage2D;
}
inline ::Journal::OpImage2d* EvTransientJournalUpdate_V1::release_image2d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.image2d)
  if (_internal_has_image2d()) {
    clear_has_Op();
    ::Journal::OpImage2d* temp = _impl_.Op_.image2d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.image2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpImage2d& EvTransientJournalUpdate_V1::_internal_image2d() const {
  return _internal_has_image2d()
      ? *_impl_.Op_.image2d_
      : reinterpret_cast< ::Journal::OpImage2d&>(::Journal::_OpImage2d_default_instance_);
}
inline const ::Journal::OpImage2d& EvTransientJournalUpdate_V1::image2d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.image2d)
  return _internal_image2d();
}
inline ::Journal::OpImage2d* EvTransientJournalUpdate_V1::unsafe_arena_release_image2d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.image2d)
  if (_internal_has_image2d()) {
    clear_has_Op();
    ::Journal::OpImage2d* temp = _impl_.Op_.image2d_;
    _impl_.Op_.image2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_image2d(::Journal::OpImage2d* image2d) {
  clear_Op();
  if (image2d) {
    set_has_image2d();
    _impl_.Op_.image2d_ = image2d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.image2d)
}
inline ::Journal::OpImage2d* EvTransientJournalUpdate_V1::_internal_mutable_image2d() {
  if (!_internal_has_image2d()) {
    clear_Op();
    set_has_image2d();
    _impl_.Op_.image2d_ = CreateMaybeMessage< ::Journal::OpImage2d >(GetArenaForAllocation());
  }
  return _impl_.Op_.image2d_;
}
inline ::Journal::OpImage2d* EvTransientJournalUpdate_V1::mutable_image2d() {
  ::Journal::OpImage2d* _msg = _internal_mutable_image2d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.image2d)
  return _msg;
}

// .Journal.OpLine3d line3d = 20;
inline bool EvTransientJournalUpdate_V1::_internal_has_line3d() const {
  return Op_case() == kLine3D;
}
inline bool EvTransientJournalUpdate_V1::has_line3d() const {
  return _internal_has_line3d();
}
inline void EvTransientJournalUpdate_V1::set_has_line3d() {
  _impl_._oneof_case_[0] = kLine3D;
}
inline ::Journal::OpLine3d* EvTransientJournalUpdate_V1::release_line3d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.line3d)
  if (_internal_has_line3d()) {
    clear_has_Op();
    ::Journal::OpLine3d* temp = _impl_.Op_.line3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.line3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpLine3d& EvTransientJournalUpdate_V1::_internal_line3d() const {
  return _internal_has_line3d()
      ? *_impl_.Op_.line3d_
      : reinterpret_cast< ::Journal::OpLine3d&>(::Journal::_OpLine3d_default_instance_);
}
inline const ::Journal::OpLine3d& EvTransientJournalUpdate_V1::line3d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.line3d)
  return _internal_line3d();
}
inline ::Journal::OpLine3d* EvTransientJournalUpdate_V1::unsafe_arena_release_line3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.line3d)
  if (_internal_has_line3d()) {
    clear_has_Op();
    ::Journal::OpLine3d* temp = _impl_.Op_.line3d_;
    _impl_.Op_.line3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_line3d(::Journal::OpLine3d* line3d) {
  clear_Op();
  if (line3d) {
    set_has_line3d();
    _impl_.Op_.line3d_ = line3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.line3d)
}
inline ::Journal::OpLine3d* EvTransientJournalUpdate_V1::_internal_mutable_line3d() {
  if (!_internal_has_line3d()) {
    clear_Op();
    set_has_line3d();
    _impl_.Op_.line3d_ = CreateMaybeMessage< ::Journal::OpLine3d >(GetArenaForAllocation());
  }
  return _impl_.Op_.line3d_;
}
inline ::Journal::OpLine3d* EvTransientJournalUpdate_V1::mutable_line3d() {
  ::Journal::OpLine3d* _msg = _internal_mutable_line3d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.line3d)
  return _msg;
}

// .Journal.OpText3d text3d = 21;
inline bool EvTransientJournalUpdate_V1::_internal_has_text3d() const {
  return Op_case() == kText3D;
}
inline bool EvTransientJournalUpdate_V1::has_text3d() const {
  return _internal_has_text3d();
}
inline void EvTransientJournalUpdate_V1::set_has_text3d() {
  _impl_._oneof_case_[0] = kText3D;
}
inline ::Journal::OpText3d* EvTransientJournalUpdate_V1::release_text3d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.text3d)
  if (_internal_has_text3d()) {
    clear_has_Op();
    ::Journal::OpText3d* temp = _impl_.Op_.text3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.text3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpText3d& EvTransientJournalUpdate_V1::_internal_text3d() const {
  return _internal_has_text3d()
      ? *_impl_.Op_.text3d_
      : reinterpret_cast< ::Journal::OpText3d&>(::Journal::_OpText3d_default_instance_);
}
inline const ::Journal::OpText3d& EvTransientJournalUpdate_V1::text3d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.text3d)
  return _internal_text3d();
}
inline ::Journal::OpText3d* EvTransientJournalUpdate_V1::unsafe_arena_release_text3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.text3d)
  if (_internal_has_text3d()) {
    clear_has_Op();
    ::Journal::OpText3d* temp = _impl_.Op_.text3d_;
    _impl_.Op_.text3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_text3d(::Journal::OpText3d* text3d) {
  clear_Op();
  if (text3d) {
    set_has_text3d();
    _impl_.Op_.text3d_ = text3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.text3d)
}
inline ::Journal::OpText3d* EvTransientJournalUpdate_V1::_internal_mutable_text3d() {
  if (!_internal_has_text3d()) {
    clear_Op();
    set_has_text3d();
    _impl_.Op_.text3d_ = CreateMaybeMessage< ::Journal::OpText3d >(GetArenaForAllocation());
  }
  return _impl_.Op_.text3d_;
}
inline ::Journal::OpText3d* EvTransientJournalUpdate_V1::mutable_text3d() {
  ::Journal::OpText3d* _msg = _internal_mutable_text3d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.text3d)
  return _msg;
}

// .Journal.OpImage3d image3d = 22;
inline bool EvTransientJournalUpdate_V1::_internal_has_image3d() const {
  return Op_case() == kImage3D;
}
inline bool EvTransientJournalUpdate_V1::has_image3d() const {
  return _internal_has_image3d();
}
inline void EvTransientJournalUpdate_V1::set_has_image3d() {
  _impl_._oneof_case_[0] = kImage3D;
}
inline ::Journal::OpImage3d* EvTransientJournalUpdate_V1::release_image3d() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.image3d)
  if (_internal_has_image3d()) {
    clear_has_Op();
    ::Journal::OpImage3d* temp = _impl_.Op_.image3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.image3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpImage3d& EvTransientJournalUpdate_V1::_internal_image3d() const {
  return _internal_has_image3d()
      ? *_impl_.Op_.image3d_
      : reinterpret_cast< ::Journal::OpImage3d&>(::Journal::_OpImage3d_default_instance_);
}
inline const ::Journal::OpImage3d& EvTransientJournalUpdate_V1::image3d() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.image3d)
  return _internal_image3d();
}
inline ::Journal::OpImage3d* EvTransientJournalUpdate_V1::unsafe_arena_release_image3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.image3d)
  if (_internal_has_image3d()) {
    clear_has_Op();
    ::Journal::OpImage3d* temp = _impl_.Op_.image3d_;
    _impl_.Op_.image3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_image3d(::Journal::OpImage3d* image3d) {
  clear_Op();
  if (image3d) {
    set_has_image3d();
    _impl_.Op_.image3d_ = image3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.image3d)
}
inline ::Journal::OpImage3d* EvTransientJournalUpdate_V1::_internal_mutable_image3d() {
  if (!_internal_has_image3d()) {
    clear_Op();
    set_has_image3d();
    _impl_.Op_.image3d_ = CreateMaybeMessage< ::Journal::OpImage3d >(GetArenaForAllocation());
  }
  return _impl_.Op_.image3d_;
}
inline ::Journal::OpImage3d* EvTransientJournalUpdate_V1::mutable_image3d() {
  ::Journal::OpImage3d* _msg = _internal_mutable_image3d();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.image3d)
  return _msg;
}

// .Journal.OpCreateObject createObject = 32;
inline bool EvTransientJournalUpdate_V1::_internal_has_createobject() const {
  return Op_case() == kCreateObject;
}
inline bool EvTransientJournalUpdate_V1::has_createobject() const {
  return _internal_has_createobject();
}
inline void EvTransientJournalUpdate_V1::set_has_createobject() {
  _impl_._oneof_case_[0] = kCreateObject;
}
inline ::Journal::OpCreateObject* EvTransientJournalUpdate_V1::release_createobject() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.createObject)
  if (_internal_has_createobject()) {
    clear_has_Op();
    ::Journal::OpCreateObject* temp = _impl_.Op_.createobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.createobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpCreateObject& EvTransientJournalUpdate_V1::_internal_createobject() const {
  return _internal_has_createobject()
      ? *_impl_.Op_.createobject_
      : reinterpret_cast< ::Journal::OpCreateObject&>(::Journal::_OpCreateObject_default_instance_);
}
inline const ::Journal::OpCreateObject& EvTransientJournalUpdate_V1::createobject() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.createObject)
  return _internal_createobject();
}
inline ::Journal::OpCreateObject* EvTransientJournalUpdate_V1::unsafe_arena_release_createobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.createObject)
  if (_internal_has_createobject()) {
    clear_has_Op();
    ::Journal::OpCreateObject* temp = _impl_.Op_.createobject_;
    _impl_.Op_.createobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_createobject(::Journal::OpCreateObject* createobject) {
  clear_Op();
  if (createobject) {
    set_has_createobject();
    _impl_.Op_.createobject_ = createobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.createObject)
}
inline ::Journal::OpCreateObject* EvTransientJournalUpdate_V1::_internal_mutable_createobject() {
  if (!_internal_has_createobject()) {
    clear_Op();
    set_has_createobject();
    _impl_.Op_.createobject_ = CreateMaybeMessage< ::Journal::OpCreateObject >(GetArenaForAllocation());
  }
  return _impl_.Op_.createobject_;
}
inline ::Journal::OpCreateObject* EvTransientJournalUpdate_V1::mutable_createobject() {
  ::Journal::OpCreateObject* _msg = _internal_mutable_createobject();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.createObject)
  return _msg;
}

// .Journal.OpSetPartHighlight setPartHighlight = 61;
inline bool EvTransientJournalUpdate_V1::_internal_has_setparthighlight() const {
  return Op_case() == kSetPartHighlight;
}
inline bool EvTransientJournalUpdate_V1::has_setparthighlight() const {
  return _internal_has_setparthighlight();
}
inline void EvTransientJournalUpdate_V1::set_has_setparthighlight() {
  _impl_._oneof_case_[0] = kSetPartHighlight;
}
inline ::Journal::OpSetPartHighlight* EvTransientJournalUpdate_V1::release_setparthighlight() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.setPartHighlight)
  if (_internal_has_setparthighlight()) {
    clear_has_Op();
    ::Journal::OpSetPartHighlight* temp = _impl_.Op_.setparthighlight_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.setparthighlight_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpSetPartHighlight& EvTransientJournalUpdate_V1::_internal_setparthighlight() const {
  return _internal_has_setparthighlight()
      ? *_impl_.Op_.setparthighlight_
      : reinterpret_cast< ::Journal::OpSetPartHighlight&>(::Journal::_OpSetPartHighlight_default_instance_);
}
inline const ::Journal::OpSetPartHighlight& EvTransientJournalUpdate_V1::setparthighlight() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.setPartHighlight)
  return _internal_setparthighlight();
}
inline ::Journal::OpSetPartHighlight* EvTransientJournalUpdate_V1::unsafe_arena_release_setparthighlight() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.setPartHighlight)
  if (_internal_has_setparthighlight()) {
    clear_has_Op();
    ::Journal::OpSetPartHighlight* temp = _impl_.Op_.setparthighlight_;
    _impl_.Op_.setparthighlight_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_setparthighlight(::Journal::OpSetPartHighlight* setparthighlight) {
  clear_Op();
  if (setparthighlight) {
    set_has_setparthighlight();
    _impl_.Op_.setparthighlight_ = setparthighlight;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.setPartHighlight)
}
inline ::Journal::OpSetPartHighlight* EvTransientJournalUpdate_V1::_internal_mutable_setparthighlight() {
  if (!_internal_has_setparthighlight()) {
    clear_Op();
    set_has_setparthighlight();
    _impl_.Op_.setparthighlight_ = CreateMaybeMessage< ::Journal::OpSetPartHighlight >(GetArenaForAllocation());
  }
  return _impl_.Op_.setparthighlight_;
}
inline ::Journal::OpSetPartHighlight* EvTransientJournalUpdate_V1::mutable_setparthighlight() {
  ::Journal::OpSetPartHighlight* _msg = _internal_mutable_setparthighlight();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.setPartHighlight)
  return _msg;
}

// .Journal.OpUpdatePropertyValue updatePropertyValue = 13;
inline bool EvTransientJournalUpdate_V1::_internal_has_updatepropertyvalue() const {
  return Op_case() == kUpdatePropertyValue;
}
inline bool EvTransientJournalUpdate_V1::has_updatepropertyvalue() const {
  return _internal_has_updatepropertyvalue();
}
inline void EvTransientJournalUpdate_V1::set_has_updatepropertyvalue() {
  _impl_._oneof_case_[0] = kUpdatePropertyValue;
}
inline ::Journal::OpUpdatePropertyValue* EvTransientJournalUpdate_V1::release_updatepropertyvalue() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.updatePropertyValue)
  if (_internal_has_updatepropertyvalue()) {
    clear_has_Op();
    ::Journal::OpUpdatePropertyValue* temp = _impl_.Op_.updatepropertyvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.updatepropertyvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpUpdatePropertyValue& EvTransientJournalUpdate_V1::_internal_updatepropertyvalue() const {
  return _internal_has_updatepropertyvalue()
      ? *_impl_.Op_.updatepropertyvalue_
      : reinterpret_cast< ::Journal::OpUpdatePropertyValue&>(::Journal::_OpUpdatePropertyValue_default_instance_);
}
inline const ::Journal::OpUpdatePropertyValue& EvTransientJournalUpdate_V1::updatepropertyvalue() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.updatePropertyValue)
  return _internal_updatepropertyvalue();
}
inline ::Journal::OpUpdatePropertyValue* EvTransientJournalUpdate_V1::unsafe_arena_release_updatepropertyvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.updatePropertyValue)
  if (_internal_has_updatepropertyvalue()) {
    clear_has_Op();
    ::Journal::OpUpdatePropertyValue* temp = _impl_.Op_.updatepropertyvalue_;
    _impl_.Op_.updatepropertyvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_updatepropertyvalue(::Journal::OpUpdatePropertyValue* updatepropertyvalue) {
  clear_Op();
  if (updatepropertyvalue) {
    set_has_updatepropertyvalue();
    _impl_.Op_.updatepropertyvalue_ = updatepropertyvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.updatePropertyValue)
}
inline ::Journal::OpUpdatePropertyValue* EvTransientJournalUpdate_V1::_internal_mutable_updatepropertyvalue() {
  if (!_internal_has_updatepropertyvalue()) {
    clear_Op();
    set_has_updatepropertyvalue();
    _impl_.Op_.updatepropertyvalue_ = CreateMaybeMessage< ::Journal::OpUpdatePropertyValue >(GetArenaForAllocation());
  }
  return _impl_.Op_.updatepropertyvalue_;
}
inline ::Journal::OpUpdatePropertyValue* EvTransientJournalUpdate_V1::mutable_updatepropertyvalue() {
  ::Journal::OpUpdatePropertyValue* _msg = _internal_mutable_updatepropertyvalue();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.updatePropertyValue)
  return _msg;
}

// .Journal.OpDeclareProperty declareProperty = 14;
inline bool EvTransientJournalUpdate_V1::_internal_has_declareproperty() const {
  return Op_case() == kDeclareProperty;
}
inline bool EvTransientJournalUpdate_V1::has_declareproperty() const {
  return _internal_has_declareproperty();
}
inline void EvTransientJournalUpdate_V1::set_has_declareproperty() {
  _impl_._oneof_case_[0] = kDeclareProperty;
}
inline ::Journal::OpDeclareProperty* EvTransientJournalUpdate_V1::release_declareproperty() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.declareProperty)
  if (_internal_has_declareproperty()) {
    clear_has_Op();
    ::Journal::OpDeclareProperty* temp = _impl_.Op_.declareproperty_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.declareproperty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpDeclareProperty& EvTransientJournalUpdate_V1::_internal_declareproperty() const {
  return _internal_has_declareproperty()
      ? *_impl_.Op_.declareproperty_
      : reinterpret_cast< ::Journal::OpDeclareProperty&>(::Journal::_OpDeclareProperty_default_instance_);
}
inline const ::Journal::OpDeclareProperty& EvTransientJournalUpdate_V1::declareproperty() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.declareProperty)
  return _internal_declareproperty();
}
inline ::Journal::OpDeclareProperty* EvTransientJournalUpdate_V1::unsafe_arena_release_declareproperty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.declareProperty)
  if (_internal_has_declareproperty()) {
    clear_has_Op();
    ::Journal::OpDeclareProperty* temp = _impl_.Op_.declareproperty_;
    _impl_.Op_.declareproperty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_declareproperty(::Journal::OpDeclareProperty* declareproperty) {
  clear_Op();
  if (declareproperty) {
    set_has_declareproperty();
    _impl_.Op_.declareproperty_ = declareproperty;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.declareProperty)
}
inline ::Journal::OpDeclareProperty* EvTransientJournalUpdate_V1::_internal_mutable_declareproperty() {
  if (!_internal_has_declareproperty()) {
    clear_Op();
    set_has_declareproperty();
    _impl_.Op_.declareproperty_ = CreateMaybeMessage< ::Journal::OpDeclareProperty >(GetArenaForAllocation());
  }
  return _impl_.Op_.declareproperty_;
}
inline ::Journal::OpDeclareProperty* EvTransientJournalUpdate_V1::mutable_declareproperty() {
  ::Journal::OpDeclareProperty* _msg = _internal_mutable_declareproperty();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.declareProperty)
  return _msg;
}

// .Journal.OpUserAuthorityData userAuthorityData = 16;
inline bool EvTransientJournalUpdate_V1::_internal_has_userauthoritydata() const {
  return Op_case() == kUserAuthorityData;
}
inline bool EvTransientJournalUpdate_V1::has_userauthoritydata() const {
  return _internal_has_userauthoritydata();
}
inline void EvTransientJournalUpdate_V1::set_has_userauthoritydata() {
  _impl_._oneof_case_[0] = kUserAuthorityData;
}
inline ::Journal::OpUserAuthorityData* EvTransientJournalUpdate_V1::release_userauthoritydata() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.V1.userAuthorityData)
  if (_internal_has_userauthoritydata()) {
    clear_has_Op();
    ::Journal::OpUserAuthorityData* temp = _impl_.Op_.userauthoritydata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Op_.userauthoritydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Journal::OpUserAuthorityData& EvTransientJournalUpdate_V1::_internal_userauthoritydata() const {
  return _internal_has_userauthoritydata()
      ? *_impl_.Op_.userauthoritydata_
      : reinterpret_cast< ::Journal::OpUserAuthorityData&>(::Journal::_OpUserAuthorityData_default_instance_);
}
inline const ::Journal::OpUserAuthorityData& EvTransientJournalUpdate_V1::userauthoritydata() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.V1.userAuthorityData)
  return _internal_userauthoritydata();
}
inline ::Journal::OpUserAuthorityData* EvTransientJournalUpdate_V1::unsafe_arena_release_userauthoritydata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.V1.userAuthorityData)
  if (_internal_has_userauthoritydata()) {
    clear_has_Op();
    ::Journal::OpUserAuthorityData* temp = _impl_.Op_.userauthoritydata_;
    _impl_.Op_.userauthoritydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate_V1::unsafe_arena_set_allocated_userauthoritydata(::Journal::OpUserAuthorityData* userauthoritydata) {
  clear_Op();
  if (userauthoritydata) {
    set_has_userauthoritydata();
    _impl_.Op_.userauthoritydata_ = userauthoritydata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.V1.userAuthorityData)
}
inline ::Journal::OpUserAuthorityData* EvTransientJournalUpdate_V1::_internal_mutable_userauthoritydata() {
  if (!_internal_has_userauthoritydata()) {
    clear_Op();
    set_has_userauthoritydata();
    _impl_.Op_.userauthoritydata_ = CreateMaybeMessage< ::Journal::OpUserAuthorityData >(GetArenaForAllocation());
  }
  return _impl_.Op_.userauthoritydata_;
}
inline ::Journal::OpUserAuthorityData* EvTransientJournalUpdate_V1::mutable_userauthoritydata() {
  ::Journal::OpUserAuthorityData* _msg = _internal_mutable_userauthoritydata();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.V1.userAuthorityData)
  return _msg;
}

inline bool EvTransientJournalUpdate_V1::has_Op() const {
  return Op_case() != OP_NOT_SET;
}
inline void EvTransientJournalUpdate_V1::clear_has_Op() {
  _impl_._oneof_case_[0] = OP_NOT_SET;
}
inline EvTransientJournalUpdate_V1::OpCase EvTransientJournalUpdate_V1::Op_case() const {
  return EvTransientJournalUpdate_V1::OpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EvTransientJournalUpdate

// .Transient.EvTransientJournalUpdate.V1 v1 = 1;
inline bool EvTransientJournalUpdate::_internal_has_v1() const {
  return V_case() == kV1;
}
inline bool EvTransientJournalUpdate::has_v1() const {
  return _internal_has_v1();
}
inline void EvTransientJournalUpdate::set_has_v1() {
  _impl_._oneof_case_[0] = kV1;
}
inline void EvTransientJournalUpdate::clear_v1() {
  if (_internal_has_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v1_;
    }
    clear_has_V();
  }
}
inline ::Transient::EvTransientJournalUpdate_V1* EvTransientJournalUpdate::release_v1() {
  // @@protoc_insertion_point(field_release:Transient.EvTransientJournalUpdate.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Transient::EvTransientJournalUpdate_V1* temp = _impl_.V_.v1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Transient::EvTransientJournalUpdate_V1& EvTransientJournalUpdate::_internal_v1() const {
  return _internal_has_v1()
      ? *_impl_.V_.v1_
      : reinterpret_cast< ::Transient::EvTransientJournalUpdate_V1&>(::Transient::_EvTransientJournalUpdate_V1_default_instance_);
}
inline const ::Transient::EvTransientJournalUpdate_V1& EvTransientJournalUpdate::v1() const {
  // @@protoc_insertion_point(field_get:Transient.EvTransientJournalUpdate.v1)
  return _internal_v1();
}
inline ::Transient::EvTransientJournalUpdate_V1* EvTransientJournalUpdate::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvTransientJournalUpdate.v1)
  if (_internal_has_v1()) {
    clear_has_V();
    ::Transient::EvTransientJournalUpdate_V1* temp = _impl_.V_.v1_;
    _impl_.V_.v1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvTransientJournalUpdate::unsafe_arena_set_allocated_v1(::Transient::EvTransientJournalUpdate_V1* v1) {
  clear_V();
  if (v1) {
    set_has_v1();
    _impl_.V_.v1_ = v1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvTransientJournalUpdate.v1)
}
inline ::Transient::EvTransientJournalUpdate_V1* EvTransientJournalUpdate::_internal_mutable_v1() {
  if (!_internal_has_v1()) {
    clear_V();
    set_has_v1();
    _impl_.V_.v1_ = CreateMaybeMessage< ::Transient::EvTransientJournalUpdate_V1 >(GetArenaForAllocation());
  }
  return _impl_.V_.v1_;
}
inline ::Transient::EvTransientJournalUpdate_V1* EvTransientJournalUpdate::mutable_v1() {
  ::Transient::EvTransientJournalUpdate_V1* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:Transient.EvTransientJournalUpdate.v1)
  return _msg;
}

inline bool EvTransientJournalUpdate::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void EvTransientJournalUpdate::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline EvTransientJournalUpdate::VCase EvTransientJournalUpdate::V_case() const {
  return EvTransientJournalUpdate::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EvCopresence_V3

// string fromConnectionId = 1;
inline void EvCopresence_V3::clear_fromconnectionid() {
  _impl_.fromconnectionid_.ClearToEmpty();
}
inline const std::string& EvCopresence_V3::fromconnectionid() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.fromConnectionId)
  return _internal_fromconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvCopresence_V3::set_fromconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Transient.EvCopresence.V3.fromConnectionId)
}
inline std::string* EvCopresence_V3::mutable_fromconnectionid() {
  std::string* _s = _internal_mutable_fromconnectionid();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.fromConnectionId)
  return _s;
}
inline const std::string& EvCopresence_V3::_internal_fromconnectionid() const {
  return _impl_.fromconnectionid_.Get();
}
inline void EvCopresence_V3::_internal_set_fromconnectionid(const std::string& value) {
  
  _impl_.fromconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* EvCopresence_V3::_internal_mutable_fromconnectionid() {
  
  return _impl_.fromconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* EvCopresence_V3::release_fromconnectionid() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.fromConnectionId)
  return _impl_.fromconnectionid_.Release();
}
inline void EvCopresence_V3::set_allocated_fromconnectionid(std::string* fromconnectionid) {
  if (fromconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.fromconnectionid_.SetAllocated(fromconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromconnectionid_.IsDefault()) {
    _impl_.fromconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.fromConnectionId)
}

// optional string followingConnectionId = 2;
inline bool EvCopresence_V3::_internal_has_followingconnectionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EvCopresence_V3::has_followingconnectionid() const {
  return _internal_has_followingconnectionid();
}
inline void EvCopresence_V3::clear_followingconnectionid() {
  _impl_.followingconnectionid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EvCopresence_V3::followingconnectionid() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.followingConnectionId)
  return _internal_followingconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvCopresence_V3::set_followingconnectionid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.followingconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Transient.EvCopresence.V3.followingConnectionId)
}
inline std::string* EvCopresence_V3::mutable_followingconnectionid() {
  std::string* _s = _internal_mutable_followingconnectionid();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.followingConnectionId)
  return _s;
}
inline const std::string& EvCopresence_V3::_internal_followingconnectionid() const {
  return _impl_.followingconnectionid_.Get();
}
inline void EvCopresence_V3::_internal_set_followingconnectionid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.followingconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* EvCopresence_V3::_internal_mutable_followingconnectionid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.followingconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* EvCopresence_V3::release_followingconnectionid() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.followingConnectionId)
  if (!_internal_has_followingconnectionid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.followingconnectionid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.followingconnectionid_.IsDefault()) {
    _impl_.followingconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EvCopresence_V3::set_allocated_followingconnectionid(std::string* followingconnectionid) {
  if (followingconnectionid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.followingconnectionid_.SetAllocated(followingconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.followingconnectionid_.IsDefault()) {
    _impl_.followingconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.followingConnectionId)
}

// optional float scale = 3;
inline bool EvCopresence_V3::_internal_has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EvCopresence_V3::has_scale() const {
  return _internal_has_scale();
}
inline void EvCopresence_V3::clear_scale() {
  _impl_.scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float EvCopresence_V3::_internal_scale() const {
  return _impl_.scale_;
}
inline float EvCopresence_V3::scale() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.scale)
  return _internal_scale();
}
inline void EvCopresence_V3::_internal_set_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.scale_ = value;
}
inline void EvCopresence_V3::set_scale(float value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:Transient.EvCopresence.V3.scale)
}

// optional .Transient.AvatarRootV3 root = 8;
inline bool EvCopresence_V3::_internal_has_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_ != nullptr);
  return value;
}
inline bool EvCopresence_V3::has_root() const {
  return _internal_has_root();
}
inline void EvCopresence_V3::clear_root() {
  if (_impl_.root_ != nullptr) _impl_.root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Transient::AvatarRootV3& EvCopresence_V3::_internal_root() const {
  const ::Transient::AvatarRootV3* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarRootV3&>(
      ::Transient::_AvatarRootV3_default_instance_);
}
inline const ::Transient::AvatarRootV3& EvCopresence_V3::root() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.root)
  return _internal_root();
}
inline void EvCopresence_V3::unsafe_arena_set_allocated_root(
    ::Transient::AvatarRootV3* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.V3.root)
}
inline ::Transient::AvatarRootV3* EvCopresence_V3::release_root() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Transient::AvatarRootV3* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarRootV3* EvCopresence_V3::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.root)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Transient::AvatarRootV3* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::Transient::AvatarRootV3* EvCopresence_V3::_internal_mutable_root() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarRootV3>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::Transient::AvatarRootV3* EvCopresence_V3::mutable_root() {
  ::Transient::AvatarRootV3* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.root)
  return _msg;
}
inline void EvCopresence_V3::set_allocated_root(::Transient::AvatarRootV3* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.root)
}

// optional .Transient.AvatarControllerV3 leftController = 9;
inline bool EvCopresence_V3::_internal_has_leftcontroller() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leftcontroller_ != nullptr);
  return value;
}
inline bool EvCopresence_V3::has_leftcontroller() const {
  return _internal_has_leftcontroller();
}
inline void EvCopresence_V3::clear_leftcontroller() {
  if (_impl_.leftcontroller_ != nullptr) _impl_.leftcontroller_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Transient::AvatarControllerV3& EvCopresence_V3::_internal_leftcontroller() const {
  const ::Transient::AvatarControllerV3* p = _impl_.leftcontroller_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarControllerV3&>(
      ::Transient::_AvatarControllerV3_default_instance_);
}
inline const ::Transient::AvatarControllerV3& EvCopresence_V3::leftcontroller() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.leftController)
  return _internal_leftcontroller();
}
inline void EvCopresence_V3::unsafe_arena_set_allocated_leftcontroller(
    ::Transient::AvatarControllerV3* leftcontroller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leftcontroller_);
  }
  _impl_.leftcontroller_ = leftcontroller;
  if (leftcontroller) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.V3.leftController)
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::release_leftcontroller() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Transient::AvatarControllerV3* temp = _impl_.leftcontroller_;
  _impl_.leftcontroller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::unsafe_arena_release_leftcontroller() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.leftController)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Transient::AvatarControllerV3* temp = _impl_.leftcontroller_;
  _impl_.leftcontroller_ = nullptr;
  return temp;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::_internal_mutable_leftcontroller() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.leftcontroller_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarControllerV3>(GetArenaForAllocation());
    _impl_.leftcontroller_ = p;
  }
  return _impl_.leftcontroller_;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::mutable_leftcontroller() {
  ::Transient::AvatarControllerV3* _msg = _internal_mutable_leftcontroller();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.leftController)
  return _msg;
}
inline void EvCopresence_V3::set_allocated_leftcontroller(::Transient::AvatarControllerV3* leftcontroller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.leftcontroller_;
  }
  if (leftcontroller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leftcontroller);
    if (message_arena != submessage_arena) {
      leftcontroller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leftcontroller, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.leftcontroller_ = leftcontroller;
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.leftController)
}

// optional .Transient.AvatarControllerV3 rightController = 10;
inline bool EvCopresence_V3::_internal_has_rightcontroller() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rightcontroller_ != nullptr);
  return value;
}
inline bool EvCopresence_V3::has_rightcontroller() const {
  return _internal_has_rightcontroller();
}
inline void EvCopresence_V3::clear_rightcontroller() {
  if (_impl_.rightcontroller_ != nullptr) _impl_.rightcontroller_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::Transient::AvatarControllerV3& EvCopresence_V3::_internal_rightcontroller() const {
  const ::Transient::AvatarControllerV3* p = _impl_.rightcontroller_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarControllerV3&>(
      ::Transient::_AvatarControllerV3_default_instance_);
}
inline const ::Transient::AvatarControllerV3& EvCopresence_V3::rightcontroller() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.rightController)
  return _internal_rightcontroller();
}
inline void EvCopresence_V3::unsafe_arena_set_allocated_rightcontroller(
    ::Transient::AvatarControllerV3* rightcontroller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rightcontroller_);
  }
  _impl_.rightcontroller_ = rightcontroller;
  if (rightcontroller) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.V3.rightController)
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::release_rightcontroller() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Transient::AvatarControllerV3* temp = _impl_.rightcontroller_;
  _impl_.rightcontroller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::unsafe_arena_release_rightcontroller() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.rightController)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Transient::AvatarControllerV3* temp = _impl_.rightcontroller_;
  _impl_.rightcontroller_ = nullptr;
  return temp;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::_internal_mutable_rightcontroller() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rightcontroller_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarControllerV3>(GetArenaForAllocation());
    _impl_.rightcontroller_ = p;
  }
  return _impl_.rightcontroller_;
}
inline ::Transient::AvatarControllerV3* EvCopresence_V3::mutable_rightcontroller() {
  ::Transient::AvatarControllerV3* _msg = _internal_mutable_rightcontroller();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.rightController)
  return _msg;
}
inline void EvCopresence_V3::set_allocated_rightcontroller(::Transient::AvatarControllerV3* rightcontroller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rightcontroller_;
  }
  if (rightcontroller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rightcontroller);
    if (message_arena != submessage_arena) {
      rightcontroller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rightcontroller, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rightcontroller_ = rightcontroller;
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.rightController)
}

// optional .Transient.AvatarPositionV3 view = 11;
inline bool EvCopresence_V3::_internal_has_view() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.view_ != nullptr);
  return value;
}
inline bool EvCopresence_V3::has_view() const {
  return _internal_has_view();
}
inline void EvCopresence_V3::clear_view() {
  if (_impl_.view_ != nullptr) _impl_.view_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::Transient::AvatarPositionV3& EvCopresence_V3::_internal_view() const {
  const ::Transient::AvatarPositionV3* p = _impl_.view_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarPositionV3&>(
      ::Transient::_AvatarPositionV3_default_instance_);
}
inline const ::Transient::AvatarPositionV3& EvCopresence_V3::view() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.view)
  return _internal_view();
}
inline void EvCopresence_V3::unsafe_arena_set_allocated_view(
    ::Transient::AvatarPositionV3* view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_);
  }
  _impl_.view_ = view;
  if (view) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.V3.view)
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::release_view() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Transient::AvatarPositionV3* temp = _impl_.view_;
  _impl_.view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.view)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Transient::AvatarPositionV3* temp = _impl_.view_;
  _impl_.view_ = nullptr;
  return temp;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::_internal_mutable_view() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.view_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarPositionV3>(GetArenaForAllocation());
    _impl_.view_ = p;
  }
  return _impl_.view_;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::mutable_view() {
  ::Transient::AvatarPositionV3* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.view)
  return _msg;
}
inline void EvCopresence_V3::set_allocated_view(::Transient::AvatarPositionV3* view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.view_;
  }
  if (view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view);
    if (message_arena != submessage_arena) {
      view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.view_ = view;
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.view)
}

// optional .Transient.AvatarPositionV3 head = 12;
inline bool EvCopresence_V3::_internal_has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline bool EvCopresence_V3::has_head() const {
  return _internal_has_head();
}
inline void EvCopresence_V3::clear_head() {
  if (_impl_.head_ != nullptr) _impl_.head_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::Transient::AvatarPositionV3& EvCopresence_V3::_internal_head() const {
  const ::Transient::AvatarPositionV3* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarPositionV3&>(
      ::Transient::_AvatarPositionV3_default_instance_);
}
inline const ::Transient::AvatarPositionV3& EvCopresence_V3::head() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.V3.head)
  return _internal_head();
}
inline void EvCopresence_V3::unsafe_arena_set_allocated_head(
    ::Transient::AvatarPositionV3* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.V3.head)
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::release_head() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::Transient::AvatarPositionV3* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.V3.head)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::Transient::AvatarPositionV3* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::_internal_mutable_head() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarPositionV3>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::Transient::AvatarPositionV3* EvCopresence_V3::mutable_head() {
  ::Transient::AvatarPositionV3* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.V3.head)
  return _msg;
}
inline void EvCopresence_V3::set_allocated_head(::Transient::AvatarPositionV3* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:Transient.EvCopresence.V3.head)
}

// -------------------------------------------------------------------

// EvCopresence

// .Transient.EvCopresence.V3 v3 = 3;
inline bool EvCopresence::_internal_has_v3() const {
  return V_case() == kV3;
}
inline bool EvCopresence::has_v3() const {
  return _internal_has_v3();
}
inline void EvCopresence::set_has_v3() {
  _impl_._oneof_case_[0] = kV3;
}
inline void EvCopresence::clear_v3() {
  if (_internal_has_v3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.V_.v3_;
    }
    clear_has_V();
  }
}
inline ::Transient::EvCopresence_V3* EvCopresence::release_v3() {
  // @@protoc_insertion_point(field_release:Transient.EvCopresence.v3)
  if (_internal_has_v3()) {
    clear_has_V();
    ::Transient::EvCopresence_V3* temp = _impl_.V_.v3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.V_.v3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Transient::EvCopresence_V3& EvCopresence::_internal_v3() const {
  return _internal_has_v3()
      ? *_impl_.V_.v3_
      : reinterpret_cast< ::Transient::EvCopresence_V3&>(::Transient::_EvCopresence_V3_default_instance_);
}
inline const ::Transient::EvCopresence_V3& EvCopresence::v3() const {
  // @@protoc_insertion_point(field_get:Transient.EvCopresence.v3)
  return _internal_v3();
}
inline ::Transient::EvCopresence_V3* EvCopresence::unsafe_arena_release_v3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Transient.EvCopresence.v3)
  if (_internal_has_v3()) {
    clear_has_V();
    ::Transient::EvCopresence_V3* temp = _impl_.V_.v3_;
    _impl_.V_.v3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EvCopresence::unsafe_arena_set_allocated_v3(::Transient::EvCopresence_V3* v3) {
  clear_V();
  if (v3) {
    set_has_v3();
    _impl_.V_.v3_ = v3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.EvCopresence.v3)
}
inline ::Transient::EvCopresence_V3* EvCopresence::_internal_mutable_v3() {
  if (!_internal_has_v3()) {
    clear_V();
    set_has_v3();
    _impl_.V_.v3_ = CreateMaybeMessage< ::Transient::EvCopresence_V3 >(GetArenaForAllocation());
  }
  return _impl_.V_.v3_;
}
inline ::Transient::EvCopresence_V3* EvCopresence::mutable_v3() {
  ::Transient::EvCopresence_V3* _msg = _internal_mutable_v3();
  // @@protoc_insertion_point(field_mutable:Transient.EvCopresence.v3)
  return _msg;
}

inline bool EvCopresence::has_V() const {
  return V_case() != V_NOT_SET;
}
inline void EvCopresence::clear_has_V() {
  _impl_._oneof_case_[0] = V_NOT_SET;
}
inline EvCopresence::VCase EvCopresence::V_case() const {
  return EvCopresence::VCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AvatarPositionV3

// .Common.Float3 position = 1;
inline bool AvatarPositionV3::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool AvatarPositionV3::has_position() const {
  return _internal_has_position();
}
inline const ::Common::Float3& AvatarPositionV3::_internal_position() const {
  const ::Common::Float3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& AvatarPositionV3::position() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarPositionV3.position)
  return _internal_position();
}
inline void AvatarPositionV3::unsafe_arena_set_allocated_position(
    ::Common::Float3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.AvatarPositionV3.position)
}
inline ::Common::Float3* AvatarPositionV3::release_position() {
  
  ::Common::Float3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* AvatarPositionV3::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Transient.AvatarPositionV3.position)
  
  ::Common::Float3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Common::Float3* AvatarPositionV3::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::Common::Float3* AvatarPositionV3::mutable_position() {
  ::Common::Float3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarPositionV3.position)
  return _msg;
}
inline void AvatarPositionV3::set_allocated_position(::Common::Float3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarPositionV3.position)
}

// .Common.Float3 rotation = 2;
inline bool AvatarPositionV3::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool AvatarPositionV3::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::Common::Float3& AvatarPositionV3::_internal_rotation() const {
  const ::Common::Float3* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& AvatarPositionV3::rotation() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarPositionV3.rotation)
  return _internal_rotation();
}
inline void AvatarPositionV3::unsafe_arena_set_allocated_rotation(
    ::Common::Float3* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.AvatarPositionV3.rotation)
}
inline ::Common::Float3* AvatarPositionV3::release_rotation() {
  
  ::Common::Float3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* AvatarPositionV3::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Transient.AvatarPositionV3.rotation)
  
  ::Common::Float3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Common::Float3* AvatarPositionV3::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::Common::Float3* AvatarPositionV3::mutable_rotation() {
  ::Common::Float3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarPositionV3.rotation)
  return _msg;
}
inline void AvatarPositionV3::set_allocated_rotation(::Common::Float3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarPositionV3.rotation)
}

// -------------------------------------------------------------------

// AvatarControllerV3

// .Transient.AvatarPositionV3 location = 1;
inline bool AvatarControllerV3::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AvatarControllerV3::has_location() const {
  return _internal_has_location();
}
inline void AvatarControllerV3::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::Transient::AvatarPositionV3& AvatarControllerV3::_internal_location() const {
  const ::Transient::AvatarPositionV3* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarPositionV3&>(
      ::Transient::_AvatarPositionV3_default_instance_);
}
inline const ::Transient::AvatarPositionV3& AvatarControllerV3::location() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarControllerV3.location)
  return _internal_location();
}
inline void AvatarControllerV3::unsafe_arena_set_allocated_location(
    ::Transient::AvatarPositionV3* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.AvatarControllerV3.location)
}
inline ::Transient::AvatarPositionV3* AvatarControllerV3::release_location() {
  
  ::Transient::AvatarPositionV3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarPositionV3* AvatarControllerV3::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:Transient.AvatarControllerV3.location)
  
  ::Transient::AvatarPositionV3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::Transient::AvatarPositionV3* AvatarControllerV3::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarPositionV3>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::Transient::AvatarPositionV3* AvatarControllerV3::mutable_location() {
  ::Transient::AvatarPositionV3* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarControllerV3.location)
  return _msg;
}
inline void AvatarControllerV3::set_allocated_location(::Transient::AvatarPositionV3* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarControllerV3.location)
}

// optional .Common.Float3 beamTarget = 2;
inline bool AvatarControllerV3::_internal_has_beamtarget() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.beamtarget_ != nullptr);
  return value;
}
inline bool AvatarControllerV3::has_beamtarget() const {
  return _internal_has_beamtarget();
}
inline const ::Common::Float3& AvatarControllerV3::_internal_beamtarget() const {
  const ::Common::Float3* p = _impl_.beamtarget_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& AvatarControllerV3::beamtarget() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarControllerV3.beamTarget)
  return _internal_beamtarget();
}
inline void AvatarControllerV3::unsafe_arena_set_allocated_beamtarget(
    ::Common::Float3* beamtarget) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.beamtarget_);
  }
  _impl_.beamtarget_ = beamtarget;
  if (beamtarget) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.AvatarControllerV3.beamTarget)
}
inline ::Common::Float3* AvatarControllerV3::release_beamtarget() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Float3* temp = _impl_.beamtarget_;
  _impl_.beamtarget_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* AvatarControllerV3::unsafe_arena_release_beamtarget() {
  // @@protoc_insertion_point(field_release:Transient.AvatarControllerV3.beamTarget)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Float3* temp = _impl_.beamtarget_;
  _impl_.beamtarget_ = nullptr;
  return temp;
}
inline ::Common::Float3* AvatarControllerV3::_internal_mutable_beamtarget() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.beamtarget_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.beamtarget_ = p;
  }
  return _impl_.beamtarget_;
}
inline ::Common::Float3* AvatarControllerV3::mutable_beamtarget() {
  ::Common::Float3* _msg = _internal_mutable_beamtarget();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarControllerV3.beamTarget)
  return _msg;
}
inline void AvatarControllerV3::set_allocated_beamtarget(::Common::Float3* beamtarget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.beamtarget_);
  }
  if (beamtarget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beamtarget));
    if (message_arena != submessage_arena) {
      beamtarget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, beamtarget, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.beamtarget_ = beamtarget;
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarControllerV3.beamTarget)
}

// -------------------------------------------------------------------

// AvatarRootV3

// .Transient.AvatarPositionV3 location = 1;
inline bool AvatarRootV3::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AvatarRootV3::has_location() const {
  return _internal_has_location();
}
inline void AvatarRootV3::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::Transient::AvatarPositionV3& AvatarRootV3::_internal_location() const {
  const ::Transient::AvatarPositionV3* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::Transient::AvatarPositionV3&>(
      ::Transient::_AvatarPositionV3_default_instance_);
}
inline const ::Transient::AvatarPositionV3& AvatarRootV3::location() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarRootV3.location)
  return _internal_location();
}
inline void AvatarRootV3::unsafe_arena_set_allocated_location(
    ::Transient::AvatarPositionV3* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transient.AvatarRootV3.location)
}
inline ::Transient::AvatarPositionV3* AvatarRootV3::release_location() {
  
  ::Transient::AvatarPositionV3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Transient::AvatarPositionV3* AvatarRootV3::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:Transient.AvatarRootV3.location)
  
  ::Transient::AvatarPositionV3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::Transient::AvatarPositionV3* AvatarRootV3::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::Transient::AvatarPositionV3>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::Transient::AvatarPositionV3* AvatarRootV3::mutable_location() {
  ::Transient::AvatarPositionV3* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarRootV3.location)
  return _msg;
}
inline void AvatarRootV3::set_allocated_location(::Transient::AvatarPositionV3* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarRootV3.location)
}

// optional .Transient.AvatarRootV3.AvatarMovementStateEnum animationState = 2;
inline bool AvatarRootV3::_internal_has_animationstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvatarRootV3::has_animationstate() const {
  return _internal_has_animationstate();
}
inline void AvatarRootV3::clear_animationstate() {
  _impl_.animationstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Transient::AvatarRootV3_AvatarMovementStateEnum AvatarRootV3::_internal_animationstate() const {
  return static_cast< ::Transient::AvatarRootV3_AvatarMovementStateEnum >(_impl_.animationstate_);
}
inline ::Transient::AvatarRootV3_AvatarMovementStateEnum AvatarRootV3::animationstate() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarRootV3.animationState)
  return _internal_animationstate();
}
inline void AvatarRootV3::_internal_set_animationstate(::Transient::AvatarRootV3_AvatarMovementStateEnum value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.animationstate_ = value;
}
inline void AvatarRootV3::set_animationstate(::Transient::AvatarRootV3_AvatarMovementStateEnum value) {
  _internal_set_animationstate(value);
  // @@protoc_insertion_point(field_set:Transient.AvatarRootV3.animationState)
}

// optional string animationStateCustom = 3;
inline bool AvatarRootV3::_internal_has_animationstatecustom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvatarRootV3::has_animationstatecustom() const {
  return _internal_has_animationstatecustom();
}
inline void AvatarRootV3::clear_animationstatecustom() {
  _impl_.animationstatecustom_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AvatarRootV3::animationstatecustom() const {
  // @@protoc_insertion_point(field_get:Transient.AvatarRootV3.animationStateCustom)
  return _internal_animationstatecustom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvatarRootV3::set_animationstatecustom(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.animationstatecustom_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Transient.AvatarRootV3.animationStateCustom)
}
inline std::string* AvatarRootV3::mutable_animationstatecustom() {
  std::string* _s = _internal_mutable_animationstatecustom();
  // @@protoc_insertion_point(field_mutable:Transient.AvatarRootV3.animationStateCustom)
  return _s;
}
inline const std::string& AvatarRootV3::_internal_animationstatecustom() const {
  return _impl_.animationstatecustom_.Get();
}
inline void AvatarRootV3::_internal_set_animationstatecustom(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.animationstatecustom_.Set(value, GetArenaForAllocation());
}
inline std::string* AvatarRootV3::_internal_mutable_animationstatecustom() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.animationstatecustom_.Mutable(GetArenaForAllocation());
}
inline std::string* AvatarRootV3::release_animationstatecustom() {
  // @@protoc_insertion_point(field_release:Transient.AvatarRootV3.animationStateCustom)
  if (!_internal_has_animationstatecustom()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.animationstatecustom_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.animationstatecustom_.IsDefault()) {
    _impl_.animationstatecustom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AvatarRootV3::set_allocated_animationstatecustom(std::string* animationstatecustom) {
  if (animationstatecustom != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.animationstatecustom_.SetAllocated(animationstatecustom, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.animationstatecustom_.IsDefault()) {
    _impl_.animationstatecustom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Transient.AvatarRootV3.animationStateCustom)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Transient

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Transient::AvatarRootV3_AvatarMovementStateEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Transient::AvatarRootV3_AvatarMovementStateEnum>() {
  return ::Transient::AvatarRootV3_AvatarMovementStateEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transient_5fevents_5fclient_2eproto
